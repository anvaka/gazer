SCRIPT  /usr/local/share/vim/vim73/scripts.vim
Sourced 1 time
Total time:   0.002435
 Self time:   0.002435

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2010 Jul 29
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000041 if did_filetype()
                              finish
                            endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000014 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000023 let s:cpo_save = &cpo
    1              0.000019 set cpo&vim
                            
    1              0.000011 let s:line1 = getline(1)
                            
    1              0.000015 if s:line1 =~ "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~ '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~ '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~ '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~ '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~ '^csh\>'
                                if exists("g:filetype_csh")
                                  call SetFileTypeShell(g:filetype_csh)
                                else
                                  call SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~ '^tcsh\>'
                                call SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~ '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~ '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~ '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~ 'make\>'
                                set ft=make
                            
                                " Lua
                              elseif s:name =~ 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~ 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~ 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~ 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~ 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~ '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~ 'ruby'
                                set ft=ruby
                            
                                " BC calculator
                              elseif s:name =~ '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~ 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~ 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~ 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~ 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~ 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~ 'cfengine'
                                set ft=cfengine
                            
                              endif
                              unlet s:name
                            
                            else
                              " File does not start with "#!".
                            
    1              0.000007   let s:line2 = getline(2)
    1              0.000005   let s:line3 = getline(3)
    1              0.000005   let s:line4 = getline(4)
    1              0.000006   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000009   if s:line1 =~ '^:$'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " Z shell scripts
                              elseif s:line1 =~ '^#compdef\>' || s:line1 =~ '^#autoload\>'
                                set ft=zsh
                            
                              " ELM Mail files
                              elseif s:line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                                " Mason
                              elseif s:line1 =~ '^<[%&].*>'
                                set ft=mason
                            
                                " Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif s:line1 =~ '^" *[vV]im$'
                                set ft=vim
                            
                                " MOO
                              elseif s:line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                              elseif s:line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\)'
                            	\ || (s:line1 =~ '^--- ' && s:line2 =~ '^+++ ')
                            	\ || (s:line1 =~ '^\* looking for ' && s:line2 =~ '^\* comparing to ')
                            	\ || (s:line1 =~ '^\*\*\* ' && s:line2 =~ '^--- ')
                            	\ || (s:line1 =~ '^=== ' && ((s:line2 =~ '^=\{66\}' && s:line3 =~ '^--- ' && s:line4 =~ '^+++') || (s:line2 =~ '^--- ' && s:line3 =~ '^+++ ')))
                            	\ || (s:line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif s:line1 =~ '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
                              elseif s:line1 =~ '^\s*dnl\>'
                            	\ || s:line2 =~ '^\s*dnl\>'
                            	\ || s:line3 =~ '^\s*dnl\>'
                            	\ || s:line4 =~ '^\s*dnl\>'
                            	\ || s:line5 =~ '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
                              elseif $TERM == "amiga"
                            	\ && (s:line1 =~ "^;" || s:line1 =~ '^\.[bB][rR][aA]')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
                              elseif s:line1 =~ '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
                              elseif s:line1 =~ '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif s:line1 =~ '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                              elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
                              elseif s:line1 =~ '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
                              elseif s:line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
                              elseif s:line1 =~ '^RCS file:' || s:line2 =~ '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
                              elseif s:line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
                              elseif s:line1 =~ '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
                              elseif s:line1 =~ '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
                              elseif s:line1 =~ '^SNNS network definition file'
                                set ft=snnsnet
                              elseif s:line1 =~ '^SNNS pattern definition file'
                                set ft=snnspat
                              elseif s:line1 =~ '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
                              elseif s:line1 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~ '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
                              elseif s:line1 =~ '^\(\[pid \d\+\] \)\=[0-9:.]* *execve(' || s:line1 =~ '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
                              elseif s:line1 =~ '^\* $$ JOB\>' || s:line1 =~ '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
                              elseif s:line4 =~ 'K & K  Associates' || s:line2 =~ 'TAK 2000'
                                set ft=takout
                              elseif s:line3 =~ 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
                              elseif getline(6) =~ 'Run Date: '
                                set ft=takcmp
                              elseif getline(9) =~ 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
                              elseif s:line1.s:line2.s:line3.s:line4 =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
                              elseif s:line1 =~ '|\*\{1,80}' && s:line2 =~ 'VRC '
                            	\ || s:line2 =~ '|\*\{1,80}' && s:line3 =~ 'VRC '
                                set ft=baan
                            
                              " Valgrind
                              elseif s:line1 =~ '^==\d\+== valgrind' || s:line3 =~ '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Renderman Interface Bytestream
                              elseif s:line1 =~ '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
                              elseif s:line1 =~ 'exec\s\+\S*scheme' || s:line2 =~ 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
                              elseif s:line1 =~ '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                              " CVS diff
                              else
    1              0.000007     let s:lnum = 1
    1              0.000014     while getline(s:lnum) =~ "^? " && s:lnum < line("$")
                                  let s:lnum += 1
                                endwhile
    1              0.000014     if getline(s:lnum) =~ '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
                                endif
    1              0.000005     unlet s:lnum
                            
    1              0.000002   endif
                            
    1              0.000006   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000002 endif
                            
                            " Restore 'cpoptions'
    1              0.000017 let &cpo = s:cpo_save
                            
    1              0.000010 unlet s:cpo_save s:line1

SCRIPT  /Users/anvaka/.vim/bundle/nerdtree/syntax/nerdtree.vim
Sourced 2 times
Total time:   0.001126
 Self time:   0.001126

count  total (s)   self (s)
                            let s:tree_up_dir_line = '.. (up a dir)'
                            "NERDTreeFlags are syntax items that should be invisible, but give clues as to
                            "how things should be highlighted
    2              0.000032 syn match NERDTreeFlag #\~#
    2              0.000018 syn match NERDTreeFlag #\[RO\]#
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    2              0.000036 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
                            
                            "highlighting for the ~/+ symbols for the directory nodes
    2              0.000014 syn match NERDTreeClosable #\~\<#
    2              0.000010 syn match NERDTreeClosable #\~\.#
    2              0.000033 syn match NERDTreeOpenable #+\<#
    2              0.000012 syn match NERDTreeOpenable #+\.#he=e-1
                            
                            "highlighting for the tree structural parts
    2              0.000012 syn match NERDTreePart #|#
    2              0.000008 syn match NERDTreePart #`#
    2              0.000023 syn match NERDTreePartFile #[|`]-#hs=s+1 contains=NERDTreePart
                            
                            "quickhelp syntax elements
    2              0.000021 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#hs=s+2,he=e-1
    2              0.000014 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#hs=s+2,he=e-1
    2              0.000020 syn match NERDTreeHelpTitle #" .*\~#hs=s+2,he=e-1 contains=NERDTreeFlag
    2              0.000020 syn match NERDTreeToggleOn #".*(on)#hs=e-2,he=e-1 contains=NERDTreeHelpKey
    2              0.000018 syn match NERDTreeToggleOff #".*(off)#hs=e-3,he=e-1 contains=NERDTreeHelpKey
    2              0.000022 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    2              0.000038 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeFlag,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for readonly files
    2              0.000034 syn match NERDTreeRO #.*\[RO\]#hs=s+2 contains=NERDTreeFlag,NERDTreeBookmark,NERDTreePart,NERDTreePartFile
                            
                            "highlighting for sym links
    2              0.000034 syn match NERDTreeLink #[^-| `].* -> # contains=NERDTreeBookmark,NERDTreeOpenable,NERDTreeClosable,NERDTreeDirSlash
                            
                            "highlighing for directory nodes and file nodes
    2              0.000013 syn match NERDTreeDirSlash #/#
    2              0.000031 syn match NERDTreeDir #[^-| `].*/# contains=NERDTreeLink,NERDTreeDirSlash,NERDTreeOpenable,NERDTreeClosable
    2              0.000039 syn match NERDTreeExecFile  #[|` ].*\*\($\| \)# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark
    2              0.000035 syn match NERDTreeFile  #|-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
    2              0.000032 syn match NERDTreeFile  #`-.*# contains=NERDTreeLink,NERDTreePart,NERDTreeRO,NERDTreePartFile,NERDTreeBookmark,NERDTreeExecFile
    2              0.000014 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    2              0.000021 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
    2              0.000087 syn match NERDTreeBookmarksLeader #^>#
    2              0.000027 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    2              0.000020 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    2              0.000023 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    2              0.000021 if exists("g:NERDChristmasTree") && g:NERDChristmasTree
    2              0.000015     hi def link NERDTreePart Special
    2              0.000009     hi def link NERDTreePartFile Type
    2              0.000007     hi def link NERDTreeFile Normal
    2              0.000008     hi def link NERDTreeExecFile Title
    2              0.000009     hi def link NERDTreeDirSlash Identifier
    2              0.000007     hi def link NERDTreeClosable Type
    2              0.000004 else
                                hi def link NERDTreePart Normal
                                hi def link NERDTreePartFile Normal
                                hi def link NERDTreeFile Normal
                                hi def link NERDTreeClosable Title
                            endif
                            
    2              0.000009 hi def link NERDTreeBookmarksHeader statement
    2              0.000008 hi def link NERDTreeBookmarksLeader ignore
    2              0.000010 hi def link NERDTreeBookmarkName Identifier
    2              0.000007 hi def link NERDTreeBookmark normal
                            
    2              0.000007 hi def link NERDTreeHelp String
    2              0.000008 hi def link NERDTreeHelpKey Identifier
    2              0.000008 hi def link NERDTreeHelpCommand Identifier
    2              0.000007 hi def link NERDTreeHelpTitle Macro
    2              0.000008 hi def link NERDTreeToggleOn Question
    2              0.000017 hi def link NERDTreeToggleOff WarningMsg
                            
    2              0.000008 hi def link NERDTreeDir Directory
    2              0.000008 hi def link NERDTreeUp Directory
    2              0.000007 hi def link NERDTreeCWD Statement
    2              0.000007 hi def link NERDTreeLink Macro
    2              0.000008 hi def link NERDTreeOpenable Title
    2              0.000007 hi def link NERDTreeFlag ignore
    2              0.000008 hi def link NERDTreeRO WarningMsg
    2              0.000007 hi def link NERDTreeBookmark Statement
                            
    2              0.000019 hi def link NERDTreeCurrentNode Search

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/init.vim
Sourced 1 time
Total time:   0.002522
 Self time:   0.002522

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: init.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 19 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000034 let s:save_cpo = &cpo
    1              0.000020 set cpo&vim
                            
    1              0.000015 if !exists('s:is_enabled')
    1              0.000007   let s:is_enabled = 0
    1              0.000002 endif
                            
    1              0.000012 function! neocomplcache#init#lazy() "{{{
                              if !exists('s:lazy_progress')
                                let s:lazy_progress = 0
                              endif
                            
                              if s:lazy_progress == 0
                                call neocomplcache#init#_others()
                                let s:is_enabled = 0
                              elseif s:lazy_progress == 1
                                call neocomplcache#init#_sources(get(g:neocomplcache_sources_list,
                                      \ neocomplcache#get_context_filetype(), ['_']))
                              else
                                call neocomplcache#init#_autocmds()
                                let s:is_enabled = 1
                              endif
                            
                              let s:lazy_progress += 1
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#init#enable() "{{{
                              if neocomplcache#is_enabled()
                                return
                              endif
                            
                              call neocomplcache#init#_autocmds()
                              call neocomplcache#init#_others()
                            
                              call neocomplcache#init#_sources(get(g:neocomplcache_sources_list,
                                    \ neocomplcache#get_context_filetype(), ['_']))
                              let s:is_enabled = 1
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#init#disable() "{{{
                              if !neocomplcache#is_enabled()
                                call neocomplcache#print_warning(
                                      \ 'neocomplcache is disabled! This command is ignored.')
                                return
                              endif
                            
                              let s:is_enabled = 0
                            
                              augroup neocomplcache
                                autocmd!
                              augroup END
                            
                              delcommand NeoComplCacheDisable
                            
                              call neocomplcache#helper#call_hook(filter(values(
                                    \ neocomplcache#variables#get_sources()), 'v:val.loaded'),
                                    \ 'on_final', {})
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#init#is_enabled() "{{{
                              return s:is_enabled
                            endfunction"}}}
                            
    1              0.000012 function! neocomplcache#init#_autocmds() "{{{
                              augroup neocomplcache
                                autocmd!
                                autocmd InsertEnter *
                                      \ call neocomplcache#handler#_on_insert_enter()
                                autocmd InsertLeave *
                                      \ call neocomplcache#handler#_on_insert_leave()
                                autocmd CursorMovedI *
                                      \ call neocomplcache#handler#_on_moved_i()
                                autocmd BufWritePost *
                                      \ call neocomplcache#handler#_on_write_post()
                              augroup END
                            
                              if g:neocomplcache_enable_insert_char_pre
                                    \ && (v:version > 703 || v:version == 703 && has('patch418'))
                                autocmd neocomplcache InsertCharPre *
                                      \ call neocomplcache#handler#_do_auto_complete('InsertCharPre')
                              elseif g:neocomplcache_enable_cursor_hold_i
                                augroup neocomplcache
                                  autocmd CursorHoldI *
                                        \ call neocomplcache#handler#_do_auto_complete('CursorHoldI')
                                  autocmd InsertEnter *
                                        \ call neocomplcache#handler#_change_update_time()
                                  autocmd InsertLeave *
                                        \ call neocomplcache#handler#_restore_update_time()
                                augroup END
                              else
                                autocmd neocomplcache CursorMovedI *
                                      \ call neocomplcache#handler#_do_auto_complete('CursorMovedI')
                              endif
                            
                              if (v:version > 703 || v:version == 703 && has('patch598'))
                                autocmd neocomplcache CompleteDone *
                                      \ call neocomplcache#handler#_on_complete_done()
                              endif
                            endfunction"}}}
                            
    1              0.000013 function! neocomplcache#init#_others() "{{{
                              call neocomplcache#init#_variables()
                            
                              call neocomplcache#context_filetype#initialize()
                            
                              call neocomplcache#commands#_initialize()
                            
                              " Save options.
                              let s:completefunc_save = &completefunc
                              let s:completeopt_save = &completeopt
                            
                              " Set completefunc.
                              let &completefunc = 'neocomplcache#complete#manual_complete'
                            
                              " For auto complete keymappings.
                              call neocomplcache#mappings#define_default_mappings()
                            
                              " Detect set paste.
                              if &paste
                                redir => output
                                99verbose set paste
                                redir END
                                call neocomplcache#print_error(output)
                                call neocomplcache#print_error(
                                      \ 'Detected set paste! Disabled neocomplcache.')
                              endif
                            
                              command! -nargs=0 -bar NeoComplCacheDisable
                                    \ call neocomplcache#init#disable()
                            endfunction"}}}
                            
    1              0.000009 function! neocomplcache#init#_variables() "{{{
                              " Initialize keyword patterns. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_keyword_patterns', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'_',
                                    \'\k\+')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_keyword_patterns',
                                    \'filename',
                                    \ neocomplcache#util#is_windows() ?
                                    \'\%(\a\+:/\)\?\%([/[:alnum:]()$+_~.\x80-\xff-]\|[^[:print:]]\|\\.\)\+' :
                                    \'\%([/\[\][:alnum:]()$+_~.-]\|[^[:print:]]\|\\.\)\+')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'lisp,scheme,clojure,int-gosh,int-clisp,int-clj',
                                    \'[[:alpha:]+*/@$_=.!?-][[:alnum:]+*/@$_:=.!?-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'ruby,int-irb',
                                    \'^=\%(b\%[egin]\|e\%[nd]\)\|\%(@@\|[:$@]\)\h\w*\|\h\w*\%(::\w*\)*[!?]\?')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'php,int-php',
                                    \'</\?\%(\h[[:alnum:]_-]*\s*\)\?\%(/\?>\)\?'.
                                    \'\|\$\h\w*\|\h\w*\%(\%(\\\|::\)\w*\)*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'perl,int-perlsh',
                                    \'<\h\w*>\?\|[$@%&*]\h\w*\|\h\w*\%(::\w*\)*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'perl6,int-perl6',
                                    \'<\h\w*>\?\|[$@%&][!.*?]\?\h[[:alnum:]_-]*'.
                                    \'\|\h[[:alnum:]_-]*\%(::[[:alnum:]_-]*\)*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'pir',
                                    \'[$@%.=]\?\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'pasm',
                                    \'[=]\?\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'vim,help',
                                    \'-\h[[:alnum:]-]*=\?\|\c\[:\%(\h\w*:\]\)\?\|&\h[[:alnum:]_:]*\|'.
                                    \'<SID>\%(\h\w*\)\?\|<Plug>([^)]*)\?'.
                                    \'\|<\h[[:alnum:]_-]*>\?\|\h[[:alnum:]_:#]*!\?\|$\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'tex',
                                    \'\\\a{\a\{1,2}}\|\\[[:alpha:]@][[:alnum:]@]*'.
                                    \'\%({\%([[:alnum:]:_]\+\*\?}\?\)\?\)\?\|\a[[:alnum:]:_]*\*\?')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'sh,zsh,int-zsh,int-bash,int-sh',
                                    \'[[:alpha:]_.-][[:alnum:]_.-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'vimshell',
                                    \'\$\$\?\w*\|[[:alpha:]_.\\/~-][[:alnum:]_.\\/~-]*\|\d\+\%(\.\d\+\)\+')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'ps1,int-powershell',
                                    \'\[\h\%([[:alnum:]_.]*\]::\)\?\|[$%@.]\?[[:alpha:]_.:-][[:alnum:]_.:-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'c',
                                    \'^\s*#\s*\h\w*\|\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'cpp',
                                    \'^\s*#\s*\h\w*\|\h\w*\%(::\w*\)*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'objc',
                                    \'^\s*#\s*\h\w*\|\h\w*\|@\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'objcpp',
                                    \'^\s*#\s*\h\w*\|\h\w*\%(::\w*\)*\|@\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'objj',
                                    \'\h\w*\|@\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'d',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'python,int-python,int-ipython',
                                    \'[@]\?\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'cs',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'java',
                                    \'[@]\?\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'javascript,actionscript,int-js,int-kjs,int-rhino',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'coffee,int-coffee',
                                    \'[@]\?\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'awk',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'haskell,int-ghci',
                                    \'\%(\u\w*\.\)\+[[:alnum:]_'']*\|[[:alpha:]_''][[:alnum:]_'']*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'ml,ocaml,int-ocaml,int-sml,int-smlsharp',
                                    \'[''`#.]\?\h[[:alnum:]_'']*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'erlang,int-erl',
                                    \'^\s*-\h\w*\|\%(\h\w*:\)*\h\w\|\h[[:alnum:]_@]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'html,xhtml,xml,markdown,eruby',
                                    \'</\?\%([[:alnum:]_:-]\+\s*\)\?\%(/\?>\)\?\|&\h\%(\w*;\)\?'.
                                    \'\|\h[[:alnum:]_-]*="\%([^"]*"\?\)\?\|\h[[:alnum:]_:-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'css,stylus,scss,less',
                                    \'[@#.]\?[[:alpha:]_:-][[:alnum:]_:-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'tags',
                                    \'^[^!][^/[:blank:]]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'pic',
                                    \'^\s*#\h\w*\|\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'arm',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'asmh8300',
                                    \'[[:alpha:]_.][[:alnum:]_.]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'masm',
                                    \'\.\h\w*\|[[:alpha:]_@?$][[:alnum:]_@?$]*\|\h\w*:\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'nasm',
                                    \'^\s*\[\h\w*\|[%.]\?\h\w*\|\%(\.\.@\?\|%[%$!]\)\%(\h\w*\)\?\|\h\w*:\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'asm',
                                    \'[%$.]\?\h\w*\%(\$\h\w*\)\?')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'gas',
                                    \'[$.]\?\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'gdb,int-gdb',
                                    \'$\h\w*\|[[:alnum:]:._-]\+')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'make',
                                    \'[[:alpha:]_.-][[:alnum:]_.-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'scala,int-scala',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'int-termtter',
                                    \'\h[[:alnum:]_/-]*\|\$\a\+\|#\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'int-earthquake',
                                    \'[:#$]\h\w*\|\h[[:alnum:]_/-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'dosbatch,int-cmdproxy',
                                    \'\$\w+\|[[:alpha:]_./-][[:alnum:]_.-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'vb',
                                    \'\h\w*\|#\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'lua',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \ 'zimbu',
                                    \'\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'konoha',
                                    \'[*$@%]\h\w*\|\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'cobol',
                                    \'\a[[:alnum:]-]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'coq',
                                    \'\h[[:alnum:]_'']*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'tcl',
                                    \'[.-]\h\w*\|\h\w*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_keyword_patterns',
                                    \'nyaos,int-nyaos',
                                    \'\h\w*')
                              "}}}
                            
                              " Initialize next keyword patterns. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_next_keyword_patterns', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_next_keyword_patterns', 'perl',
                                    \'\h\w*>')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_next_keyword_patterns', 'perl6',
                                    \'\h\w*>')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_next_keyword_patterns', 'vim,help',
                                    \'\w*()\?\|\w*:\]\|[[:alnum:]_-]*[)>=]')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_next_keyword_patterns', 'python',
                                    \'\w*()\?')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_next_keyword_patterns', 'tex',
                                    \'[[:alnum:]:_]\+[*[{}]')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_next_keyword_patterns', 'html,xhtml,xml,mkd',
                                    \'[[:alnum:]_:-]*>\|[^"]*"')
                              "}}}
                            
                              " Initialize same file type lists. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_same_filetype_lists', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'c', 'cpp')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'cpp', 'c')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'erb', 'ruby,html,xhtml')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'html,xml', 'xhtml')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'html,xhtml', 'css,stylus,less')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'css', 'scss')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'scss', 'css')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'stylus', 'css')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'less', 'css')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'xhtml', 'html,xml')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'help', 'vim')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'tex', 'bib,plaintex')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'plaintex', 'bib,tex')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'lingr-say', 'lingr-messages,lingr-members')
                            
                              " Interactive filetypes.
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-irb', 'ruby')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-ghci,int-hugs', 'haskell')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-python,int-ipython', 'python')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-gosh', 'scheme')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-clisp', 'lisp')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-erl', 'erlang')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-zsh', 'zsh')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-bash', 'bash')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-sh', 'sh')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-cmdproxy', 'dosbatch')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-powershell', 'powershell')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-perlsh', 'perl')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-perl6', 'perl6')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-ocaml', 'ocaml')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-clj', 'clojure')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-sml,int-smlsharp', 'sml')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-js,int-kjs,int-rhino', 'javascript')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-coffee', 'coffee')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-gdb', 'gdb')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-scala', 'scala')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-nyaos', 'nyaos')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_same_filetype_lists',
                                    \ 'int-php', 'php')
                              "}}}
                            
                              " Initialize delimiter patterns. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_delimiter_patterns', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'vim,help', ['#'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'erlang,lisp,int-clisp', [':'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'lisp,int-clisp', ['/', ':'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'clojure,int-clj', ['/', '\.'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'perl,cpp', ['::'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'php', ['\', '::'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'java,d,javascript,actionscript,'.
                                    \ 'ruby,eruby,haskell,int-ghci,coffee,zimbu,konoha',
                                    \ ['\.'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'lua', ['\.', ':'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_delimiter_patterns',
                                    \ 'perl6', ['\.', '::'])
                              "}}}
                            
                              " Initialize ctags arguments. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_ctags_arguments_list', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_ctags_arguments_list',
                                    \ '_', '')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_ctags_arguments_list', 'vim',
                                    \ '--extra=fq --fields=afmiKlnsStz ' .
                                    \ "--regex-vim='/function!? ([a-z#:_0-9A-Z]+)/\\1/function/'")
                              if neocomplcache#util#is_mac()
                                call neocomplcache#util#set_default_dictionary(
                                      \ 'g:neocomplcache_ctags_arguments_list', 'c',
                                      \ '--c-kinds=+p --fields=+iaS --extra=+q
                                      \ -I__DARWIN_ALIAS,__DARWIN_ALIAS_C,__DARWIN_ALIAS_I,__DARWIN_INODE64
                                      \ -I__DARWIN_1050,__DARWIN_1050ALIAS,__DARWIN_1050ALIAS_C,__DARWIN_1050ALIAS_I,__DARWIN_1050INODE64
                                      \ -I__DARWIN_EXTSN,__DARWIN_EXTSN_C
                                      \ -I__DARWIN_LDBL_COMPAT,__DARWIN_LDBL_COMPAT2')
                              else
                                call neocomplcache#util#set_default_dictionary(
                                      \ 'g:neocomplcache_ctags_arguments_list', 'c',
                                      \ '-R --sort=1 --c-kinds=+p --fields=+iaS --extra=+q ' .
                                      \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
                                      \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                              endif
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_ctags_arguments_list', 'cpp',
                                    \ '--language-force=C++ -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q '.
                                    \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
                                    \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                              "}}}
                            
                              " Initialize text mode filetypes. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_text_mode_filetypes', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_text_mode_filetypes',
                                    \ 'text,help,tex,gitcommit,vcs-commit', 1)
                              "}}}
                            
                              " Initialize tags filter patterns. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_tags_filter_patterns', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_tags_filter_patterns', 'c,cpp',
                                    \'v:val.word !~ ''^[~_]''')
                              "}}}
                            
                              " Initialize force omni completion pattern. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_force_omni_patterns', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_force_omni_patterns', 'objc',
                                    \'\h\w\+\|[^.[:digit:] *\t]\%(\.\|->\)')
                              "}}}
                            
                              " Initialize ignore composite filetypes
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_ignore_composite_filetype_lists', {})
                            
                              " Must g:neocomplcache_auto_completion_start_length > 1.
                              if g:neocomplcache_auto_completion_start_length < 1
                                let g:neocomplcache_auto_completion_start_length = 1
                              endif
                              " Must g:neocomplcache_min_keyword_length > 1.
                              if g:neocomplcache_min_keyword_length < 1
                                let g:neocomplcache_min_keyword_length = 1
                              endif
                            
                              " Initialize omni function list. "{{{
                              if !exists('g:neocomplcache_omni_functions')
                                let g:neocomplcache_omni_functions = {}
                              endif
                              "}}}
                            
                              " Set custom.
                              call s:set_default_custom()
                            endfunction"}}}
                            
    1              0.000013 function! neocomplcache#init#_current_neocomplcache() "{{{
                              let b:neocomplcache = {
                                    \ 'context' : {
                                    \      'input' : '',
                                    \      'complete_pos' : -1,
                                    \      'complete_str' : '',
                                    \      'candidates' : [],
                                    \ },
                                    \ 'lock' : 0,
                                    \ 'skip_next_complete' : 0,
                                    \ 'filetype' : '',
                                    \ 'context_filetype' : '',
                                    \ 'context_filetype_range' :
                                    \    [[1, 1], [line('$'), len(getline('$'))+1]],
                                    \ 'completion_length' : -1,
                                    \ 'update_time_save' : &updatetime,
                                    \ 'foldinfo' : [],
                                    \ 'lock_sources' : {},
                                    \ 'skipped' : 0,
                                    \ 'event' : '',
                                    \ 'cur_text' : '',
                                    \ 'old_cur_text' : '',
                                    \ 'complete_str' : '',
                                    \ 'complete_pos' : -1,
                                    \ 'candidates' : [],
                                    \ 'complete_results' : [],
                                    \ 'complete_sources' : [],
                                    \ 'manual_sources' : [],
                                    \ 'start_time' : reltime(),
                                    \}
                            endfunction"}}}
                            
    1              0.000009 function! neocomplcache#init#_sources(names) "{{{
                              if !exists('s:loaded_source_files')
                                " Initialize.
                                let s:loaded_source_files = {}
                                let s:loaded_all_sources = 0
                                let s:runtimepath_save = ''
                              endif
                            
                              " Initialize sources table.
                              if s:loaded_all_sources && &runtimepath ==# s:runtimepath_save
                                return
                              endif
                            
                              let runtimepath_save = neocomplcache#util#split_rtp(s:runtimepath_save)
                              let runtimepath = neocomplcache#util#join_rtp(
                                    \ filter(neocomplcache#util#split_rtp(),
                                    \ 'index(runtimepath_save, v:val) < 0'))
                              let sources = neocomplcache#variables#get_sources()
                            
                              for name in filter(copy(a:names), '!has_key(sources, v:val)')
                                " Search autoload.
                                for source_name in map(split(globpath(runtimepath,
                                      \ 'autoload/neocomplcache/sources/*.vim'), '\n'),
                                      \ "fnamemodify(v:val, ':t:r')")
                                  if has_key(s:loaded_source_files, source_name)
                                    continue
                                  endif
                            
                                  let s:loaded_source_files[source_name] = 1
                            
                                  let source = neocomplcache#sources#{source_name}#define()
                                  if empty(source)
                                    " Ignore.
                                    continue
                                  endif
                            
                                  call neocomplcache#define_source(source)
                                endfor
                            
                                if name == '_'
                                  let s:loaded_all_sources = 1
                                  let s:runtimepath_save = &runtimepath
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#init#_source(source) "{{{
                              let default = {
                                    \ 'max_candidates' : 0,
                                    \ 'filetypes' : {},
                                    \ 'hooks' : {},
                                    \ 'matchers' : ['matcher_old'],
                                    \ 'sorters' : ['sorter_rank'],
                                    \ 'converters' : [
                                    \      'converter_remove_next_keyword',
                                    \      'converter_delimiter',
                                    \      'converter_case',
                                    \      'converter_abbr',
                                    \ ],
                                    \ 'neocomplcache__context' : copy(neocomplcache#get_context()),
                                    \ }
                            
                              let source = extend(copy(default), a:source)
                            
                              " Overwritten by user custom.
                              let custom = neocomplcache#variables#get_custom().sources
                              let source = extend(source, get(custom, source.name,
                                    \ get(custom, '_', {})))
                            
                              let source.loaded = 0
                              " Source kind convertion.
                              if source.kind ==# 'plugin' ||
                                    \ (!has_key(source, 'gather_candidates') &&
                                    \  !has_key(source, 'get_complete_words'))
                                let source.kind = 'keyword'
                              elseif source.kind ==# 'ftplugin' || source.kind ==# 'complfunc'
                                " For compatibility.
                                let source.kind = 'manual'
                              else
                                let source.kind = 'manual'
                              endif
                            
                              if !has_key(source, 'rank')
                                " Set default rank.
                                let source.rank = (source.kind ==# 'keyword') ? 5 :
                                      \ empty(source.filetypes) ? 10 : 100
                              endif
                            
                              if !has_key(source, 'min_pattern_length')
                                " Set min_pattern_length.
                                let source.min_pattern_length = (source.kind ==# 'keyword') ?
                                      \ g:neocomplcache_auto_completion_start_length : 0
                              endif
                            
                              let source.neocomplcache__context.source_name = source.name
                            
                              " Note: This routine is for compatibility of old sources implementation.
                              " Initialize sources.
                              if empty(source.filetypes) && has_key(source, 'initialize')
                                try
                                  call source.initialize()
                                catch
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  call neocomplcache#print_error(
                                        \ 'Error occured in source''s initialize()!')
                                  call neocomplcache#print_error(
                                        \ 'Source name is ' . source.name)
                                endtry
                            
                                let source.loaded = 1
                              endif
                            
                              return source
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#init#_filters(names) "{{{
                              let _ = []
                              let filters = neocomplcache#variables#get_filters()
                            
                              for name in a:names
                                if !has_key(filters, name)
                                  " Search autoload.
                                  for filter_name in map(split(globpath(&runtimepath,
                                        \ 'autoload/neocomplcache/filters/'.
                                        \   substitute(name,
                                        \'^\%(matcher\|sorter\|converter\)_[^/_-]\+\zs[/_-].*$', '', '')
                                        \  .'*.vim'), '\n'), "fnamemodify(v:val, ':t:r')")
                                    let filter = neocomplcache#filters#{filter_name}#define()
                                    if empty(filter)
                                      " Ignore.
                                      continue
                                    endif
                            
                                    call neocomplcache#define_filter(filter)
                                  endfor
                            
                                  if !has_key(filters, name)
                                    " Not found.
                                    call neocomplcache#print_error(
                                          \ printf('filter name : %s is not found.', string(name)))
                                    continue
                                  endif
                                endif
                            
                                if has_key(filters, name)
                                  call add(_, filters[name])
                                endif
                              endfor
                            
                              return _
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#init#_filter(filter) "{{{
                              let default = {
                                    \ }
                            
                              let filter = extend(default, a:filter)
                              if !has_key(filter, 'kind')
                                let filter.kind =
                                      \ (filter.name =~# '^matcher_') ? 'matcher' :
                                      \ (filter.name =~# '^sorter_') ? 'sorter' : 'converter'
                              endif
                            
                              return filter
                            endfunction"}}}
                            
    1              0.000011 function! s:set_default_custom() "{{{
                              let custom = neocomplcache#variables#get_custom().sources
                            
                              " Initialize completion length.
                              for [source_name, length] in items(
                                    \ g:neocomplcache_source_completion_length)
                                if !has_key(custom, source_name)
                                  let custom[source_name] = {}
                                endif
                                let custom[source_name].min_pattern_length = length
                              endfor
                            
                              " Initialize rank.
                              for [source_name, rank] in items(
                                    \ g:neocomplcache_source_rank)
                                if !has_key(custom, source_name)
                                  let custom[source_name] = {}
                                endif
                                let custom[source_name].rank = rank
                              endfor
                            endfunction"}}}
                            
    1              0.000024 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/util.vim
Sourced 1 time
Total time:   0.174543
 Self time:   0.001144

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: util.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 25 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000025 let s:save_cpo = &cpo
    1              0.000014 set cpo&vim
                            
    1   0.063846   0.000021 let s:V = vital#of('neocomplcache')
    1   0.035928   0.000028 let s:List = vital#of('neocomplcache').import('Data.List')
    1   0.073702   0.000028 let s:String = vital#of('neocomplcache').import('Data.String')
                            
    1              0.000005 function! neocomplcache#util#truncate_smart(...) "{{{
                              return call(s:V.truncate_smart, a:000)
                            endfunction"}}}
                            
    1              0.000002 function! neocomplcache#util#truncate(...) "{{{
                              return call(s:V.truncate, a:000)
                            endfunction"}}}
                            
    1              0.000003 function! neocomplcache#util#strchars(...) "{{{
                              return call(s:String.strchars, a:000)
                            endfunction"}}}
    1              0.000003 function! neocomplcache#util#wcswidth(...) "{{{
                              return call(s:V.wcswidth, a:000)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#strwidthpart(...) "{{{
                              return call(s:V.strwidthpart, a:000)
                            endfunction"}}}
    1              0.000003 function! neocomplcache#util#strwidthpart_reverse(...) "{{{
                              return call(s:V.strwidthpart_reverse, a:000)
                            endfunction"}}}
                            
    1              0.000003 function! neocomplcache#util#substitute_path_separator(...) "{{{
                              return call(s:V.substitute_path_separator, a:000)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#mb_strlen(...) "{{{
                              return call(s:String.strchars, a:000)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#uniq(list) "{{{
                              let dict = {}
                              for item in a:list
                                if !has_key(dict, item)
                                  let dict[item] = item
                                endif
                              endfor
                            
                              return values(dict)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#system(...) "{{{
                              return call(s:V.system, a:000)
                            endfunction"}}}
    1              0.000003 function! neocomplcache#util#has_vimproc(...) "{{{
                              return call(s:V.has_vimproc, a:000)
                            endfunction"}}}
    1              0.000003 function! neocomplcache#util#has_lua() "{{{
                              " Note: Disabled if_lua feature if less than 7.3.885.
                              " Because if_lua has double free problem.
                              return has('lua') && (v:version > 703 || v:version == 703 && has('patch885'))
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#is_windows(...) "{{{
                              return call(s:V.is_windows, a:000)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#is_mac(...) "{{{
                              return call(s:V.is_mac, a:000)
                            endfunction"}}}
    1              0.000003 function! neocomplcache#util#get_last_status(...) "{{{
                              return call(s:V.get_last_status, a:000)
                            endfunction"}}}
    1              0.000003 function! neocomplcache#util#escape_pattern(...) "{{{
                              return call(s:V.escape_pattern, a:000)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#iconv(...) "{{{
                              return call(s:V.iconv, a:000)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#uniq(...) "{{{
                              return call(s:List.uniq, a:000)
                            endfunction"}}}
    1              0.000002 function! neocomplcache#util#sort_by(...)
                              return call(s:List.sort_by, a:000)
                            endfunction
                            
    1              0.000003 function! neocomplcache#util#glob(pattern, ...) "{{{
                              if a:pattern =~ "'"
                                " Use glob('*').
                                let cwd = getcwd()
                                let base = neocomplcache#util#substitute_path_separator(
                                      \ fnamemodify(a:pattern, ':h'))
                                execute 'lcd' fnameescape(base)
                            
                                let files = map(split(neocomplcache#util#substitute_path_separator(
                                      \ glob('*')), '\n'), "base . '/' . v:val")
                            
                                execute 'lcd' fnameescape(cwd)
                            
                                return files
                              endif
                            
                              " let is_force_glob = get(a:000, 0, 0)
                              let is_force_glob = get(a:000, 0, 1)
                            
                              if !is_force_glob && a:pattern =~ '^[^\\*]\+/\*'
                                    \ && neocomplcache#util#has_vimproc() && exists('*vimproc#readdir')
                                return filter(vimproc#readdir(a:pattern[: -2]), 'v:val !~ "/\\.\\.\\?$"')
                              else
                                " Escape [.
                                if neocomplcache#util#is_windows()
                                  let glob = substitute(a:pattern, '\[', '\\[[]', 'g')
                                else
                                  let glob = escape(a:pattern, '[')
                                endif
                            
                                return split(neocomplcache#util#substitute_path_separator(glob(glob)), '\n')
                              endif
                            endfunction"}}}
    1              0.000024 function! neocomplcache#util#expand(path) "{{{
                              return expand(escape(a:path, '*?[]"={}'), 1)
                            endfunction"}}}
                            
    1              0.000016 function! neocomplcache#util#set_default(var, val, ...)  "{{{
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let alternate_var = get(a:000, 0, '')
                            
                                let {a:var} = exists(alternate_var) ?
                                      \ {alternate_var} : a:val
                              endif
                            endfunction"}}}
    1              0.000014 function! neocomplcache#util#set_dictionary_helper(...) "{{{
                              return call(s:V.set_dictionary_helper, a:000)
                            endfunction"}}}
                            
    1              0.000009 function! neocomplcache#util#set_default_dictionary(variable, keys, value) "{{{
                              if !exists('s:disable_dictionaries')
                                let s:disable_dictionaries = {}
                              endif
                            
                              if has_key(s:disable_dictionaries, a:variable)
                                return
                              endif
                            
                              call neocomplcache#util#set_dictionary_helper({a:variable}, a:keys, a:value)
                            endfunction"}}}
    1              0.000009 function! neocomplcache#util#disable_default_dictionary(variable) "{{{
                              if !exists('s:disable_dictionaries')
                                let s:disable_dictionaries = {}
                              endif
                            
                              let s:disable_dictionaries[a:variable] = 1
                            endfunction"}}}
                            
    1              0.000014 function! neocomplcache#util#split_rtp(...) "{{{
                              let rtp = a:0 ? a:1 : &runtimepath
                              if type(rtp) == type([])
                                return rtp
                              endif
                            
                              if rtp !~ '\\'
                                return split(rtp, ',')
                              endif
                            
                              let split = split(rtp, '\\\@<!\%(\\\\\)*\zs,')
                              return map(split,'substitute(v:val, ''\\\([\\,]\)'', "\\1", "g")')
                            endfunction"}}}
    1              0.000007 function! neocomplcache#util#join_rtp(list) "{{{
                              return join(map(copy(a:list), 's:escape(v:val)'), ',')
                            endfunction"}}}
                            " Escape a path for runtimepath.
    1              0.000008 function! s:escape(path)"{{{
                              return substitute(a:path, ',\|\\,\@=', '\\\0', 'g')
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#util#has_vimproc() "{{{
                              " Initialize.
                              if !exists('g:neocomplcache_use_vimproc')
                                " Check vimproc.
                                try
                                  call vimproc#version()
                                  let exists_vimproc = 1
                                catch
                                  let exists_vimproc = 0
                                endtry
                            
                                let g:neocomplcache_use_vimproc = exists_vimproc
                              endif
                            
                              return g:neocomplcache_use_vimproc
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#util#dup_filter(list) "{{{
                              let dict = {}
                              for keyword in a:list
                                if !has_key(dict, keyword.word)
                                  let dict[keyword.word] = keyword
                                endif
                              endfor
                            
                              return values(dict)
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#util#convert2list(expr) "{{{
                              return type(a:expr) ==# type([]) ? a:expr : [a:expr]
                            endfunction"}}}
                            
    1              0.000025 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/vital/_a477c91.vim
Sourced 1 time
Total time:   0.000844
 Self time:   0.000844

count  total (s)   self (s)
                            let s:self_version = expand('<sfile>:t:r')
                            
    1              0.000005 let s:loaded = {}
                            
    1              0.000010 function! s:import(name, ...)
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = s:_import(a:name, s:_scripts())
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
                            
    1              0.000005 function! s:load(...) dict
                              let scripts = s:_scripts()
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                while 1 <= len(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == type({})
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                            
                                if exists('dict')
                                  call extend(dict, s:_import(name, scripts))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
                            
    1              0.000005 function! s:unload()
                              let s:loaded = {}
                            endfunction
                            
    1              0.000005 function! s:_import(name, scripts)
                              if type(a:name) == type(0)
                                return s:_build_module(a:name)
                              endif
                              let path = s:_get_module_path(a:name)
                              if path ==# ''
                                throw 'vital: module not found: ' . a:name
                              endif
                              let sid = get(a:scripts, path, 0)
                              if !sid
                                try
                                  execute 'source' fnameescape(path)
                                catch /^Vim\%((\a\+)\)\?:E484/
                                  throw 'vital: module not found: ' . a:name
                                catch /^Vim\%((\a\+)\)\?:E127/
                                  " Ignore.
                                endtry
                            
                                let sid = len(a:scripts) + 1  " We expect that the file newly read is +1.
                                let a:scripts[path] = sid
                              endif
                              return s:_build_module(sid)
                            endfunction
                            
    1              0.000005 function! s:_get_module_path(name)
                              if filereadable(a:name)
                                return s:_unify_path(a:name)
                              endif
                              if a:name ==# ''
                                let tailpath = printf('autoload/vital/%s.vim', s:self_version)
                              elseif a:name =~# '\v^\u\a*%(\.\u\a*)*$'
                                let target = '/' . substitute(a:name, '\W\+', '/', 'g')
                                let target = substitute(target, '\l\zs\ze\u', '_', 'g') " OrderedSet -> Ordered_Set
                                let target = substitute(target, '[/_]\zs\u', '\l\0', 'g') " Ordered_Set -> ordered_set
                                let tailpath = printf('autoload/vital/%s%s.vim', s:self_version, target)
                              else
                                let tailpath = a:name
                              endif
                            
                              " Note: The extra argument to globpath() was added in Patch 7.2.051.
                              if v:version > 702 || v:version == 702 && has('patch51')
                                let paths = split(globpath(&runtimepath, tailpath, 1), "\n")
                              else
                                let paths = split(globpath(&runtimepath, tailpath), "\n")
                              endif
                              call filter(paths, 'filereadable(v:val)')
                              return s:_unify_path(get(paths, 0, ''))
                            endfunction
                            
    1              0.000005 function! s:_scripts()
                              let scripts = {}
                              for line in split(s:_redir('scriptnames'), "\n")
                                let list = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if !empty(list)
                                  let scripts[s:_unify_path(list[2])] = list[1] - 0
                                endif
                              endfor
                              return scripts
                            endfunction
                            
    1              0.000065 if filereadable(expand('<sfile>:r') . '.VIM')
    1              0.000008   function! s:_unify_path(path)
                                " Note: On windows, vim can't expand path names from 8.3 formats.
                                " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                                " vital load duplicated scripts. Below's :~ avoid this issue.
                                return tolower(fnamemodify(resolve(fnamemodify(
                                \              a:path, ':p:gs?[\\/]\+?/?')), ':~'))
                              endfunction
    1              0.000004 else
                              function! s:_unify_path(path)
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]\+?/?'))
                              endfunction
                            endif
                            
    1              0.000005 function! s:_build_module(sid)
                              if has_key(s:loaded, a:sid)
                                return copy(s:loaded[a:sid])
                              endif
                              let prefix = '<SNR>' . a:sid . '_'
                              let funcs = s:_redir('function')
                              let filter_pat = '^\s*function ' . prefix
                              let map_pat = prefix . '\zs\w\+'
                              let functions = map(filter(split(funcs, "\n"), 'v:val =~# filter_pat'),
                              \          'matchstr(v:val, map_pat)')
                            
                              let module = {}
                              for func in functions
                                let module[func] = function(prefix . func)
                              endfor
                              if has_key(module, '_vital_loaded')
                                let V = vital#{s:self_version}#new()
                                if has_key(module, '_vital_depends')
                                  call call(V.load, module._vital_depends(), V)
                                endif
                                try
                                  call module._vital_loaded(V)
                                catch
                                  " FIXME: Show an error message for debug.
                                endtry
                              endif
                              if !get(g:, 'vital_debug', 0)
                                call filter(module, 'v:key =~# "^\\a"')
                              endif
                              let s:loaded[a:sid] = module
                              return copy(module)
                            endfunction
                            
    1              0.000012 function! s:_redir(cmd)
                              let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
                              set verbose=0 verbosefile=
                              redir => res
                                silent! execute a:cmd
                              redir END
                              let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
                              return res
                            endfunction
                            
    1              0.000016 function! vital#{s:self_version}#new()
                              return s:_import('', s:_scripts()).load(['Prelude', ''])
                            endfunction

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/vital/_a477c91/prelude.vim
Sourced 1 time
Total time:   0.000842
 Self time:   0.000842

count  total (s)   self (s)
                            let s:save_cpo = &cpo
    1              0.000012 set cpo&vim
                            
                            " glob() wrapper which returns List
                            " and 'wildignore' does not affect
                            " this function's return value.
    1              0.000011 if v:version ># 703 ||
                            \  (v:version is 703 && has('patch465'))
                              function! s:glob(expr)
                                return glob(a:expr, 1, 1)
                              endfunction
                            else
    1              0.000004   function! s:glob(expr)
                                let R = glob(a:expr, 1)
                                return split(R, '\n')
                              endfunction
    1              0.000002 endif
                            " globpath() wrapper which returns List
                            " and 'suffixes' and 'wildignore' does not affect
                            " this function's return value.
    1              0.000003 function! s:globpath(path, expr)
                              let R = globpath(a:path, a:expr, 1)
                              return split(R, '\n')
                            endfunction
                            
                            " Wrapper functions for type().
    1              0.000044 let [
                            \   s:__TYPE_NUMBER,
                            \   s:__TYPE_STRING,
                            \   s:__TYPE_FUNCREF,
                            \   s:__TYPE_LIST,
                            \   s:__TYPE_DICT,
                            \   s:__TYPE_FLOAT
                            \] = [
                            \   type(3),
                            \   type(""),
                            \   type(function('tr')),
                            \   type([]),
                            \   type({}),
                            \   has('float') ? type(str2float('0')) : -1
                            \]
                            " __TYPE_FLOAT = -1 when -float
                            " This doesn't match to anything.
                            
                            " Number or Float
    1              0.000004 function! s:is_numeric(Value)
                              let _ = type(a:Value)
                              return _ ==# s:__TYPE_NUMBER
                              \   || _ ==# s:__TYPE_FLOAT
                            endfunction
                            " Number
    1              0.000003 function! s:is_integer(Value)
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
    1              0.000002 function! s:is_number(Value)
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
                            " Float
    1              0.000003 function! s:is_float(Value)
                              return type(a:Value) ==# s:__TYPE_FLOAT
                            endfunction
                            " String
    1              0.000003 function! s:is_string(Value)
                              return type(a:Value) ==# s:__TYPE_STRING
                            endfunction
                            " Funcref
    1              0.000002 function! s:is_funcref(Value)
                              return type(a:Value) ==# s:__TYPE_FUNCREF
                            endfunction
                            " List
    1              0.000003 function! s:is_list(Value)
                              return type(a:Value) ==# s:__TYPE_LIST
                            endfunction
                            " Dictionary
    1              0.000002 function! s:is_dict(Value)
                              return type(a:Value) ==# s:__TYPE_DICT
                            endfunction
                            
    1              0.000004 function! s:truncate_smart(str, max, footer_width, separator)
                              let width = s:wcswidth(a:str)
                              if width <= a:max
                                let ret = a:str
                              else
                                let header_width = a:max - s:wcswidth(a:separator) - a:footer_width
                                let ret = s:strwidthpart(a:str, header_width) . a:separator
                                      \ . s:strwidthpart_reverse(a:str, a:footer_width)
                              endif
                            
                              return s:truncate(ret, a:max)
                            endfunction
                            
    1              0.000003 function! s:truncate(str, width)
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
                              if a:str =~# '^[\x00-\x7f]*$'
                                return len(a:str) < a:width ?
                                      \ printf('%-'.a:width.'s', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = s:wcswidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000003 function! s:strwidthpart(str, width)
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '.$')
                                let ret = ret[: -1 - len(char)]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
    1              0.000004 function! s:strwidthpart_reverse(str, width)
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '^.')
                                let ret = ret[len(char) :]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
                            
    1              0.000002 if v:version >= 703
                              " Use builtin function.
    1              0.000003   function! s:wcswidth(str)
                                return strwidth(a:str)
                              endfunction
    1              0.000002 else
                              function! s:wcswidth(str)
                                if a:str =~# '^[\x00-\x7f]*$'
                                  return strlen(a:str)
                                end
                            
                                let mx_first = '^\(.\)'
                                let str = a:str
                                let width = 0
                                while 1
                                  let ucs = char2nr(substitute(str, mx_first, '\1', ''))
                                  if ucs == 0
                                    break
                                  endif
                                  let width += s:_wcwidth(ucs)
                                  let str = substitute(str, mx_first, '', '')
                                endwhile
                                return width
                              endfunction
                            
                              " UTF-8 only.
                              function! s:_wcwidth(ucs)
                                let ucs = a:ucs
                                if (ucs >= 0x1100
                                      \  && (ucs <= 0x115f
                                      \  || ucs == 0x2329
                                      \  || ucs == 0x232a
                                      \  || (ucs >= 0x2e80 && ucs <= 0xa4cf
                                      \      && ucs != 0x303f)
                                      \  || (ucs >= 0xac00 && ucs <= 0xd7a3)
                                      \  || (ucs >= 0xf900 && ucs <= 0xfaff)
                                      \  || (ucs >= 0xfe30 && ucs <= 0xfe6f)
                                      \  || (ucs >= 0xff00 && ucs <= 0xff60)
                                      \  || (ucs >= 0xffe0 && ucs <= 0xffe6)
                                      \  || (ucs >= 0x20000 && ucs <= 0x2fffd)
                                      \  || (ucs >= 0x30000 && ucs <= 0x3fffd)
                                      \  ))
                                  return 2
                                endif
                                return 1
                              endfunction
                            endif
                            
    1              0.000017 let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')
    1              0.000006 let s:is_cygwin = has('win32unix')
    1              0.000013 let s:is_mac = !s:is_windows && !s:is_cygwin
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
    1              0.000005 let s:is_unix = has('unix')
    1              0.000003 function! s:is_windows()
                              return s:is_windows
                            endfunction
    1              0.000003 function! s:is_cygwin()
                              return s:is_cygwin
                            endfunction
    1              0.000003 function! s:is_mac()
                              return s:is_mac
                            endfunction
    1              0.000002 function! s:is_unix()
                              return s:is_unix
                            endfunction
                            
    1              0.000003 function! s:print_error(message)
                              echohl ErrorMsg
                              for m in split(a:message, "\n")
                                echomsg m
                              endfor
                              echohl None
                            endfunction
                            
    1              0.000004 function! s:smart_execute_command(action, word)
                              execute a:action . ' ' . (a:word == '' ? '' : '`=a:word`')
                            endfunction
                            
    1              0.000004 function! s:escape_file_searching(buffer_name)
                              return escape(a:buffer_name, '*[]?{}, ')
                            endfunction
    1              0.000003 function! s:escape_pattern(str)
                              return escape(a:str, '~"\.^$[]*')
                            endfunction
                            " iconv() wrapper for safety.
    1              0.000003 function! s:iconv(expr, from, to)
                              if a:from == '' || a:to == '' || a:from ==? a:to
                                return a:expr
                              endif
                              let result = iconv(a:expr, a:from, a:to)
                              return result != '' ? result : a:expr
                            endfunction
                            " Like builtin getchar() but returns string always.
    1              0.000003 function! s:getchar(...)
                              let c = call('getchar', a:000)
                              return type(c) == type(0) ? nr2char(c) : c
                            endfunction
                            " Like builtin getchar() but returns string always.
                            " and do inputsave()/inputrestore() before/after getchar().
    1              0.000003 function! s:getchar_safe(...)
                              let c = s:input_helper('getchar', a:000)
                              return type(c) == type("") ? c : nr2char(c)
                            endfunction
                            " Like builtin getchar() but
                            " do inputsave()/inputrestore() before/after input().
    1              0.000002 function! s:input_safe(...)
                                return s:input_helper('input', a:000)
                            endfunction
                            " Do inputsave()/inputrestore() before/after calling a:funcname.
    1              0.000007 function! s:input_helper(funcname, args)
                                let success = 0
                                if inputsave() !=# success
                                    throw 'inputsave() failed'
                                endif
                                try
                                    return call(a:funcname, a:args)
                                finally
                                    if inputrestore() !=# success
                                        throw 'inputrestore() failed'
                                    endif
                                endtry
                            endfunction
                            
    1              0.000003 function! s:set_default(var, val)
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let {a:var} = a:val
                              endif
                            endfunction
    1              0.000003 function! s:set_dictionary_helper(variable, keys, pattern)
                              for key in split(a:keys, '\s*,\s*')
                                if !has_key(a:variable, key)
                                  let a:variable[key] = a:pattern
                                endif
                              endfor
                            endfunction
    1              0.000003 function! s:substitute_path_separator(path)
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction
    1              0.000003 function! s:path2directory(path)
                              return s:substitute_path_separator(isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))
                            endfunction
    1              0.000006 function! s:path2project_directory(path, ...)
                              let is_allow_empty = get(a:000, 0, 0)
                              let search_directory = s:path2directory(a:path)
                              let directory = ''
                            
                              " Search VCS directory.
                              for vcs in ['.git', '.bzr', '.hg', '.svn']
                                let find_directory = s:escape_file_searching(search_directory)
                                let d = finddir(vcs, find_directory . ';')
                                if d == ''
                                  continue
                                endif
                            
                                let directory = fnamemodify(d, ':p:h:h')
                            
                                if vcs ==# '.svn'
                                  " Search parent directories.
                                  let parent_directory = s:path2directory(
                                        \ fnamemodify(directory, ':h'))
                            
                                  if parent_directory != ''
                                    let d = finddir(vcs, parent_directory . ';')
                                    if d != ''
                                      let directory = s:path2project_directory(parent_directory)
                                    endif
                                  endif
                                endif
                              endfor
                            
                              " Search project file.
                              if directory == ''
                                for d in ['build.xml', 'prj.el', '.project', 'pom.xml',
                                      \ 'Makefile', 'configure', 'Rakefile', 'NAnt.build', 'tags', 'gtags']
                                  let d = findfile(d, s:escape_file_searching(search_directory) . ';')
                                  if d != ''
                                    let directory = fnamemodify(d, ':p:h')
                                    break
                                  endif
                                endfor
                              endif
                            
                              if directory == ''
                                " Search /src/ directory.
                                let base = s:substitute_path_separator(search_directory)
                                if base =~# '/src/'
                                  let directory = base[: strridx(base, '/src/') + 3]
                                endif
                              endif
                            
                              if directory == '' && !is_allow_empty
                                " Use original path.
                                let directory = search_directory
                              endif
                            
                              return s:substitute_path_separator(directory)
                            endfunction
                            " Check vimproc.
    1              0.000003 function! s:has_vimproc()
                              if !exists('s:exists_vimproc')
                                try
                                  call vimproc#version()
                                  let s:exists_vimproc = 1
                                catch
                                  let s:exists_vimproc = 0
                                endtry
                              endif
                              return s:exists_vimproc
                            endfunction
                            
    1              0.000003 function! s:system(str, ...)
                              let command = a:str
                              let input = a:0 >= 1 ? a:1 : ''
                              let command = s:iconv(command, &encoding, 'char')
                              let input = s:iconv(input, &encoding, 'char')
                            
                              if a:0 == 0
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command) : system(command)
                              elseif a:0 == 1
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command, input) : system(command, input)
                              else
                                " ignores 3rd argument unless you have vimproc.
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command, input, a:2) : system(command, input)
                              endif
                            
                              let output = s:iconv(output, 'char', &encoding)
                            
                              return output
                            endfunction
    1              0.000002 function! s:get_last_status()
                              return s:has_vimproc() ?
                                    \ vimproc#get_last_status() : v:shell_error
                            endfunction
                            
    1              0.000013 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/vital/_a477c91/data/list.vim
Sourced 1 time
Total time:   0.000573
 Self time:   0.000573

count  total (s)   self (s)
                            " Utilities for list.
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000003 function! s:pop(list)
                              return remove(a:list, -1)
                            endfunction
                            
    1              0.000002 function! s:push(list, val)
                              call add(a:list, a:val)
                              return a:list
                            endfunction
                            
    1              0.000001 function! s:shift(list)
                              return remove(a:list, 0)
                            endfunction
                            
    1              0.000002 function! s:unshift(list, val)
                              return insert(a:list, a:val)
                            endfunction
                            
                            " Removes duplicates from a list.
    1              0.000001 function! s:uniq(list, ...)
                              let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(a:0 ? list[i][1] : list[i])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:0 ? map(list, 'v:val[0]') : list
                            endfunction
                            
    1              0.000001 function! s:clear(list)
                              if !empty(a:list)
                                unlet! a:list[0 : len(a:list) - 1]
                              endif
                              return a:list
                            endfunction
                            
                            " Concatenates a list of lists.
                            " XXX: Should we verify the input?
    1              0.000001 function! s:concat(list)
                              let list = []
                              for Value in a:list
                                let list += Value
                              endfor
                              return list
                            endfunction
                            
                            " Flattens a list.
    1              0.000002 function! s:flatten(list)
                              let list = []
                              for Value in a:list
                                if type(Value) == type([])
                                  let list += s:flatten(Value)
                                else
                                  call add(list, Value)
                                endif
                                unlet! Value
                              endfor
                              return list
                            endfunction
                            
                            " Sorts a list with expression to compare each two values.
                            " a:a and a:b can be used in {expr}.
    1              0.000002 function! s:sort(list, expr)
                              if type(a:expr) == type(function('function'))
                                return sort(a:list, a:expr)
                              endif
                              let s:expr = a:expr
                              return sort(a:list, 's:_compare')
                            endfunction
                            
    1              0.000002 function! s:_compare(a, b)
                              return eval(s:expr)
                            endfunction
                            
                            " Sorts a list using a set of keys generated by mapping the values in the list
                            " through the given expr.
                            " v:val is used in {expr}
    1              0.000001 function! s:sort_by(list, expr)
                              let pairs = map(a:list, printf('[v:val, %s]', a:expr))
                              return map(s:sort(pairs,
                              \      'a:a[1] ==# a:b[1] ? 0 : a:a[1] ># a:b[1] ? 1 : -1'), 'v:val[0]')
                            endfunction
                            
                            " Returns a maximum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
    1              0.000002 function! s:max(list, expr)
                              if empty(a:list)
                                return 0
                              endif
                              let list = map(copy(a:list), a:expr)
                              return a:list[index(list, max(list))]
                            endfunction
                            
                            " Returns a minimum value in {list} through given {expr}.
                            " Returns 0 if {list} is empty.
                            " v:val is used in {expr}
                            " FIXME: -0x80000000 == 0x80000000
    1              0.000002 function! s:min(list, expr)
                              return s:max(a:list, '-(' . a:expr . ')')
                            endfunction
                            
                            " Returns List of character sequence between [a:from, a:to]
                            " e.g.: s:char_range('a', 'c') returns ['a', 'b', 'c']
    1              0.000002 function! s:char_range(from, to)
                              return map(
                              \   range(char2nr(a:from), char2nr(a:to)),
                              \   'nr2char(v:val)'
                              \)
                            endfunction
                            
                            " Returns true if a:list has a:Value.
                            " Returns false otherwise.
    1              0.000002 function! s:has(list, Value)
                              return index(a:list, a:Value) isnot -1
                            endfunction
                            
                            " Returns true if a:list[a:index] exists.
                            " Returns false otherwise.
                            " NOTE: Returns false when a:index is negative number.
    1              0.000001 function! s:has_index(list, index)
                              " Return true when negative index?
                              " let index = a:index >= 0 ? a:index : len(a:list) + a:index
                              return 0 <= a:index && a:index < len(a:list)
                            endfunction
                            
                            " similar to Haskell's Data.List.span
    1              0.000002 function! s:span(f, xs)
                              let border = len(a:xs)
                              for i in range(len(a:xs))
                                if !eval(substitute(a:f, 'v:val', string(a:xs[i]), 'g'))
                                  let border = i
                                  break
                                endif
                              endfor
                              return border == 0 ? [[], copy(a:xs)] : [a:xs[: border - 1], a:xs[border :]]
                            endfunction
                            
                            " similar to Haskell's Data.List.break
    1              0.000001 function! s:break(f, xs)
                              return s:span(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Data.List.takeWhile
    1              0.000001 function! s:take_while(f, xs)
                              return s:span(a:f, a:xs)[0]
                            endfunction
                            
                            " similar to Haskell's Data.List.partition
    1              0.000002 function! s:partition(f, xs)
                              return [filter(copy(a:xs), a:f), filter(copy(a:xs), '!(' . a:f . ')')]
                            endfunction
                            
                            " similar to Haskell's Prelude.all
    1              0.000002 function! s:all(f, xs)
                              return !s:any(printf('!(%s)', a:f), a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.any
    1              0.000007 function! s:any(f, xs)
                              return !empty(filter(map(copy(a:xs), a:f), 'v:val'))
                            endfunction
                            
                            " similar to Haskell's Prelude.and
    1              0.000002 function! s:and(xs)
                              return s:all('v:val', a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.or
    1              0.000002 function! s:or(xs)
                              return s:any('v:val', a:xs)
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl
    1              0.000003 function! s:foldl(f, init, xs)
                              let memo = a:init
                              for x in a:xs
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.foldl1
    1              0.000002 function! s:foldl1(f, xs)
                              if len(a:xs) == 0
                                throw 'foldl1'
                              endif
                              return s:foldl(a:f, a:xs[0], a:xs[1:])
                            endfunction
                            
                            " similar to Haskell's Prelude.foldr
    1              0.000003 function! s:foldr(f, init, xs)
                              let memo = a:init
                              for i in reverse(range(0, len(a:xs) - 1))
                                let x = a:xs[i]
                                let expr = substitute(a:f, 'v:val', string(x), 'g')
                                let expr = substitute(expr, 'v:memo', string(memo), 'g')
                                unlet memo
                                let memo = eval(expr)
                              endfor
                              return memo
                            endfunction
                            
                            " similar to Haskell's Prelude.fold11
    1              0.000002 function! s:foldr1(f, xs)
                              if len(a:xs) == 0
                                throw 'foldr1'
                              endif
                              return s:foldr(a:f, a:xs[-1], a:xs[0:-2])
                            endfunction
                            
                            " similar to python's zip()
    1              0.000001 function! s:zip(...)
                              return map(range(min(map(copy(a:000), 'len(v:val)'))), "map(copy(a:000), 'v:val['.v:val.']')")
                            endfunction
                            
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/vital/_a477c91/data/string.vim
Sourced 1 time
Total time:   0.000582
 Self time:   0.000582

count  total (s)   self (s)
                            " Utilities for string.
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000003 function! s:_vital_loaded(V)
                              let s:V = a:V
                              let s:L = s:V.import('Data.List')
                            endfunction
                            
    1              0.000002 function! s:_vital_depends()
                              return ['Data.List']
                            endfunction
                            
                            " Substitute a:from => a:to by string.
                            " To substitute by pattern, use substitute() instead.
    1              0.000001 function! s:replace(str, from, to)
                              if a:str ==# '' || a:from ==# ''
                                return a:str
                              endif
                              let str = a:str
                              let idx = stridx(str, a:from)
                              while idx !=# -1
                                let left  = idx ==# 0 ? '' : str[: idx - 1]
                                let right = str[idx + strlen(a:from) :]
                                let str = left . a:to . right
                                let idx = stridx(str, a:from)
                              endwhile
                              return str
                            endfunction
                            
                            " Substitute a:from => a:to only once.
                            " cf. s:replace()
    1              0.000002 function! s:replace_once(str, from, to)
                              if a:str ==# '' || a:from ==# ''
                                return a:str
                              endif
                              let idx = stridx(a:str, a:from)
                              if idx ==# -1
                                return a:str
                              else
                                let left  = idx ==# 0 ? '' : a:str[: idx - 1]
                                let right = a:str[idx + strlen(a:from) :]
                                return left . a:to . right
                              endif
                            endfunction
                            
    1              0.000002 function! s:scan(str, pattern)
                              let list = []
                              let pos = 0
                              let len = len(a:str)
                              while 0 <= pos && pos < len
                                let matched = matchstr(a:str, a:pattern, pos)
                                let pos = matchend(a:str, a:pattern, pos)
                                if !empty(matched)
                                  call add(list, matched)
                                endif
                              endwhile
                              return list
                            endfunction
                            
    1              0.000004 function! s:reverse(str)
                              return join(reverse(split(a:str, '.\zs')), '')
                            endfunction
                            
    1              0.000001 function! s:common_head(strs)
                              if empty(a:strs)
                                return ''
                              endif
                              let head = a:strs[0]
                              for str in a:strs[1 :]
                                let pat = substitute(str, '.', '[\0]', 'g')
                                let head = matchstr(head, '^\%[' . pat . ']')
                                if head ==# ''
                                  break
                                endif
                              endfor
                              return head
                            endfunction
                            
                            " Split to two elements of List. ([left, right])
                            " e.g.: s:split3('neocomplcache', 'compl') returns ['neo', 'compl', 'cache']
    1              0.000002 function! s:split_leftright(expr, pattern)
                              let [left, _, right] = s:split3(a:expr, a:pattern)
                              return [left, right]
                            endfunction
                            
    1              0.000002 function! s:split3(expr, pattern)
                              let ERROR = ['', '', '']
                              if a:expr ==# '' || a:pattern ==# ''
                                return ERROR
                              endif
                              let begin = match(a:expr, a:pattern)
                              if begin is -1
                                return ERROR
                              endif
                              let end   = matchend(a:expr, a:pattern)
                              let left  = begin <=# 0 ? '' : a:expr[: begin - 1]
                              let right = a:expr[end :]
                              return [left, a:expr[begin : end-1], right]
                            endfunction
                            
                            " Slices into strings determines the number of substrings.
                            " e.g.: s:splitn("neo compl cache", 2, '\s') returns ['neo', 'compl cache']
    1              0.000002 function! s:nsplit(expr, n, ...)
                              let pattern = get(a:000, 0, '\s')
                              let keepempty = get(a:000, 1, 1)
                              let ret = []
                              let expr = a:expr
                              if a:n <= 1
                                return [expr]
                              endif
                              while 1
                                let pos = match(expr, pattern)
                                if pos == -1
                                  if expr !~ pattern || keepempty
                                    call add(ret, expr)
                                  endif
                                  break
                                elseif pos >= 0
                                  let left = pos > 0 ? expr[:pos-1] : ''
                                  if pos > 0 || keepempty
                                    call add(ret, left)
                                  endif
                                  let ml = len(matchstr(expr, pattern))
                                  if pos == 0 && ml == 0
                                    let pos = 1
                                  endif
                                  let expr = expr[pos+ml :]
                                endif
                                if len(expr) == 0
                                  break
                                endif
                                if len(ret) == a:n - 1
                                  call add(ret, expr)
                                  break
                                endif
                              endwhile
                              return ret
                            endfunction
                            
                            " Returns the number of character in a:str.
                            " NOTE: This returns proper value
                            " even if a:str contains multibyte character(s).
                            " s:strchars(str) {{{
    1              0.000005 if exists('*strchars')
    1              0.000002   function! s:strchars(str)
                                return strchars(a:str)
                              endfunction
    1              0.000001 else
                              function! s:strchars(str)
                                return strlen(substitute(copy(a:str), '.', 'x', 'g'))
                              endfunction
                            endif "}}}
                            
                            " Remove last character from a:str.
                            " NOTE: This returns proper value
                            " even if a:str contains multibyte character(s).
    1              0.000002 function! s:chop(str) "{{{
                              return substitute(a:str, '.$', '', '')
                            endfunction "}}}
                            
                            " wrap() and its internal functions
                            " * _split_by_wcswidth_once()
                            " * _split_by_wcswidth()
                            " * _concat()
                            " * wrap()
                            "
                            " NOTE _concat() is just a copy of Data.List.concat().
                            " FIXME don't repeat yourself
    1              0.000008 function! s:_split_by_wcswidth_once(body, x)
                              let fst = s:V.strwidthpart(a:body, a:x)
                              let snd = s:V.strwidthpart_reverse(a:body, s:V.wcswidth(a:body) - s:V.wcswidth(fst))
                              return [fst, snd]
                            endfunction
                            
    1              0.000003 function! s:_split_by_wcswidth(body, x)
                              let memo = []
                              let body = a:body
                              while s:V.wcswidth(body) > a:x
                                let [tmp, body] = s:_split_by_wcswidth_once(body, a:x)
                                call add(memo, tmp)
                              endwhile
                              call add(memo, body)
                              return memo
                            endfunction
                            
    1              0.000003 function! s:trim(str)
                              return matchstr(a:str,'^\s*\zs.\{-}\ze\s*$')
                            endfunction
                            
    1              0.000003 function! s:wrap(str,...)
                              let _columns = a:0 > 0 ? a:1 : &columns
                              return s:L.concat(
                                    \ map(split(a:str, '\r\?\n'), 's:_split_by_wcswidth(v:val, _columns - 1)'))
                            endfunction
                            
    1              0.000002 function! s:nr2byte(nr)
                              if a:nr < 0x80
                                return nr2char(a:nr)
                              elseif a:nr < 0x800
                                return nr2char(a:nr/64+192).nr2char(a:nr%64+128)
                              else
                                return nr2char(a:nr/4096%16+224).nr2char(a:nr/64%64+128).nr2char(a:nr%64+128)
                              endif
                            endfunction
                            
    1              0.000002 function! s:nr2enc_char(charcode)
                              if &encoding == 'utf-8'
                                return nr2char(a:charcode)
                              endif
                              let char = s:nr2byte(a:charcode)
                              if strlen(char) > 1
                                let char = strtrans(iconv(char, 'utf-8', &encoding))
                              endif
                              return char
                            endfunction
                            
    1              0.000001 function! s:nr2hex(nr)
                              let n = a:nr
                              let r = ""
                              while n
                                let r = '0123456789ABCDEF'[n % 16] . r
                                let n = n / 16
                              endwhile
                              return r
                            endfunction
                            
                            " If a ==# b, returns -1.
                            " If a !=# b, returns first index of diffrent character.
    1              0.000002 function! s:diffidx(a, b)
                              let [a, b] = [split(a:a, '\zs'), split(a:b, '\zs')]
                              let [al, bl] = [len(a), len(b)]
                              let l = max([al, bl])
                              for i in range(l)
                                " if `i` is out of range, a[i] returns empty string.
                                if i >= al || i >= bl || a[i] !=# b[i]
                                  return i > 0 ? strlen(join(a[:i-1], '')) : 0
                                endif
                              endfor
                              return -1
                            endfunction
                            
    1              0.000007 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/variables.vim
Sourced 1 time
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: variables.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 01 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000013 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000013 function! neocomplcache#variables#get_frequencies() "{{{
                              if !exists('s:filetype_frequencies')
                                let s:filetype_frequencies = {}
                              endif
                              let filetype = neocomplcache#context_filetype#get(&filetype)
                              if !has_key(s:filetype_frequencies, filetype)
                                let s:filetype_frequencies[filetype] = {}
                              endif
                            
                              let frequencies = s:filetype_frequencies[filetype]
                            
                              return frequencies
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#variables#get_sources() "{{{
                              if !exists('s:sources')
                                let s:sources = {}
                              endif
                              return s:sources
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#variables#get_filters() "{{{
                              if !exists('s:filters')
                                let s:filters = {}
                              endif
                              return s:filters
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#variables#get_custom() "{{{
                              if !exists('s:custom')
                                let s:custom = {}
                                let s:custom.sources = {}
                                let s:custom.sources._ = {}
                              endif
                            
                              return s:custom
                            endfunction"}}}
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/context_filetype.vim
Sourced 1 time
Total time:   0.000589
 Self time:   0.000589

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: context_filetype.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 18 Apr 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000007 function! neocomplcache#context_filetype#initialize() "{{{
                              " Initialize context filetype lists.
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_context_filetype_lists', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'c,cpp', [
                                    \ {'filetype' : 'masm',
                                    \  'start' : '_*asm_*\s\+\h\w*', 'end' : '$'},
                                    \ {'filetype' : 'masm',
                                    \  'start' : '_*asm_*\s*\%(\n\s*\)\?{', 'end' : '}'},
                                    \ {'filetype' : 'gas',
                                    \  'start' : '_*asm_*\s*\%(_*volatile_*\s*\)\?(', 'end' : ');'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'd', [
                                    \ {'filetype' : 'masm',
                                    \  'start' : 'asm\s*\%(\n\s*\)\?{', 'end' : '}'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'perl6', [
                                    \ {'filetype' : 'pir', 'start' : 'Q:PIR\s*{', 'end' : '}'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'vimshell', [
                                    \ {'filetype' : 'vim',
                                    \  'start' : 'vexe \([''"]\)', 'end' : '\\\@<!\1'},
                                    \ {'filetype' : 'vim', 'start' : ' :\w*', 'end' : '\n'},
                                    \ {'filetype' : 'vim', 'start' : ' vexe\s\+', 'end' : '\n'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'eruby', [
                                    \ {'filetype' : 'ruby', 'start' : '<%[=#]\?', 'end' : '%>'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'vim', [
                                    \ {'filetype' : 'python',
                                    \  'start' : '^\s*py\%[thon\]3\? <<\s*\(\h\w*\)', 'end' : '^\1'},
                                    \ {'filetype' : 'ruby',
                                    \  'start' : '^\s*rub\%[y\] <<\s*\(\h\w*\)', 'end' : '^\1'},
                                    \ {'filetype' : 'lua',
                                    \  'start' : '^\s*lua <<\s*\(\h\w*\)', 'end' : '^\1'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'html,xhtml', [
                                    \ {'filetype' : 'javascript', 'start' :
                                    \'<script\%( [^>]*\)\? type="text/javascript"\%( [^>]*\)\?>',
                                    \  'end' : '</script>'},
                                    \ {'filetype' : 'coffee', 'start' :
                                    \'<script\%( [^>]*\)\? type="text/coffeescript"\%( [^>]*\)\?>',
                                    \  'end' : '</script>'},
                                    \ {'filetype' : 'css', 'start' :
                                    \'<style\%( [^>]*\)\? type="text/css"\%( [^>]*\)\?>',
                                    \  'end' : '</style>'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'python', [
                                    \ {'filetype' : 'vim',
                                    \  'start' : 'vim.command\s*(\([''"]\)', 'end' : '\\\@<!\1\s*)'},
                                    \ {'filetype' : 'vim',
                                    \  'start' : 'vim.eval\s*(\([''"]\)', 'end' : '\\\@<!\1\s*)'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'help', [
                                    \ {'filetype' : 'vim', 'start' : '^>', 'end' : '^<'},
                                    \])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_context_filetype_lists',
                                    \ 'nyaos,int-nyaos', [
                                    \ {'filetype' : 'lua',
                                    \  'start' : '\<lua_e\s\+\(["'']\)', 'end' : '^\1'},
                                    \])
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#context_filetype#set() "{{{
                              let old_filetype = neocomplcache#get_current_neocomplcache().filetype
                              if old_filetype == ''
                                let old_filetype = &filetype
                              endif
                              if old_filetype == ''
                                let old_filetype = 'nothing'
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              let dup_check = {}
                              while 1
                                let new_filetype = neocomplcache#context_filetype#get(old_filetype)
                            
                                " Check filetype root.
                                if get(dup_check, old_filetype, '') ==# new_filetype
                                  let neocomplcache.context_filetype = old_filetype
                                  break
                                endif
                            
                                " Save old -> new filetype graph.
                                let dup_check[old_filetype] = new_filetype
                                let old_filetype = new_filetype
                              endwhile
                            
                              return neocomplcache.context_filetype
                            endfunction"}}}
    1              0.000006 function! neocomplcache#context_filetype#get(filetype) "{{{
                              " Default.
                              let filetype = a:filetype
                              if filetype == ''
                                let filetype = 'nothing'
                              endif
                            
                              " Default range.
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              let pos = [line('.'), col('.')]
                              for include in get(g:neocomplcache_context_filetype_lists, filetype, [])
                                let start_backward = searchpos(include.start, 'bneW')
                            
                                " Check pos > start.
                                if start_backward[0] == 0 || s:compare_pos(start_backward, pos) > 0
                                  continue
                                endif
                            
                                let end_pattern = include.end
                                if end_pattern =~ '\\1'
                                  let match_list = matchlist(getline(start_backward[0]), include.start)
                                  let end_pattern = substitute(end_pattern, '\\1', '\=match_list[1]', 'g')
                                endif
                                let end_forward = searchpos(end_pattern, 'nW')
                                if end_forward[0] == 0
                                  let end_forward = [line('$'), len(getline('$'))+1]
                                endif
                            
                                " Check end > pos.
                                if s:compare_pos(pos, end_forward) > 0
                                  continue
                                endif
                            
                                let end_backward = searchpos(end_pattern, 'bnW')
                            
                                " Check start <= end.
                                if s:compare_pos(start_backward, end_backward) < 0
                                  continue
                                endif
                            
                                if start_backward[1] == len(getline(start_backward[0]))
                                  " Next line.
                                  let start_backward[0] += 1
                                  let start_backward[1] = 1
                                endif
                                if end_forward[1] == 1
                                  " Previous line.
                                  let end_forward[0] -= 1
                                  let end_forward[1] = len(getline(end_forward[0]))
                                endif
                            
                                let neocomplcache.context_filetype_range =
                                      \ [ start_backward, end_forward ]
                                return include.filetype
                              endfor
                            
                              return filetype
                            endfunction"}}}
                            
    1              0.000005 function! s:compare_pos(i1, i2)
                              return a:i1[0] == a:i2[0] ? a:i1[1] - a:i2[1] : a:i1[0] - a:i2[0]
                            endfunction"
                            
    1              0.000012 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/commands.vim
Sourced 1 time
Total time:   0.000550
 Self time:   0.000550

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: commands.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 12 Apr 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000011 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000006 function! neocomplcache#commands#_initialize() "{{{
                              command! -nargs=? Neco call s:display_neco(<q-args>)
                              command! -nargs=1 NeoComplCacheAutoCompletionLength
                                    \ call s:set_auto_completion_length(<args>)
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#commands#_toggle_lock() "{{{
                              if neocomplcache#get_current_neocomplcache().lock
                                echo 'neocomplcache is unlocked!'
                                call neocomplcache#commands#_unlock()
                              else
                                echo 'neocomplcache is locked!'
                                call neocomplcache#commands#_lock()
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! neocomplcache#commands#_lock() "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let neocomplcache.lock = 1
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#commands#_unlock() "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let neocomplcache.lock = 0
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#commands#_lock_source(source_name) "{{{
                              if !neocomplcache#is_enabled()
                                call neocomplcache#print_warning(
                                      \ 'neocomplcache is disabled! This command is ignored.')
                                return
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              let neocomplcache.lock_sources[a:source_name] = 1
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#commands#_unlock_source(source_name) "{{{
                              if !neocomplcache#is_enabled()
                                call neocomplcache#print_warning(
                                      \ 'neocomplcache is disabled! This command is ignored.')
                                return
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              let neocomplcache.lock_sources[a:source_name] = 1
                            endfunction"}}}
                            
    1              0.000003 function! neocomplcache#commands#_clean() "{{{
                              " Delete cache files.
                              for directory in filter(neocomplcache#util#glob(
                                    \ g:neocomplcache_temporary_dir.'/*'), 'isdirectory(v:val)')
                                for filename in filter(neocomplcache#util#glob(directory.'/*'),
                                      \ '!isdirectory(v:val)')
                                  call delete(filename)
                                endfor
                              endfor
                            
                              echo 'Cleaned cache files in: ' . g:neocomplcache_temporary_dir
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#commands#_set_file_type(filetype) "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let neocomplcache.filetype = a:filetype
                            endfunction"}}}
                            
    1              0.000003 function! s:display_neco(number) "{{{
                              let cmdheight_save = &cmdheight
                            
                              let animation = [
                                \[
                                    \[
                                    \ "   A A",
                                    \ "~(-'_'-)"
                                    \],
                                    \[
                                    \ "      A A",
                                    \ "   ~(-'_'-)",
                                    \],
                                    \[
                                    \ "        A A",
                                    \ "     ~(-'_'-)",
                                    \],
                                    \[
                                    \ "          A A  ",
                                    \ "       ~(-'_'-)",
                                    \],
                                    \[
                                    \ "             A A",
                                    \ "          ~(-^_^-)",
                                    \],
                                \],
                                \[
                                    \[
                                    \ "   A A",
                                    \ "~(-'_'-)",
                                    \],
                                    \[
                                    \ "      A A",
                                    \ "   ~(-'_'-)",
                                    \],
                                    \[
                                    \ "        A A",
                                    \ "     ~(-'_'-)",
                                    \],
                                    \[
                                    \ "          A A  ",
                                    \ "       ~(-'_'-)",
                                    \],
                                    \[
                                    \ "             A A",
                                    \ "          ~(-'_'-)",
                                    \],
                                    \[
                                    \ "          A A  ",
                                    \ "       ~(-'_'-)"
                                    \],
                                    \[
                                    \ "        A A",
                                    \ "     ~(-'_'-)"
                                    \],
                                    \[
                                    \ "      A A",
                                    \ "   ~(-'_'-)"
                                    \],
                                    \[
                                    \ "   A A",
                                    \ "~(-'_'-)"
                                    \],
                                \],
                                \[
                                    \[
                                    \ "   A A",
                                    \ "~(-'_'-)",
                                    \],
                                    \[
                                    \ "        A A",
                                    \ "     ~(-'_'-)",
                                    \],
                                    \[
                                    \ "             A A",
                                    \ "          ~(-'_'-)",
                                    \],
                                    \[
                                    \ "                  A A",
                                    \ "               ~(-'_'-)",
                                    \],
                                    \[
                                    \ "                       A A",
                                    \ "                    ~(-'_'-)",
                                    \],
                                    \["                           A A",
                                    \ "                        ~(-'_'-)",
                                    \],
                                \],
                                \[
                                    \[
                                    \ "",
                                    \ "   A A",
                                    \ "~(-'_'-)",
                                    \],
                                    \["      A A",
                                    \ "   ~(-'_'-)",
                                    \ "",
                                    \],
                                    \[
                                    \ "",
                                    \ "        A A",
                                    \ "     ~(-'_'-)",
                                    \],
                                    \[
                                    \ "          A A  ",
                                    \ "       ~(-'_'-)",
                                    \ "",
                                    \],
                                    \[
                                    \ "",
                                    \ "             A A",
                                    \ "          ~(-^_^-)",
                                    \],
                                \],
                                \[
                                    \[
                                    \ "   A A        A A",
                                    \ "~(-'_'-)  -8(*'_'*)"
                                    \],
                                    \[
                                    \ "     A A        A A",
                                    \ "  ~(-'_'-)  -8(*'_'*)"
                                    \],
                                    \[
                                    \ "       A A        A A",
                                    \ "    ~(-'_'-)  -8(*'_'*)"
                                    \],
                                    \[
                                    \ "     A A        A A",
                                    \ "  ~(-'_'-)  -8(*'_'*)"
                                    \],
                                    \[
                                    \ "   A A        A A",
                                    \ "~(-'_'-)  -8(*'_'*)"
                                    \],
                                \],
                                \[
                                    \[
                                    \ "  A\\_A\\",
                                    \ "(=' .' ) ~w",
                                    \ "(,(\")(\")",
                                    \],
                                \],
                              \]
                            
                              let number = (a:number != '') ? a:number : len(animation)
                              let anim = get(animation, number, animation[s:rand(len(animation) - 1)])
                              let &cmdheight = len(anim[0])
                            
                              for frame in anim
                                echo repeat("\n", &cmdheight-2)
                                redraw
                                echon join(frame, "\n")
                                sleep 300m
                              endfor
                              redraw
                            
                              let &cmdheight = cmdheight_save
                            endfunction"}}}
                            
    1              0.000006 function! s:rand(max) "{{{
                              if !has('reltime')
                                " Same value.
                                return 0
                              endif
                            
                              let time = reltime()[1]
                              return (time < 0 ? -time : time)% (a:max + 1)
                            endfunction"}}}
                            
    1              0.000003 function! s:set_auto_completion_length(len) "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let neocomplcache.completion_length = a:len
                            endfunction"}}}
                            
    1              0.000011 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/mappings.vim
Sourced 1 time
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: mappings.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 19 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000010 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000006 function! neocomplcache#mappings#define_default_mappings() "{{{
                              inoremap <expr><silent> <Plug>(neocomplcache_start_unite_complete)
                                    \ unite#sources#neocomplcache#start_complete()
                              inoremap <expr><silent> <Plug>(neocomplcache_start_unite_quick_match)
                                    \ unite#sources#neocomplcache#start_quick_match()
                              inoremap <silent> <Plug>(neocomplcache_start_auto_complete)
                                    \ <C-x><C-u><C-r>=neocomplcache#mappings#popup_post()<CR>
                              inoremap <silent> <Plug>(neocomplcache_start_auto_complete_no_select)
                                    \ <C-x><C-u><C-p>
                              " \ <C-x><C-u><C-p>
                              inoremap <silent> <Plug>(neocomplcache_start_omni_complete)
                                    \ <C-x><C-o><C-p>
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#mappings#smart_close_popup() "{{{
                              return g:neocomplcache_enable_auto_select ?
                                    \ neocomplcache#mappings#cancel_popup() :
                                    \ neocomplcache#mappings#close_popup()
                            endfunction
                            "}}}
    1              0.000003 function! neocomplcache#mappings#close_popup() "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let neocomplcache.complete_str = ''
                              let neocomplcache.skip_next_complete = 2
                              let neocomplcache.candidates = []
                            
                              return pumvisible() ? "\<C-y>" : ''
                            endfunction
                            "}}}
    1              0.000004 function! neocomplcache#mappings#cancel_popup() "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let neocomplcache.skip_next_complete = 1
                              call neocomplcache#helper#clear_result()
                            
                              return pumvisible() ? "\<C-e>" : ''
                            endfunction
                            "}}}
                            
    1              0.000004 function! neocomplcache#mappings#popup_post() "{{{
                              return  !pumvisible() ? "" :
                                    \ g:neocomplcache_enable_auto_select ? "\<C-p>\<Down>" :
                                    \ "\<C-p>"
                            endfunction"}}}
                            
    1              0.000003 function! neocomplcache#mappings#undo_completion() "{{{
                              if !exists(':NeoComplCacheDisable')
                                return ''
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              " Get cursor word.
                              let [complete_pos, complete_str] =
                                    \ neocomplcache#match_word(neocomplcache#get_cur_text(1))
                              let old_keyword_str = neocomplcache.complete_str
                              let neocomplcache.complete_str = complete_str
                            
                              return (!pumvisible() ? '' :
                                    \ complete_str ==# old_keyword_str ? "\<C-e>" : "\<C-y>")
                                    \. repeat("\<BS>", len(complete_str)) . old_keyword_str
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#mappings#complete_common_string() "{{{
                              if !exists(':NeoComplCacheDisable')
                                return ''
                              endif
                            
                              " Save options.
                              let ignorecase_save = &ignorecase
                            
                              " Get cursor word.
                              let [complete_pos, complete_str] =
                                    \ neocomplcache#match_word(neocomplcache#get_cur_text(1))
                            
                              if neocomplcache#is_text_mode()
                                let &ignorecase = 1
                              elseif g:neocomplcache_enable_smart_case && complete_str =~ '\u'
                                let &ignorecase = 0
                              else
                                let &ignorecase = g:neocomplcache_enable_ignore_case
                              endif
                            
                              let is_fuzzy = g:neocomplcache_enable_fuzzy_completion
                            
                              try
                                let g:neocomplcache_enable_fuzzy_completion = 0
                                let neocomplcache = neocomplcache#get_current_neocomplcache()
                                let candidates = neocomplcache#keyword_filter(
                                      \ copy(neocomplcache.candidates), complete_str)
                              finally
                                let g:neocomplcache_enable_fuzzy_completion = is_fuzzy
                              endtry
                            
                              if empty(candidates)
                                let &ignorecase = ignorecase_save
                            
                                return ''
                              endif
                            
                              let common_str = candidates[0].word
                              for keyword in candidates[1:]
                                while !neocomplcache#head_match(keyword.word, common_str)
                                  let common_str = common_str[: -2]
                                endwhile
                              endfor
                              if &ignorecase
                                let common_str = tolower(common_str)
                              endif
                            
                              let &ignorecase = ignorecase_save
                            
                              if common_str == ''
                                return ''
                              endif
                            
                              return (pumvisible() ? "\<C-e>" : '')
                                    \ . repeat("\<BS>", len(complete_str)) . common_str
                            endfunction"}}}
                            
                            " Manual complete wrapper.
    1              0.000009 function! neocomplcache#mappings#start_manual_complete(...) "{{{
                              if !neocomplcache#is_enabled()
                                return ''
                              endif
                            
                              " Set context filetype.
                              call neocomplcache#context_filetype#set()
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              let sources = get(a:000, 0,
                                    \ keys(neocomplcache#available_sources()))
                              let neocomplcache.manual_sources = neocomplcache#helper#get_sources_list(
                                    \ neocomplcache#util#convert2list(sources))
                            
                              " Set function.
                              let &l:completefunc = 'neocomplcache#complete#sources_manual_complete'
                            
                              " Start complete.
                              return "\<C-x>\<C-u>\<C-p>"
                            endfunction"}}}
                            
    1              0.000013 function! neocomplcache#mappings#start_manual_complete_list(complete_pos, complete_str, candidates) "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let [neocomplcache.complete_pos,
                                    \ neocomplcache.complete_str, neocomplcache.candidates] =
                                    \ [a:complete_pos, a:complete_str, a:candidates]
                            
                              " Set function.
                              let &l:completefunc = 'neocomplcache#complete#auto_complete'
                            
                              " Start complete.
                              return "\<C-x>\<C-u>\<C-p>"
                            endfunction"}}}
                            
    1              0.000014 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache.vim
Sourced 1 time
Total time:   0.001996
 Self time:   0.001996

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: neocomplcache.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 01 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000027 if !exists('g:loaded_neocomplcache')
                              runtime! plugin/neocomplcache.vim
                            endif
                            
    1              0.000021 let s:save_cpo = &cpo
    1              0.000020 set cpo&vim
                            
    1              0.000006 scriptencoding utf-8
                            
    1              0.000013 function! neocomplcache#initialize() "{{{
                              return neocomplcache#init#enable()
                            endfunction"}}}
                            
    1              0.000009 function! neocomplcache#get_current_neocomplcache() "{{{
                              if !exists('b:neocomplcache')
                                call neocomplcache#init#_current_neocomplcache()
                              endif
                            
                              return b:neocomplcache
                            endfunction"}}}
    1              0.000007 function! neocomplcache#get_context() "{{{
                              return neocomplcache#get_current_neocomplcache().context
                            endfunction"}}}
                            
                            " Source helper. "{{{
    1              0.000009 function! neocomplcache#define_source(source) "{{{
                              let sources = neocomplcache#variables#get_sources()
                              for source in neocomplcache#util#convert2list(a:source)
                                let sources[source.name] = neocomplcache#init#_source(source)
                              endfor
                            endfunction"}}}
    1              0.000008 function! neocomplcache#define_filter(filter) "{{{
                              let filters = neocomplcache#variables#get_filters()
                              for filter in neocomplcache#util#convert2list(a:filter)
                                let filters[filter.name] = neocomplcache#init#_filter(filter)
                              endfor
                            endfunction"}}}
    1              0.000007 function! neocomplcache#available_sources() "{{{
                              return copy(neocomplcache#variables#get_sources())
                            endfunction"}}}
    1              0.000008 function! neocomplcache#custom_source(source_name, option_name, value) "{{{
                              let custom_sources = neocomplcache#variables#get_custom().sources
                            
                              for key in split(a:source_name, '\s*,\s*')
                                if !has_key(custom_sources, key)
                                  let custom_sources[key] = {}
                                endif
                            
                                let custom_sources[key][a:option_name] = a:value
                              endfor
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#is_enabled_source(source_name) "{{{
                              return neocomplcache#helper#is_enabled_source(a:source_name)
                            endfunction"}}}
    1              0.000015 function! neocomplcache#is_disabled_source(source_name) "{{{
                              let filetype = neocomplcache#get_context_filetype()
                            
                              let disabled_sources = get(
                                    \ g:neocomplcache_disabled_sources_list, filetype,
                                    \   get(g:neocomplcache_disabled_sources_list, '_', []))
                              return index(disabled_sources, a:source_name) >= 0
                            endfunction"}}}
    1              0.000008 function! neocomplcache#keyword_escape(complete_str) "{{{
                              return neocomplcache#helper#keyword_escape(a:complete_str)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#keyword_filter(list, complete_str) "{{{
                              return neocomplcache#filters#keyword_filter(a:list, a:complete_str)
                            endfunction"}}}
    1              0.000007 function! neocomplcache#dup_filter(list) "{{{
                              return neocomplcache#util#dup_filter(a:list)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#check_match_filter(complete_str) "{{{
                              return neocomplcache#keyword_escape(a:complete_str) =~ '[^\\]\*\|\\+'
                            endfunction"}}}
    1              0.000265 function! neocomplcache#check_completion_length_match(complete_str, completion_length) "{{{
                              return neocomplcache#keyword_escape(
                                    \ a:complete_str[: a:completion_length-1]) =~
                                    \'[^\\]\*\|\\+\|\\%(\|\\|'
                            endfunction"}}}
    1              0.000011 function! neocomplcache#dictionary_filter(dictionary, complete_str) "{{{
                              return neocomplcache#filters#dictionary_filter(a:dictionary, a:complete_str)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#unpack_dictionary(dict) "{{{
                              let ret = []
                              let values = values(a:dict)
                              for l in (type(values) == type([]) ?
                                    \ values : values(values))
                                let ret += (type(l) == type([])) ? copy(l) : values(l)
                              endfor
                            
                              return ret
                            endfunction"}}}
    1              0.000009 function! neocomplcache#pack_dictionary(list) "{{{
                              let completion_length = 2
                              let ret = {}
                              for candidate in a:list
                                let key = tolower(candidate.word[: completion_length-1])
                                if !has_key(ret, key)
                                  let ret[key] = {}
                                endif
                            
                                let ret[key][candidate.word] = candidate
                              endfor
                            
                              return ret
                            endfunction"}}}
    1              0.000008 function! neocomplcache#add_dictionaries(dictionaries) "{{{
                              if empty(a:dictionaries)
                                return {}
                              endif
                            
                              let ret = a:dictionaries[0]
                              for dict in a:dictionaries[1:]
                                for [key, value] in items(dict)
                                  if has_key(ret, key)
                                    let ret[key] += value
                                  else
                                    let ret[key] = value
                                  endif
                                endfor
                              endfor
                            
                              return ret
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#system(...) "{{{
                              let V = vital#of('neocomplcache')
                              return call(V.system, a:000)
                            endfunction"}}}
    1              0.000006 function! neocomplcache#has_vimproc() "{{{
                              return neocomplcache#util#has_vimproc()
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#get_cur_text(...) "{{{
                              " Return cached text.
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              return (a:0 == 0 && mode() ==# 'i' &&
                                    \  neocomplcache.cur_text != '') ?
                                    \ neocomplcache.cur_text : neocomplcache#helper#get_cur_text()
                            endfunction"}}}
    1              0.000007 function! neocomplcache#get_next_keyword() "{{{
                              " Get next keyword.
                              let pattern = '^\%(' . neocomplcache#get_next_keyword_pattern() . '\m\)'
                            
                              return matchstr('a'.getline('.')[len(neocomplcache#get_cur_text()) :], pattern)[1:]
                            endfunction"}}}
    1              0.000009 function! neocomplcache#get_completion_length(source_name) "{{{
                              let sources = neocomplcache#variables#get_sources()
                              if !has_key(sources, a:source_name)
                                " Unknown.
                                return -1
                              endif
                            
                              if neocomplcache#is_auto_complete()
                                    \ && neocomplcache#get_current_neocomplcache().completion_length >= 0
                                return neocomplcache#get_current_neocomplcache().completion_length
                              else
                                return sources[a:source_name].min_pattern_length
                              endif
                            endfunction"}}}
    1              0.000009 function! neocomplcache#set_completion_length(source_name, length) "{{{
                              let custom = neocomplcache#variables#get_custom().sources
                              if !has_key(custom, a:source_name)
                                let custom[a:source_name] = {}
                              endif
                            
                              if !has_key(custom[a:source_name], 'min_pattern_length')
                                let custom[a:source_name].min_pattern_length = a:length
                              endif
                            endfunction"}}}
    1              0.000007 function! neocomplcache#get_keyword_pattern(...) "{{{
                              let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
                            
                              return neocomplcache#helper#unite_patterns(
                                    \ g:neocomplcache_keyword_patterns, filetype)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#get_next_keyword_pattern(...) "{{{
                              let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
                              let next_pattern = neocomplcache#helper#unite_patterns(
                                    \ g:neocomplcache_next_keyword_patterns, filetype)
                            
                              return (next_pattern == '' ? '' : next_pattern.'\m\|')
                                    \ . neocomplcache#get_keyword_pattern(filetype)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#get_keyword_pattern_end(...) "{{{
                              let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
                            
                              return '\%('.neocomplcache#get_keyword_pattern(filetype).'\m\)$'
                            endfunction"}}}
    1              0.000006 function! neocomplcache#match_word(...) "{{{
                              return call('neocomplcache#helper#match_word', a:000)
                            endfunction"}}}
    1              0.000007 function! neocomplcache#is_enabled() "{{{
                              return neocomplcache#init#is_enabled()
                            endfunction"}}}
    1              0.000006 function! neocomplcache#is_locked(...) "{{{
                              let bufnr = a:0 > 0 ? a:1 : bufnr('%')
                              return !neocomplcache#is_enabled() || &paste
                                    \ || g:neocomplcache_disable_auto_complete
                                    \ || neocomplcache#get_current_neocomplcache().lock
                                    \ || (g:neocomplcache_lock_buffer_name_pattern != '' &&
                                    \   bufname(bufnr) =~ g:neocomplcache_lock_buffer_name_pattern)
                                    \ || &l:omnifunc ==# 'fuf#onComplete'
                            endfunction"}}}
    1              0.000010 function! neocomplcache#is_plugin_locked(source_name) "{{{
                              if !neocomplcache#is_enabled()
                                return 1
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              return get(neocomplcache.lock_sources, a:source_name, 0)
                            endfunction"}}}
    1              0.000007 function! neocomplcache#is_auto_select() "{{{
                              return g:neocomplcache_enable_auto_select && !neocomplcache#is_eskk_enabled()
                            endfunction"}}}
    1              0.000007 function! neocomplcache#is_auto_complete() "{{{
                              return &l:completefunc == 'neocomplcache#complete#auto_complete'
                            endfunction"}}}
    1              0.000007 function! neocomplcache#is_sources_complete() "{{{
                              return &l:completefunc == 'neocomplcache#complete#sources_manual_complete'
                            endfunction"}}}
    1              0.000007 function! neocomplcache#is_eskk_enabled() "{{{
                              return exists('*eskk#is_enabled') && eskk#is_enabled()
                            endfunction"}}}
    1              0.000008 function! neocomplcache#is_eskk_convertion(cur_text) "{{{
                              return neocomplcache#is_eskk_enabled()
                                    \   && eskk#get_preedit().get_henkan_phase() !=#
                                    \             g:eskk#preedit#PHASE_NORMAL
                            endfunction"}}}
    1              0.000007 function! neocomplcache#is_multibyte_input(cur_text) "{{{
                              return (exists('b:skk_on') && b:skk_on)
                                    \     || char2nr(split(a:cur_text, '\zs')[-1]) > 0x80
                            endfunction"}}}
    1              0.000006 function! neocomplcache#is_text_mode() "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              return get(g:neocomplcache_text_mode_filetypes,
                                    \ neocomplcache.context_filetype, 0)
                            endfunction"}}}
    1              0.000006 function! neocomplcache#is_windows() "{{{
                              return neocomplcache#util#is_windows()
                            endfunction"}}}
    1              0.000007 function! neocomplcache#is_win() "{{{
                              return neocomplcache#util#is_windows()
                            endfunction"}}}
    1              0.000006 function! neocomplcache#is_prefetch() "{{{
                              return !neocomplcache#is_locked() &&
                                    \ (g:neocomplcache_enable_prefetch || &l:formatoptions =~# 'a')
                            endfunction"}}}
    1              0.000008 function! neocomplcache#exists_echodoc() "{{{
                              return exists('g:loaded_echodoc') && g:loaded_echodoc
                            endfunction"}}}
    1              0.000006 function! neocomplcache#within_comment() "{{{
                              return neocomplcache#helper#get_syn_name(1) ==# 'Comment'
                            endfunction"}}}
    1              0.000007 function! neocomplcache#print_caching(string) "{{{
                              if g:neocomplcache_enable_caching_message
                                redraw
                                echon a:string
                              endif
                            endfunction"}}}
    1              0.000007 function! neocomplcache#print_error(string) "{{{
                              echohl Error | echomsg a:string | echohl None
                            endfunction"}}}
    1              0.000008 function! neocomplcache#print_warning(string) "{{{
                              echohl WarningMsg | echomsg a:string | echohl None
                            endfunction"}}}
    1              0.000008 function! neocomplcache#head_match(checkstr, headstr) "{{{
                              let checkstr = &ignorecase ?
                                    \ tolower(a:checkstr) : a:checkstr
                              let headstr = &ignorecase ?
                                    \ tolower(a:headstr) : a:headstr
                              return stridx(checkstr, headstr) == 0
                            endfunction"}}}
    1              0.000009 function! neocomplcache#get_source_filetypes(filetype) "{{{
                              return neocomplcache#helper#get_source_filetypes(a:filetype)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#get_sources_list(dictionary, filetype) "{{{
                              return neocomplcache#helper#ftdictionary2list(a:dictionary, a:filetype)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#escape_match(str) "{{{
                              return escape(a:str, '~"*\.^$[]')
                            endfunction"}}}
    1              0.000008 function! neocomplcache#get_context_filetype(...) "{{{
                              if !neocomplcache#is_enabled()
                                return &filetype
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              if a:0 != 0 || mode() !=# 'i' ||
                                    \ neocomplcache.context_filetype == ''
                                call neocomplcache#context_filetype#set()
                              endif
                            
                              return neocomplcache.context_filetype
                            endfunction"}}}
    1              0.000008 function! neocomplcache#get_context_filetype_range(...) "{{{
                              if !neocomplcache#is_enabled()
                                return [[1, 1], [line('$'), len(getline('$'))+1]]
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              if a:0 != 0 || mode() !=# 'i' ||
                                    \ neocomplcache.context_filetype == ''
                                call neocomplcache#context_filetype#set()
                              endif
                            
                              if neocomplcache.context_filetype ==# &filetype
                                return [[1, 1], [line('$'), len(getline('$'))+1]]
                              endif
                            
                              return neocomplcache.context_filetype_range
                            endfunction"}}}
    1              0.000008 function! neocomplcache#print_debug(expr) "{{{
                              if g:neocomplcache_enable_debug
                                echomsg string(a:expr)
                              endif
                            endfunction"}}}
    1              0.000008 function! neocomplcache#get_temporary_directory() "{{{
                              let directory = neocomplcache#util#substitute_path_separator(
                                    \ neocomplcache#util#expand(g:neocomplcache_temporary_dir))
                              if !isdirectory(directory)
                                call mkdir(directory, 'p')
                              endif
                            
                              return directory
                            endfunction"}}}
    1              0.000006 function! neocomplcache#complete_check() "{{{
                              return neocomplcache#helper#complete_check()
                            endfunction"}}}
    1              0.000008 function! neocomplcache#check_invalid_omnifunc(omnifunc) "{{{
                              return a:omnifunc == '' || (a:omnifunc !~ '#' && !exists('*' . a:omnifunc))
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#set_dictionary_helper(variable, keys, value) "{{{
                              return neocomplcache#util#set_dictionary_helper(
                                    \ a:variable, a:keys, a:value)
                            endfunction"}}}
    1              0.000008 function! neocomplcache#disable_default_dictionary(variable) "{{{
                              return neocomplcache#util#disable_default_dictionary(a:variable)
                            endfunction"}}}
    1              0.000010 function! neocomplcache#filetype_complete(arglead, cmdline, cursorpos) "{{{
                              return neocomplcache#helper#filetype_complete(a:arglead, a:cmdline, a:cursorpos)
                            endfunction"}}}
                            "}}}
                            
                            " Key mapping functions. "{{{
    1              0.000007 function! neocomplcache#smart_close_popup()
                              return neocomplcache#mappings#smart_close_popup()
                            endfunction
    1              0.000007 function! neocomplcache#close_popup()
                              return neocomplcache#mappings#close_popup()
                            endfunction
    1              0.000007 function! neocomplcache#cancel_popup()
                              return neocomplcache#mappings#cancel_popup()
                            endfunction
    1              0.000007 function! neocomplcache#undo_completion()
                              return neocomplcache#mappings#undo_completion()
                            endfunction
    1              0.000007 function! neocomplcache#complete_common_string()
                              return neocomplcache#mappings#complete_common_string()
                            endfunction
    1              0.000007 function! neocomplcache#start_manual_complete(...)
                              return call('neocomplcache#mappings#start_manual_complete', a:000)
                            endfunction
                            "}}}
                            
    1              0.000023 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/jscomplete-vim/autoload/neocomplcache/sources/jscomplete.vim
Sourced 1 time
Total time:   0.000306
 Self time:   0.000306

count  total (s)   self (s)
                            
    1              0.000049 let s:save_cpo = &cpo
    1              0.000029 set cpo&vim
                            
                            " neocomplcache source {{{1
    1              0.000026 let s:source = {
                              \ 'name': 'js_complete',
                              \ 'kind': 'ftplugin',
                              \ 'filetypes': { 'javascript': 1 },
                              \ }
                            
                            " function s:source.initialize() "{{{
                            "   call jscomplete#SetGlobalObject()
                            " endfunction "}}}
    1              0.000008 function s:source.finalize() "{{{
                              unlet! b:GlobalObject
                            endfunction "}}}
    1              0.000006 function s:source.get_keyword_pos (cur_text) "{{{
                              if neocomplcache#within_comment()
                                return -1
                              endif
                              return jscomplete#GetCompletePosition(a:cur_text, line('.'))
                            endfunction "}}}
    1              0.000006 function s:source.get_complete_words (pos, complWord) "{{{
                              let completionLength = neocomplcache#get_completion_length('jscomplete')
                              if completionLength == 0 && exists('g:neocomplcache_auto_completion_start_length')
                                let completionLength = g:neocomplcache_auto_completion_start_length
                              endif
                            
                              let l:currentLine = line('.')
                              let l:currentCol = col('.')
                            
                              let l:currentText = getline('.')
                              let l:shortcontext = a:pos > 0 ? substitute(l:currentText[0: a:pos -1], '\s*$', '', '') : ''
                            
                              let l:lineNum = l:currentLine
                              if empty(l:shortcontext)
                                let l:lineNum = prevnonblank(l:lineNum - 1)
                                let l:shortcontext = getline(l:lineNum)
                              endif
                            
                              let compList = jscomplete#GetCompleteWords(a:complWord, l:shortcontext, l:lineNum, completionLength)
                              call cursor(l:currentLine, l:currentCol)
                              return compList
                            endfunction "}}}
                            " 1}}}
                            
    1              0.000013 function! neocomplcache#sources#jscomplete#define ()
                              return s:source
                            endfunction
                            
    1              0.000023 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim:set foldmethod=marker:

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/buffer_complete.vim
Sourced 1 time
Total time:   0.001345
 Self time:   0.001345

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: buffer_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 27 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000015 let s:save_cpo = &cpo
    1              0.000012 set cpo&vim
                            
                            " Important variables.
    1              0.000010 if !exists('s:buffer_sources')
    1              0.000005   let s:buffer_sources = {}
    1              0.000004   let s:async_dictionary_list = {}
    1              0.000001 endif
                            
    1              0.000024 let s:source = {
                                  \ 'name' : 'buffer_complete',
                                  \ 'kind' : 'manual',
                                  \ 'mark' : '[B]',
                                  \ 'rank' : 5,
                                  \ 'min_pattern_length' :
                                  \     g:neocomplcache_auto_completion_start_length,
                                  \ 'hooks' : {},
                                  \}
                            
    1              0.000006 function! s:source.hooks.on_init(context) "{{{
                              let s:buffer_sources = {}
                            
                              augroup neocomplcache "{{{
                                " Caching events
                                autocmd BufEnter,BufRead,BufWinEnter *
                                      \ call s:check_source()
                                autocmd CursorHold,CursorHoldI *
                                      \ call s:check_cache()
                                autocmd BufWritePost *
                                      \ call s:check_recache()
                                autocmd InsertEnter,InsertLeave *
                                      \ call neocomplcache#sources#buffer_complete#caching_current_line()
                              augroup END"}}}
                            
                              " Create cache directory.
                              if !isdirectory(neocomplcache#get_temporary_directory() . '/buffer_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/buffer_cache', 'p')
                              endif
                            
                              " Initialize script variables. "{{{
                              let s:buffer_sources = {}
                              let s:cache_line_count = 70
                              let s:rank_cache_count = 1
                              let s:disable_caching_list = {}
                              let s:async_dictionary_list = {}
                              "}}}
                            
                              call s:check_source()
                            endfunction
                            "}}}
                            
    1              0.000004 function! s:source.hooks.on_final(context) "{{{
                              delcommand NeoComplCacheCachingBuffer
                              delcommand NeoComplCachePrintSource
                              delcommand NeoComplCacheOutputKeyword
                              delcommand NeoComplCacheDisableCaching
                              delcommand NeoComplCacheEnableCaching
                            
                              let s:buffer_sources = {}
                            endfunction"}}}
                            
    1              0.000003 function! s:source.gather_candidates(context) "{{{
                              call s:check_source()
                            
                              let keyword_list = []
                              for [key, source] in s:get_sources_list()
                                call neocomplcache#cache#check_cache_list('buffer_cache',
                                      \ source.path, s:async_dictionary_list, source.keyword_cache, 1)
                            
                                let keyword_list += neocomplcache#dictionary_filter(
                                      \ source.keyword_cache, a:context.complete_str)
                                if key == bufnr('%')
                                  let source.accessed_time = localtime()
                                endif
                              endfor
                            
                              return keyword_list
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#sources#buffer_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#sources#buffer_complete#get_frequencies() "{{{
                              " Current line caching.
                              return get(get(s:buffer_sources, bufnr('%'), {}), 'frequencies', {})
                            endfunction"}}}
    1              0.000007 function! neocomplcache#sources#buffer_complete#caching_current_line() "{{{
                              " Current line caching.
                              return s:caching_current_buffer(
                                    \ max([1, line('.') - 10]), min([line('.') + 10, line('$')]))
                            endfunction"}}}
    1              0.000015 function! neocomplcache#sources#buffer_complete#caching_current_block() "{{{
                              " Current line caching.
                              return s:caching_current_buffer(
                                      \ max([1, line('.') - 500]), min([line('.') + 500, line('$')]))
                            endfunction"}}}
    1              0.000008 function! s:caching_current_buffer(start, end) "{{{
                              " Current line caching.
                            
                              if !s:exists_current_source()
                                call s:word_caching(bufnr('%'))
                              endif
                            
                              let source = s:buffer_sources[bufnr('%')]
                              let keyword_pattern = source.keyword_pattern
                              let keyword_pattern2 = '^\%('.keyword_pattern.'\m\)'
                              let keywords = source.keyword_cache
                            
                              let completion_length = 2
                              let line = join(getline(a:start, a:end))
                              let match = match(line, keyword_pattern)
                              while match >= 0 "{{{
                                let match_str = matchstr(line, keyword_pattern2, match)
                            
                                " Ignore too short keyword.
                                if len(match_str) >= g:neocomplcache_min_keyword_length "{{{
                                  " Check dup.
                                  let key = tolower(match_str[: completion_length-1])
                                  if !has_key(keywords, key)
                                    let keywords[key] = {}
                                  endif
                                  if !has_key(keywords[key], match_str)
                                    " Append list.
                                    let keywords[key][match_str] = match_str
                                    let source.frequencies[match_str] = 30
                                  endif
                                endif"}}}
                            
                                " Next match.
                                let match = match(line, keyword_pattern, match + len(match_str))
                              endwhile"}}}
                            endfunction"}}}
                            
    1              0.000004 function! s:get_sources_list() "{{{
                              let sources_list = []
                            
                              let filetypes_dict = {}
                              for filetype in neocomplcache#get_source_filetypes(
                                    \ neocomplcache#get_context_filetype())
                                let filetypes_dict[filetype] = 1
                              endfor
                            
                              for [key, source] in items(s:buffer_sources)
                                if has_key(filetypes_dict, source.filetype)
                                      \ || has_key(filetypes_dict, '_')
                                      \ || bufnr('%') == key
                                      \ || (source.name ==# '[Command Line]' && bufnr('#') == key)
                                  call add(sources_list, [key, source])
                                endif
                              endfor
                            
                              return sources_list
                            endfunction"}}}
                            
    1              0.000005 function! s:initialize_source(srcname) "{{{
                              let path = fnamemodify(bufname(a:srcname), ':p')
                              let filename = fnamemodify(path, ':t')
                              if filename == ''
                                let filename = '[No Name]'
                                let path .= '/[No Name]'
                              endif
                            
                              let ft = getbufvar(a:srcname, '&filetype')
                              if ft == ''
                                let ft = 'nothing'
                              endif
                            
                              let buflines = getbufline(a:srcname, 1, '$')
                              let keyword_pattern = neocomplcache#get_keyword_pattern(ft)
                            
                              let s:buffer_sources[a:srcname] = {
                                    \ 'keyword_cache' : {},
                                    \ 'frequencies' : {},
                                    \ 'name' : filename, 'filetype' : ft,
                                    \ 'keyword_pattern' : keyword_pattern,
                                    \ 'end_line' : len(buflines),
                                    \ 'accessed_time' : 0,
                                    \ 'cached_time' : 0,
                                    \ 'path' : path, 'loaded_cache' : 0,
                                    \ 'cache_name' : neocomplcache#cache#encode_name(
                                    \   'buffer_cache', path),
                                    \}
                            endfunction"}}}
                            
    1              0.000004 function! s:word_caching(srcname) "{{{
                              " Initialize source.
                              call s:initialize_source(a:srcname)
                            
                              let source = s:buffer_sources[a:srcname]
                            
                              if !filereadable(source.path)
                                    \ || getbufvar(a:srcname, '&buftype') =~ 'nofile'
                                return
                              endif
                            
                              let source.cache_name =
                                    \ neocomplcache#cache#async_load_from_file(
                                    \     'buffer_cache', source.path,
                                    \     source.keyword_pattern, 'B')
                              let source.cached_time = localtime()
                              let source.end_line = len(getbufline(a:srcname, 1, '$'))
                              let s:async_dictionary_list[source.path] = [{
                                    \ 'filename' : source.path,
                                    \ 'cachename' : source.cache_name,
                                    \ }]
                            endfunction"}}}
                            
    1              0.000005 function! s:check_changed_buffer(bufnumber) "{{{
                              let source = s:buffer_sources[a:bufnumber]
                            
                              let ft = getbufvar(a:bufnumber, '&filetype')
                              if ft == ''
                                let ft = 'nothing'
                              endif
                            
                              let filename = fnamemodify(bufname(a:bufnumber), ':t')
                              if filename == ''
                                let filename = '[No Name]'
                              endif
                            
                              return s:buffer_sources[a:bufnumber].name != filename
                                    \ || s:buffer_sources[a:bufnumber].filetype != ft
                            endfunction"}}}
                            
    1              0.000003 function! s:check_source() "{{{
                              if !s:exists_current_source()
                                call neocomplcache#sources#buffer_complete#caching_current_block()
                                return
                              endif
                            
                              for bufnumber in range(1, bufnr('$'))
                                " Check new buffer.
                                let bufname = fnamemodify(bufname(bufnumber), ':p')
                                if (!has_key(s:buffer_sources, bufnumber)
                                      \ || s:check_changed_buffer(bufnumber))
                                      \ && !has_key(s:disable_caching_list, bufnumber)
                                      \ && (!neocomplcache#is_locked(bufnumber) ||
                                      \    g:neocomplcache_disable_auto_complete)
                                      \ && !getwinvar(bufwinnr(bufnumber), '&previewwindow')
                                      \ && getfsize(bufname) <
                                      \      g:neocomplcache_caching_limit_file_size
                                  " Caching.
                                  call s:word_caching(bufnumber)
                                endif
                            
                                if has_key(s:buffer_sources, bufnumber)
                                  let source = s:buffer_sources[bufnumber]
                                  call neocomplcache#cache#check_cache_list('buffer_cache',
                                        \ source.path, s:async_dictionary_list, source.keyword_cache, 1)
                                endif
                              endfor
                            endfunction"}}}
    1              0.000006 function! s:check_cache() "{{{
                              let release_accessd_time =
                                    \ localtime() - g:neocomplcache_release_cache_time
                            
                              for [key, source] in items(s:buffer_sources)
                                " Check deleted buffer and access time.
                                if !bufloaded(str2nr(key))
                                      \ || (source.accessed_time > 0 &&
                                      \ source.accessed_time < release_accessd_time)
                                  " Remove item.
                                  call remove(s:buffer_sources, key)
                                endif
                              endfor
                            endfunction"}}}
    1              0.000004 function! s:check_recache() "{{{
                              if !s:exists_current_source()
                                return
                              endif
                            
                              let release_accessd_time =
                                    \ localtime() - g:neocomplcache_release_cache_time
                            
                              let source = s:buffer_sources[bufnr('%')]
                            
                              " Check buffer access time.
                              if (source.cached_time > 0 && source.cached_time < release_accessd_time)
                                    \  || (neocomplcache#util#has_vimproc() && line('$') != source.end_line)
                                " Buffer recache.
                                if g:neocomplcache_enable_debug
                                  echomsg 'Caching buffer: ' . bufname('%')
                                endif
                            
                                call neocomplcache#sources#buffer_complete#caching_current_block()
                              endif
                            endfunction"}}}
                            
    1              0.000004 function! s:exists_current_source() "{{{
                              return has_key(s:buffer_sources, bufnr('%'))
                            endfunction"}}}
                            
                            " Command functions. "{{{
    1              0.000008 function! neocomplcache#sources#buffer_complete#caching_buffer(name) "{{{
                              if a:name == ''
                                let number = bufnr('%')
                              else
                                let number = bufnr(a:name)
                            
                                if number < 0
                                  let bufnr = bufnr('%')
                            
                                  " No swap warning.
                                  let save_shm = &shortmess
                                  set shortmess+=A
                            
                                  " Open new buffer.
                                  execute 'silent! edit' fnameescape(a:name)
                            
                                  let &shortmess = save_shm
                            
                                  if bufnr('%') != bufnr
                                    setlocal nobuflisted
                                    execute 'buffer' bufnr
                                  endif
                                endif
                            
                                let number = bufnr(a:name)
                              endif
                            
                              " Word recaching.
                              call s:word_caching(number)
                              call s:caching_current_buffer(1, line('$'))
                            endfunction"}}}
    1              0.000007 function! neocomplcache#sources#buffer_complete#print_source(name) "{{{
                              if a:name == ''
                                let number = bufnr('%')
                              else
                                let number = bufnr(a:name)
                            
                                if number < 0
                                  call neocomplcache#print_error('Invalid buffer name.')
                                  return
                                endif
                              endif
                            
                              if !has_key(s:buffer_sources, number)
                                return
                              endif
                            
                              silent put=printf('Print neocomplcache %d source.', number)
                              for key in keys(s:buffer_sources[number])
                                silent put =printf('%s => %s', key, string(s:buffer_sources[number][key]))
                              endfor
                            endfunction"}}}
    1              0.000007 function! neocomplcache#sources#buffer_complete#output_keyword(name) "{{{
                              if a:name == ''
                                let number = bufnr('%')
                              else
                                let number = bufnr(a:name)
                            
                                if number < 0
                                  call neocomplcache#print_error('Invalid buffer name.')
                                  return
                                endif
                              endif
                            
                              if !has_key(s:buffer_sources, number)
                                return
                              endif
                            
                              " Output buffer.
                              for keyword in neocomplcache#unpack_dictionary(
                                    \ s:buffer_sources[number].keyword_cache)
                                silent put=string(keyword)
                              endfor
                            endfunction "}}}
    1              0.000007 function! neocomplcache#sources#buffer_complete#disable_caching(name) "{{{
                              if a:name == ''
                                let number = bufnr('%')
                              else
                                let number = bufnr(a:name)
                            
                                if number < 0
                                  call neocomplcache#print_error('Invalid buffer name.')
                                  return
                                endif
                              endif
                            
                              let s:disable_caching_list[number] = 1
                            
                              if has_key(s:buffer_sources, number)
                                " Delete source.
                                call remove(s:buffer_sources, number)
                              endif
                            endfunction"}}}
    1              0.000008 function! neocomplcache#sources#buffer_complete#enable_caching(name) "{{{
                              if a:name == ''
                                let number = bufnr('%')
                              else
                                let number = bufnr(a:name)
                            
                                if number < 0
                                  call neocomplcache#print_error('Invalid buffer name.')
                                  return
                                endif
                              endif
                            
                              if has_key(s:disable_caching_list, number)
                                call remove(s:disable_caching_list, number)
                              endif
                            endfunction"}}}
                            "}}}
                            
    1              0.000016 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/dictionary_complete.vim
Sourced 1 time
Total time:   0.000631
 Self time:   0.000631

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: dictionary_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 28 Apr 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000022 let s:save_cpo = &cpo
    1              0.000014 set cpo&vim
                            
                            " Important variables.
    1              0.000011 if !exists('s:dictionary_list')
    1              0.000006   let s:dictionary_list = {}
    1              0.000005   let s:async_dictionary_list = {}
    1              0.000002 endif
                            
    1              0.000011 function! neocomplcache#sources#dictionary_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000025 let s:source = {
                                  \ 'name' : 'dictionary_complete',
                                  \ 'kind' : 'keyword',
                                  \ 'mark' : '[D]',
                                  \ 'rank' : 4,
                                  \}
                            
    1              0.000004 function! s:source.initialize() "{{{
                              " Initialize dictionary. "{{{
                              if !exists('g:neocomplcache_dictionary_filetype_lists')
                                let g:neocomplcache_dictionary_filetype_lists = {}
                              endif
                              if !has_key(g:neocomplcache_dictionary_filetype_lists, 'default')
                                let g:neocomplcache_dictionary_filetype_lists['default'] = ''
                              endif
                              "}}}
                            
                              " Initialize dictionary completion pattern. "{{{
                              if !exists('g:neocomplcache_dictionary_patterns')
                                let g:neocomplcache_dictionary_patterns = {}
                              endif
                              "}}}
                            
                              " Set caching event.
                              autocmd neocomplcache FileType * call s:caching()
                            
                              " Create cache directory.
                              if !isdirectory(neocomplcache#get_temporary_directory() . '/dictionary_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/dictionary_cache')
                              endif
                            
                              " Initialize check.
                              call s:caching()
                            endfunction"}}}
                            
    1              0.000003 function! s:source.finalize() "{{{
                              delcommand NeoComplCacheCachingDictionary
                            endfunction"}}}
                            
    1              0.000004 function! s:source.get_keyword_list(complete_str) "{{{
                              let list = []
                            
                              let filetype = neocomplcache#is_text_mode() ?
                                    \ 'text' : neocomplcache#get_context_filetype()
                              if !has_key(s:dictionary_list, filetype)
                                " Caching.
                                call s:caching()
                              endif
                            
                              for ft in neocomplcache#get_source_filetypes(filetype)
                                call neocomplcache#cache#check_cache('dictionary_cache', ft,
                                      \ s:async_dictionary_list, s:dictionary_list, 1)
                            
                                for dict in neocomplcache#get_sources_list(s:dictionary_list, ft)
                                  let list += neocomplcache#dictionary_filter(dict, a:complete_str)
                                endfor
                              endfor
                            
                              return list
                            endfunction"}}}
                            
    1              0.000004 function! s:caching() "{{{
                              if !bufloaded(bufnr('%'))
                                return
                              endif
                            
                              let key = neocomplcache#is_text_mode() ?
                                    \ 'text' : neocomplcache#get_context_filetype()
                              for filetype in neocomplcache#get_source_filetypes(key)
                                if !has_key(s:dictionary_list, filetype)
                                      \ && !has_key(s:async_dictionary_list, filetype)
                                  call neocomplcache#sources#dictionary_complete#recaching(filetype)
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000005 function! s:caching_dictionary(filetype)
                              let filetype = a:filetype
                              if filetype == ''
                                let filetype = neocomplcache#get_context_filetype(1)
                              endif
                            
                              if has_key(s:async_dictionary_list, filetype)
                                    \ && filereadable(s:async_dictionary_list[filetype].cache_name)
                                " Delete old cache.
                                call delete(s:async_dictionary_list[filetype].cache_name)
                              endif
                            
                              call neocomplcache#sources#dictionary_complete#recaching(filetype)
                            endfunction
    1              0.000012 function! neocomplcache#sources#dictionary_complete#recaching(filetype) "{{{
                              if !exists('g:neocomplcache_dictionary_filetype_lists')
                                call neocomplcache#initialize()
                              endif
                            
                              let filetype = a:filetype
                              if filetype == ''
                                let filetype = neocomplcache#get_context_filetype(1)
                              endif
                            
                              " Caching.
                              let dictionaries = get(
                                    \ g:neocomplcache_dictionary_filetype_lists, filetype, '')
                            
                              if dictionaries == ''
                                if filetype != &filetype &&
                                      \ &l:dictionary != '' && &l:dictionary !=# &g:dictionary
                                  let dictionaries .= &l:dictionary
                                endif
                              endif
                            
                              let s:async_dictionary_list[filetype] = []
                            
                              let pattern = get(g:neocomplcache_dictionary_patterns, filetype,
                                    \ neocomplcache#get_keyword_pattern(filetype))
                              for dictionary in split(dictionaries, ',')
                                let dictionary = neocomplcache#util#substitute_path_separator(
                                      \ fnamemodify(dictionary, ':p'))
                                if filereadable(dictionary)
                                  call neocomplcache#print_debug('Caching dictionary: ' . dictionary)
                                  call add(s:async_dictionary_list[filetype], {
                                        \ 'filename' : dictionary,
                                        \ 'cachename' : neocomplcache#cache#async_load_from_file(
                                        \       'dictionary_cache', dictionary, pattern, 'D')
                                        \ })
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000018 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/helper.vim
Sourced 1 time
Total time:   0.000958
 Self time:   0.000958

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: helper.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 28 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000021 let s:save_cpo = &cpo
    1              0.000015 set cpo&vim
                            
    1              0.000010 function! neocomplcache#helper#get_cur_text() "{{{
                              let cur_text =
                                    \ (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?
                                    \      getline('.') :
                                    \      matchstr(getline('.'),
                                    \         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))
                            
                              if cur_text =~ '^.\{-}\ze\S\+$'
                                let complete_str = matchstr(cur_text, '\S\+$')
                                let cur_text = matchstr(cur_text, '^.\{-}\ze\S\+$')
                              else
                                let complete_str = ''
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              if neocomplcache.event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
                              let filetype = neocomplcache#get_context_filetype()
                              let wildcard = get(g:neocomplcache_wildcard_characters, filetype,
                                    \ get(g:neocomplcache_wildcard_characters, '_', '*'))
                              if g:neocomplcache_enable_wildcard &&
                                    \ wildcard !=# '*' && len(wildcard) == 1
                                " Substitute wildcard character.
                                while 1
                                  let index = stridx(complete_str, wildcard)
                                  if index <= 0
                                    break
                                  endif
                            
                                  let complete_str = complete_str[: index-1]
                                        \ . '*' . complete_str[index+1: ]
                                endwhile
                              endif
                            
                              let neocomplcache.cur_text = cur_text . complete_str
                            
                              " Save cur_text.
                              return neocomplcache.cur_text
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#helper#keyword_escape(complete_str) "{{{
                              " Fuzzy completion.
                              let keyword_len = len(a:complete_str)
                              let keyword_escape = s:keyword_escape(a:complete_str)
                              if g:neocomplcache_enable_fuzzy_completion
                                    \ && (g:neocomplcache_fuzzy_completion_start_length
                                    \          <= keyword_len && keyword_len < 20)
                                let pattern = keyword_len >= 8 ?
                                      \ '\0\\w*' : '\\%(\0\\w*\\|\U\0\E\\l*\\)'
                            
                                let start = g:neocomplcache_fuzzy_completion_start_length
                                if start <= 1
                                  let keyword_escape =
                                        \ substitute(keyword_escape, '\w', pattern, 'g')
                                elseif keyword_len < 8
                                  let keyword_escape = keyword_escape[: start - 2]
                                        \ . substitute(keyword_escape[start-1 :], '\w', pattern, 'g')
                                else
                                  let keyword_escape = keyword_escape[: 3] .
                                        \ substitute(keyword_escape[4:12], '\w',
                                        \   pattern, 'g') . keyword_escape[13:]
                                endif
                              else
                                " Underbar completion. "{{{
                                if g:neocomplcache_enable_underbar_completion
                                      \ && keyword_escape =~ '[^_]_\|^_'
                                  let keyword_escape = substitute(keyword_escape,
                                        \ '\%(^\|[^_]\)\zs_', '[^_]*_', 'g')
                                endif
                                if g:neocomplcache_enable_underbar_completion
                                      \ && '-' =~ '\k' && keyword_escape =~ '[^-]-'
                                  let keyword_escape = substitute(keyword_escape,
                                        \ '[^-]\zs-', '[^-]*-', 'g')
                                endif
                                "}}}
                                " Camel case completion. "{{{
                                if g:neocomplcache_enable_camel_case_completion
                                      \ && keyword_escape =~ '\u\?\U*'
                                  let keyword_escape =
                                        \ substitute(keyword_escape,
                                        \ '\u\?\zs\U*',
                                        \ '\\%(\0\\l*\\|\U\0\E\\u*_\\?\\)', 'g')
                                endif
                                "}}}
                              endif
                            
                              call neocomplcache#print_debug(keyword_escape)
                              return keyword_escape
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#helper#is_omni_complete(cur_text) "{{{
                              " Check eskk complete length.
                              if neocomplcache#is_eskk_enabled()
                                    \ && exists('g:eskk#start_completion_length')
                                if !neocomplcache#is_eskk_convertion(a:cur_text)
                                      \ || !neocomplcache#is_multibyte_input(a:cur_text)
                                  return 0
                                endif
                            
                                let complete_pos = call(&l:omnifunc, [1, ''])
                                let complete_str = a:cur_text[complete_pos :]
                                return neocomplcache#util#mb_strlen(complete_str) >=
                                      \ g:eskk#start_completion_length
                              endif
                            
                              let filetype = neocomplcache#get_context_filetype()
                              let omnifunc = get(g:neocomplcache_omni_functions,
                                    \ filetype, &l:omnifunc)
                            
                              if neocomplcache#check_invalid_omnifunc(omnifunc)
                                return 0
                              endif
                            
                              let syn_name = neocomplcache#helper#get_syn_name(1)
                              if syn_name ==# 'Comment' || syn_name ==# 'String'
                                " Skip omni_complete in string literal.
                                return 0
                              endif
                            
                              if has_key(g:neocomplcache_force_omni_patterns, omnifunc)
                                let pattern = g:neocomplcache_force_omni_patterns[omnifunc]
                              elseif filetype != '' &&
                                    \ get(g:neocomplcache_force_omni_patterns, filetype, '') != ''
                                let pattern = g:neocomplcache_force_omni_patterns[filetype]
                              else
                                return 0
                              endif
                            
                              if a:cur_text !~# '\%(' . pattern . '\m\)$'
                                return 0
                              endif
                            
                              " Set omnifunc.
                              let &omnifunc = omnifunc
                            
                              return 1
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#helper#is_enabled_source(source_name) "{{{
                              if neocomplcache#is_disabled_source(a:source_name)
                                return 0
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              if !has_key(neocomplcache, 'sources')
                                call neocomplcache#helper#get_sources_list()
                              endif
                            
                              return index(keys(neocomplcache.sources), a:source_name) >= 0
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#helper#get_source_filetypes(filetype) "{{{
                              let filetype = (a:filetype == '') ? 'nothing' : a:filetype
                            
                              let filetype_dict = {}
                            
                              let filetypes = [filetype]
                              if filetype =~ '\.'
                                if exists('g:neocomplcache_ignore_composite_filetype_lists')
                                      \ && has_key(g:neocomplcache_ignore_composite_filetype_lists, filetype)
                                  let filetypes = [g:neocomplcache_ignore_composite_filetype_lists[filetype]]
                                else
                                  " Set composite filetype.
                                  let filetypes += split(filetype, '\.')
                                endif
                              endif
                            
                              if exists('g:neocomplcache_same_filetype_lists')
                                for ft in filetypes
                                  let filetypes += split(get(g:neocomplcache_same_filetype_lists, ft,
                                        \ get(g:neocomplcache_same_filetype_lists, '_', '')), ',')
                                endfor
                              endif
                            
                              return neocomplcache#util#uniq(filetypes)
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#helper#get_completion_length(plugin_name) "{{{
                              " Todo.
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#helper#complete_check() "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              if g:neocomplcache_enable_debug
                                echomsg split(reltimestr(reltime(neocomplcache.start_time)))[0]
                              endif
                              let ret = (!neocomplcache#is_prefetch() && complete_check())
                                    \ || (neocomplcache#is_auto_complete()
                                    \     && g:neocomplcache_skip_auto_completion_time != ''
                                    \     && split(reltimestr(reltime(neocomplcache.start_time)))[0] >
                                    \          g:neocomplcache_skip_auto_completion_time)
                              if ret
                                let neocomplcache = neocomplcache#get_current_neocomplcache()
                                let neocomplcache.skipped = 1
                            
                                redraw
                                echo 'Skipped.'
                              endif
                            
                              return ret
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#helper#get_syn_name(is_trans) "{{{
                              return len(getline('.')) < 200 ?
                                    \ synIDattr(synIDtrans(synID(line('.'), mode() ==# 'i' ?
                                    \          col('.')-1 : col('.'), a:is_trans)), 'name') : ''
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#helper#match_word(cur_text, ...) "{{{
                              let pattern = a:0 >= 1 ? a:1 : neocomplcache#get_keyword_pattern_end()
                            
                              " Check wildcard.
                              let complete_pos = s:match_wildcard(
                                    \ a:cur_text, pattern, match(a:cur_text, pattern))
                            
                              let complete_str = (complete_pos >=0) ?
                                    \ a:cur_text[complete_pos :] : ''
                            
                              return [complete_pos, complete_str]
                            endfunction"}}}
                            
    1              0.000006 function! neocomplcache#helper#filetype_complete(arglead, cmdline, cursorpos) "{{{
                              " Dup check.
                              let ret = {}
                              for item in map(
                                    \ split(globpath(&runtimepath, 'syntax/*.vim'), '\n') +
                                    \ split(globpath(&runtimepath, 'indent/*.vim'), '\n') +
                                    \ split(globpath(&runtimepath, 'ftplugin/*.vim'), '\n')
                                    \ , 'fnamemodify(v:val, ":t:r")')
                                if !has_key(ret, item) && item =~ '^'.a:arglead
                                  let ret[item] = 1
                                endif
                              endfor
                            
                              return sort(keys(ret))
                            endfunction"}}}
                            
    1              0.000011 function! neocomplcache#helper#unite_patterns(pattern_var, filetype) "{{{
                              let keyword_patterns = []
                              let dup_check = {}
                            
                              " Composite filetype.
                              for ft in split(a:filetype, '\.')
                                if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
                                  let dup_check[ft] = 1
                                  call add(keyword_patterns, a:pattern_var[ft])
                                endif
                            
                                " Same filetype.
                                if has_key(g:neocomplcache_same_filetype_lists, ft)
                                  for ft in split(g:neocomplcache_same_filetype_lists[ft], ',')
                                    if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
                                      let dup_check[ft] = 1
                                      call add(keyword_patterns, a:pattern_var[ft])
                                    endif
                                  endfor
                                endif
                              endfor
                            
                              if empty(keyword_patterns)
                                let default = get(a:pattern_var, '_', get(a:pattern_var, 'default', ''))
                                if default != ''
                                  call add(keyword_patterns, default)
                                endif
                              endif
                            
                              return join(keyword_patterns, '\m\|')
                            endfunction"}}}
                            
    1              0.000009 function! neocomplcache#helper#ftdictionary2list(dictionary, filetype) "{{{
                              let list = []
                              for filetype in neocomplcache#get_source_filetypes(a:filetype)
                                if has_key(a:dictionary, filetype)
                                  call add(list, a:dictionary[filetype])
                                endif
                              endfor
                            
                              return list
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#helper#get_sources_list(...) "{{{
                              let filetype = neocomplcache#get_context_filetype()
                            
                              let source_names = exists('b:neocomplcache_sources_list') ?
                                    \ b:neocomplcache_sources_list :
                                    \ get(a:000, 0,
                                    \   get(g:neocomplcache_sources_list, filetype,
                                    \     get(g:neocomplcache_sources_list, '_', ['_'])))
                              let disabled_sources = get(
                                    \ g:neocomplcache_disabled_sources_list, filetype,
                                    \   get(g:neocomplcache_disabled_sources_list, '_', []))
                              call neocomplcache#init#_sources(source_names)
                            
                              let all_sources = neocomplcache#available_sources()
                              let sources = {}
                              for source_name in source_names
                                if source_name ==# '_'
                                  " All sources.
                                  let sources = all_sources
                                  break
                                endif
                            
                                if !has_key(all_sources, source_name)
                                  call neocomplcache#print_warning(printf(
                                        \ 'Invalid source name "%s" is given.', source_name))
                                  continue
                                endif
                            
                                let sources[source_name] = all_sources[source_name]
                              endfor
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                              let neocomplcache.sources = filter(sources, "
                                    \ index(disabled_sources, v:val.name) < 0 &&
                                    \   (empty(v:val.filetypes) ||
                                    \    get(v:val.filetypes, neocomplcache.context_filetype, 0))")
                            
                              return neocomplcache.sources
                            endfunction"}}}
                            
    1              0.000004 function! neocomplcache#helper#clear_result() "{{{
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              let neocomplcache.complete_str = ''
                              let neocomplcache.candidates = []
                              let neocomplcache.complete_results = []
                              let neocomplcache.complete_pos = -1
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#helper#call_hook(sources, hook_name, context) "{{{
                              for source in neocomplcache#util#convert2list(a:sources)
                                try
                                  if !has_key(source.hooks, a:hook_name)
                                    if a:hook_name ==# 'on_init' && has_key(source, 'initialize')
                                      call source.initialize()
                                    elseif a:hook_name ==# 'on_final' && has_key(source, 'finalize')
                                      call source.finalize()
                                    endif
                                  else
                                    call call(source.hooks[a:hook_name],
                                          \ [extend(source.neocomplcache__context, a:context)],
                                          \ source.hooks)
                                  endif
                                catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error(
                                        \ '[unite.vim] Error occured in calling hook "' . a:hook_name . '"!')
                                  call unite#print_error(
                                        \ '[unite.vim] Source name is ' . source.name)
                                endtry
                              endfor
                            endfunction"}}}
                            
    1              0.000006 function! neocomplcache#helper#call_filters(filters, source, context) "{{{
                              let context = extend(a:source.neocomplcache__context, a:context)
                              let _ = []
                              for filter in neocomplcache#init#_filters(
                                    \ neocomplcache#util#convert2list(a:filters))
                                try
                                  let context.candidates = call(filter.filter, [context], filter)
                                catch
                                  call unite#print_error(v:throwpoint)
                                  call unite#print_error(v:exception)
                                  call unite#print_error(
                                        \ '[unite.vim] Error occured in calling filter '
                                        \   . filter.name . '!')
                                  call unite#print_error(
                                        \ '[unite.vim] Source name is ' . a:source.name)
                                endtry
                              endfor
                            
                              return context.candidates
                            endfunction"}}}
                            
    1              0.000007 function! s:match_wildcard(cur_text, pattern, complete_pos) "{{{
                              let complete_pos = a:complete_pos
                              while complete_pos > 1 && a:cur_text[complete_pos - 1] == '*'
                                let left_text = a:cur_text[: complete_pos - 2]
                                if left_text == '' || left_text !~ a:pattern
                                  break
                                endif
                            
                                let complete_pos = match(left_text, a:pattern)
                              endwhile
                            
                              return complete_pos
                            endfunction"}}}
                            
    1              0.000004 function! s:keyword_escape(complete_str) "{{{
                              let keyword_escape = escape(a:complete_str, '~" \.^$[]')
                              if g:neocomplcache_enable_wildcard
                                let keyword_escape = substitute(
                                      \ substitute(keyword_escape, '.\zs\*', '.*', 'g'),
                                      \ '\%(^\|\*\)\zs\*', '\\*', 'g')
                              else
                                let keyword_escape = escape(keyword_escape, '*')
                              endif
                            
                              return keyword_escape
                            endfunction"}}}
                            
    1              0.000019 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/filename_complete.vim
Sourced 1 time
Total time:   0.000660
 Self time:   0.000660

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: filename_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 01 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000018 let s:save_cpo = &cpo
    1              0.000015 set cpo&vim
                            
    1              0.000035 let s:source = {
                                  \ 'name' : 'filename_complete',
                                  \ 'kind' : 'manual',
                                  \ 'mark' : '[F]',
                                  \ 'rank' : 3,
                                  \ 'min_pattern_length' :
                                  \        g:neocomplcache_auto_completion_start_length,
                                  \}
                            
    1              0.000006 function! s:source.initialize() "{{{
                            endfunction"}}}
    1              0.000004 function! s:source.finalize() "{{{
                            endfunction"}}}
                            
    1              0.000004 function! s:source.get_keyword_pos(cur_text) "{{{
                              let filetype = neocomplcache#get_context_filetype()
                              if filetype ==# 'vimshell' || filetype ==# 'unite'
                                return -1
                              endif
                            
                              " Filename pattern.
                              let pattern = neocomplcache#get_keyword_pattern_end('filename')
                              let [complete_pos, complete_str] =
                                    \ neocomplcache#match_word(a:cur_text, pattern)
                              if complete_str =~ '//' ||
                                    \ (neocomplcache#is_auto_complete() &&
                                    \    (complete_str !~ '/' ||
                                    \     complete_str =~#
                                    \          '\\[^ ;*?[]"={}'']\|\.\.\+$\|/c\%[ygdrive/]$'))
                                " Not filename pattern.
                                return -1
                              endif
                            
                              if neocomplcache#is_sources_complete() && complete_pos < 0
                                let complete_pos = len(a:cur_text)
                              endif
                            
                              return complete_pos
                            endfunction"}}}
                            
    1              0.000004 function! s:source.get_complete_words(complete_pos, complete_str) "{{{
                              return s:get_glob_files(a:complete_str, '')
                            endfunction"}}}
                            
    1              0.000004 let s:cached_files = {}
                            
    1              0.000004 function! s:get_glob_files(complete_str, path) "{{{
                              let path = ',,' . substitute(a:path, '\.\%(,\|$\)\|,,', '', 'g')
                            
                              let complete_str = neocomplcache#util#substitute_path_separator(
                                    \ substitute(a:complete_str, '\\\(.\)', '\1', 'g'))
                            
                              let glob = (complete_str !~ '\*$')?
                                    \ complete_str . '*' : complete_str
                            
                              if a:path == '' && complete_str !~ '/'
                                if !has_key(s:cached_files, getcwd())
                                  call s:caching_current_files()
                                endif
                            
                                let files = copy(s:cached_files[getcwd()])
                              else
                                let ftype = getftype(glob)
                                if ftype != '' && ftype !=# 'dir'
                                  " Note: If glob() device files, Vim may freeze!
                                  return []
                                endif
                            
                                if a:path == ''
                                  let files = neocomplcache#util#glob(glob)
                                else
                                  try
                                    let globs = globpath(path, glob)
                                  catch
                                    return []
                                  endtry
                                  let files = split(substitute(globs, '\\', '/', 'g'), '\n')
                                endif
                              endif
                            
                              let files = neocomplcache#keyword_filter(map(
                                    \ files, '{
                                    \    "word" : fnamemodify(v:val, ":t"),
                                    \    "orig" : v:val,
                                    \ }'),
                                    \ fnamemodify(complete_str, ':t'))
                            
                              if neocomplcache#is_auto_complete()
                                    \ && len(files) > g:neocomplcache_max_list
                                let files = files[: g:neocomplcache_max_list - 1]
                              endif
                            
                              let files = map(files, '{
                                    \    "word" : substitute(v:val.orig, "//", "/", "g"),
                                    \ }')
                            
                              if a:complete_str =~ '^\$\h\w*'
                                let env = matchstr(a:complete_str, '^\$\h\w*')
                                let env_ev = eval(env)
                                if neocomplcache#is_windows()
                                  let env_ev = substitute(env_ev, '\\', '/', 'g')
                                endif
                                let len_env = len(env_ev)
                              else
                                let len_env = 0
                              endif
                            
                              let home_pattern = '^'.
                                    \ neocomplcache#util#substitute_path_separator(
                                    \ expand('~')).'/'
                              let exts = escape(substitute($PATHEXT, ';', '\\|', 'g'), '.')
                            
                              let dir_list = []
                              let file_list = []
                              for dict in files
                                call add(isdirectory(dict.word) ?
                                      \ dir_list : file_list, dict)
                            
                                let dict.orig = dict.word
                            
                                if len_env != 0 && dict.word[: len_env-1] == env_ev
                                  let dict.word = env . dict.word[len_env :]
                                endif
                            
                                let abbr = dict.word
                                if isdirectory(dict.word) && dict.word !~ '/$'
                                  let abbr .= '/'
                                  if g:neocomplcache_enable_auto_delimiter
                                    let dict.word .= '/'
                                  endif
                                elseif neocomplcache#is_windows()
                                  if '.'.fnamemodify(dict.word, ':e') =~ exts
                                    let abbr .= '*'
                                  endif
                                elseif executable(dict.word)
                                  let abbr .= '*'
                                endif
                                let dict.abbr = abbr
                            
                                if a:complete_str =~ '^\~/'
                                  let dict.word = substitute(dict.word, home_pattern, '\~/', '')
                                  let dict.abbr = substitute(dict.abbr, home_pattern, '\~/', '')
                                endif
                            
                                " Escape word.
                                let dict.word = escape(dict.word, ' ;*?[]"={}''')
                              endfor
                            
                              return dir_list + file_list
                            endfunction"}}}
    1              0.000008 function! s:caching_current_files() "{{{
                              let s:cached_files[getcwd()] = neocomplcache#util#glob('*')
                              if !exists('vimproc#readdir')
                                let s:cached_files[getcwd()] += neocomplcache#util#glob('.*')
                              endif
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#sources#filename_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000006 function! neocomplcache#sources#filename_complete#get_complete_words(complete_str, path) "{{{
                              if !neocomplcache#is_enabled()
                                return []
                              endif
                            
                              return s:get_glob_files(a:complete_str, a:path)
                            endfunction"}}}
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/filename_include.vim
Sourced 1 time
Total time:   0.000726
 Self time:   0.000726

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: filename_include.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 29 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000012 let s:save_cpo = &cpo
    1              0.000010 set cpo&vim
                            
                            " Global options definition. "{{{
    1              0.000008 if !exists('g:neocomplcache_include_patterns')
    1              0.000004   let g:neocomplcache_include_patterns = {}
    1              0.000002 endif
    1              0.000005 if !exists('g:neocomplcache_include_exprs')
    1              0.000003   let g:neocomplcache_include_exprs = {}
    1              0.000001 endif
    1              0.000004 if !exists('g:neocomplcache_include_paths')
    1              0.000003   let g:neocomplcache_include_paths = {}
    1              0.000002 endif
    1              0.000004 if !exists('g:neocomplcache_include_suffixes')
    1              0.000003   let g:neocomplcache_include_suffixes = {}
    1              0.000006 endif
                            "}}}
                            
    1              0.000018 let s:source = {
                                  \ 'name' : 'filename_include',
                                  \ 'kind' : 'manual',
                                  \ 'mark' : '[FI]',
                                  \ 'rank' : 10,
                                  \ 'min_pattern_length' :
                                  \        g:neocomplcache_auto_completion_start_length,
                                  \}
                            
    1              0.000003 function! s:source.initialize() "{{{
                              " Initialize.
                            
                              " Initialize filename include expr. "{{{
                              let g:neocomplcache_filename_include_exprs =
                                    \ get(g:, 'neocomplcache_filename_include_exprs', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_filename_include_exprs',
                                    \ 'perl',
                                    \ 'fnamemodify(substitute(v:fname, "/", "::", "g"), ":r")')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_filename_include_exprs',
                                    \ 'ruby,python,java,d',
                                    \ 'fnamemodify(substitute(v:fname, "/", ".", "g"), ":r")')
                              "}}}
                            
                              " Initialize filename include extensions. "{{{
                              let g:neocomplcache_filename_include_exts =
                                    \ get(g:, 'neocomplcache_filename_include_exts', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_filename_include_exts',
                                    \ 'c', ['h'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_filename_include_exts',
                                    \ 'cpp', ['', 'h', 'hpp', 'hxx'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_filename_include_exts',
                                    \ 'perl', ['pm'])
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_filename_include_exts',
                                    \ 'java', ['java'])
                              "}}}
                            endfunction"}}}
    1              0.000003 function! s:source.finalize() "{{{
                            endfunction"}}}
                            
    1              0.000003 function! s:source.get_keyword_pos(cur_text) "{{{
                              let filetype = neocomplcache#get_context_filetype()
                            
                              " Not Filename pattern.
                              if exists('g:neocomplcache_include_patterns')
                                let pattern = get(g:neocomplcache_include_patterns, filetype,
                                    \      &l:include)
                              else
                                let pattern = ''
                              endif
                              if neocomplcache#is_auto_complete()
                                    \ && (pattern == '' || a:cur_text !~ pattern)
                                    \ && a:cur_text =~ '\*$\|\.\.\+$\|/c\%[ygdrive/]$'
                                " Skip filename completion.
                                return -1
                              endif
                            
                              " Check include pattern.
                              let pattern = get(g:neocomplcache_include_patterns, filetype,
                                    \      &l:include)
                              if pattern == '' || a:cur_text !~ pattern
                                return -1
                              endif
                            
                              let match_end = matchend(a:cur_text, pattern)
                              let complete_str = matchstr(a:cur_text[match_end :], '\f\+')
                            
                              let expr = get(g:neocomplcache_include_exprs, filetype,
                                    \      &l:includeexpr)
                              if expr != ''
                                let cur_text =
                                      \ substitute(eval(substitute(expr,
                                      \ 'v:fname', string(complete_str), 'g')),
                                      \  '\.\w*$', '', '')
                              endif
                            
                              let complete_pos = len(a:cur_text) - len(complete_str)
                              if neocomplcache#is_sources_complete() && complete_pos < 0
                                let complete_pos = len(a:cur_text)
                              endif
                            
                              return complete_pos
                            endfunction"}}}
                            
    1              0.000007 function! s:source.get_complete_words(complete_pos, complete_str) "{{{
                              return s:get_include_files(a:complete_str)
                            endfunction"}}}
                            
    1              0.000012 function! s:get_include_files(complete_str) "{{{
                              let filetype = neocomplcache#get_context_filetype()
                            
                              let path = neocomplcache#util#substitute_path_separator(
                                    \ get(g:neocomplcache_include_paths, filetype,
                                    \   &l:path))
                              let pattern = get(g:neocomplcache_include_patterns, filetype,
                                    \ &l:include)
                              let expr = get(g:neocomplcache_include_exprs, filetype,
                                    \ &l:includeexpr)
                              let reverse_expr = get(g:neocomplcache_filename_include_exprs, filetype,
                                    \ '')
                              let exts = get(g:neocomplcache_filename_include_exts, filetype,
                                    \ [])
                            
                              let line = neocomplcache#get_cur_text()
                              if line =~ '^\s*\<require_relative\>' && &filetype =~# 'ruby'
                                " For require_relative.
                                let path = '.'
                              endif
                            
                              let match_end = matchend(line, pattern)
                              let complete_str = matchstr(line[match_end :], '\f\+')
                              if expr != ''
                                let complete_str =
                                      \ substitute(eval(substitute(expr,
                                      \ 'v:fname', string(complete_str), 'g')), '\.\w*$', '', '')
                              endif
                            
                              " Path search.
                              let glob = (complete_str !~ '\*$')?
                                    \ complete_str . '*' : complete_str
                              let cwd = getcwd()
                              let bufdirectory = neocomplcache#util#substitute_path_separator(
                                    \ fnamemodify(expand('%'), ':p:h'))
                              let dir_list = []
                              let file_list = s:get_default_include_files(filetype)
                              for subpath in split(path, '[,;]')
                                let dir = (subpath == '.') ? bufdirectory : subpath
                                if !isdirectory(dir)
                                  continue
                                endif
                            
                                execute 'lcd' fnameescape(dir)
                            
                                for word in split(
                                      \ neocomplcache#util#substitute_path_separator(
                                      \   glob(glob)), '\n')
                                  let dict = { 'word' : word }
                            
                                  call add(isdirectory(word) ? dir_list : file_list, dict)
                            
                                  let abbr = dict.word
                                  if isdirectory(word)
                                    let abbr .= '/'
                                    if g:neocomplcache_enable_auto_delimiter
                                      let dict.word .= '/'
                                    endif
                                  elseif !empty(exts) &&
                                        \ index(exts, fnamemodify(dict.word, ':e')) < 0
                                    " Skip.
                                    continue
                                  endif
                                  let dict.abbr = abbr
                            
                                  if reverse_expr != ''
                                    " Convert filename.
                                    let dict.word = eval(substitute(reverse_expr,
                                          \ 'v:fname', string(dict.word), 'g'))
                                    let dict.abbr = eval(substitute(reverse_expr,
                                          \ 'v:fname', string(dict.abbr), 'g'))
                                  else
                                    " Escape word.
                                    let dict.word = escape(dict.word, ' ;*?[]"={}''')
                                  endif
                                endfor
                              endfor
                              execute 'lcd' fnameescape(cwd)
                            
                              return neocomplcache#keyword_filter(dir_list, a:complete_str)
                                    \ + neocomplcache#keyword_filter(file_list, a:complete_str)
                            endfunction"}}}
                            
    1              0.000004 function! s:get_default_include_files(filetype) "{{{
                              let files = []
                            
                              if a:filetype ==# 'python' || a:filetype ==# 'python3'
                                let files = ['sys']
                              endif
                            
                              return map(files, "{ 'word' : v:val }")
                            endfunction"}}}
                            
    1              0.000006 function! neocomplcache#sources#filename_include#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000012 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/include_complete.vim
Sourced 1 time
Total time:   0.001422
 Self time:   0.000937

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: include_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 24 Apr 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000009 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000014 let s:source = {
                                  \ 'name' : 'include_complete',
                                  \ 'kind' : 'keyword',
                                  \ 'rank' : 8,
                                  \}
                            
    1              0.000004 function! s:source.initialize() "{{{
                              call s:initialize_variables()
                            
                              if neocomplcache#has_vimproc()
                                augroup neocomplcache
                                  " Caching events
                                  autocmd BufWritePost * call s:check_buffer('', 0)
                                  autocmd CursorHold * call s:check_cache()
                                augroup END
                              endif
                            
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_include_max_processes', 20)
                            
                              " Create cache directory.
                              if !isdirectory(neocomplcache#get_temporary_directory() . '/include_cache')
                                call mkdir(neocomplcache#get_temporary_directory()
                                      \ . '/include_cache', 'p')
                              endif
                            
                              if neocomplcache#exists_echodoc()
                                call echodoc#register('include_complete', s:doc_dict)
                              endif
                            endfunction"}}}
                            
    1              0.000002 function! s:source.finalize() "{{{
                              delcommand NeoComplCacheCachingInclude
                            
                              if neocomplcache#exists_echodoc()
                                call echodoc#unregister('include_complete')
                              endif
                            endfunction"}}}
                            
    1              0.000003 function! s:source.get_keyword_list(complete_str) "{{{
                              if neocomplcache#within_comment()
                                return []
                              endif
                            
                              if !has_key(s:include_info, bufnr('%'))
                                " Auto caching.
                                call s:check_buffer('', 0)
                              endif
                            
                              let keyword_list = []
                            
                              " Check caching.
                              for include in s:include_info[bufnr('%')].include_files
                                call neocomplcache#cache#check_cache(
                                      \ 'include_cache', include, s:async_include_cache, s:include_cache)
                                if has_key(s:include_cache, include)
                                  let s:cache_accessed_time[include] = localtime()
                                  let keyword_list += neocomplcache#dictionary_filter(
                                        \ s:include_cache[include], a:complete_str)
                                endif
                              endfor
                            
                              return neocomplcache#keyword_filter(
                                    \ neocomplcache#dup_filter(keyword_list), a:complete_str)
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#sources#include_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#sources#include_complete#get_include_files(bufnumber) "{{{
                              if has_key(s:include_info, a:bufnumber)
                                return copy(s:include_info[a:bufnumber].include_files)
                              else
                                return s:get_buffer_include_files(a:bufnumber)
                              endif
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#sources#include_complete#get_include_tags(bufnumber) "{{{
                              return filter(map(
                                    \ neocomplcache#sources#include_complete#get_include_files(a:bufnumber),
                                    \ "neocomplcache#cache#encode_name('tags_output', v:val)"),
                                    \ 'filereadable(v:val)')
                            endfunction"}}}
                            
                            " For Debug.
    1              0.000005 function! neocomplcache#sources#include_complete#get_current_include_files() "{{{
                              return s:get_buffer_include_files(bufnr('%'))
                            endfunction"}}}
                            
                            " For echodoc. "{{{
    1              0.000023 let s:doc_dict = {
                                  \ 'name' : 'include_complete',
                                  \ 'rank' : 5,
                                  \ 'filetypes' : {},
                                  \ }
    1              0.000007 function! s:doc_dict.search(cur_text) "{{{
                              if &filetype ==# 'vim' || !has_key(s:include_info, bufnr('%'))
                                return []
                              endif
                            
                              let completion_length = 2
                            
                              " Collect words.
                              let words = []
                              let i = 0
                              while i >= 0
                                let word = matchstr(a:cur_text, '\k\+', i)
                                if len(word) >= completion_length
                                  call add(words, word)
                                endif
                            
                                let i = matchend(a:cur_text, '\k\+', i)
                              endwhile
                            
                              for word in reverse(words)
                                let key = tolower(word[: completion_length-1])
                            
                                for include in filter(copy(s:include_info[bufnr('%')].include_files),
                                      \ 'has_key(s:include_cache, v:val) && has_key(s:include_cache[v:val], key)')
                                  for matched in filter(values(s:include_cache[include][key]),
                                        \ 'v:val.word ==# word && has_key(v:val, "kind") && v:val.kind != ""')
                                    let ret = []
                            
                                    let match = match(matched.abbr, neocomplcache#escape_match(word))
                                    if match > 0
                                      call add(ret, { 'text' : matched.abbr[ : match-1] })
                                    endif
                            
                                    call add(ret, { 'text' : word, 'highlight' : 'Identifier' })
                                    call add(ret, { 'text' : matched.abbr[match+len(word) :] })
                            
                                    if match > 0 || len(ret[-1].text) > 0
                                      return ret
                                    endif
                                  endfor
                                endfor
                              endfor
                            
                              return []
                            endfunction"}}}
                            "}}}
                            
    1              0.000003 function! s:check_buffer(bufnumber, is_force) "{{{
                              if !neocomplcache#is_enabled_source('include_complete')
                                return
                              endif
                            
                              let bufnumber = (a:bufnumber == '') ? bufnr('%') : a:bufnumber
                              let filename = fnamemodify(bufname(bufnumber), ':p')
                            
                              if !has_key(s:include_info, bufnumber)
                                " Initialize.
                                let s:include_info[bufnumber] = {
                                      \ 'include_files' : [], 'lines' : [],
                                      \ 'async_files' : {},
                                      \ }
                              endif
                            
                              if !executable(g:neocomplcache_ctags_program)
                                    \ || (!a:is_force && !neocomplcache#has_vimproc())
                                return
                              endif
                            
                              let include_info = s:include_info[bufnumber]
                            
                              if a:is_force || include_info.lines !=# getbufline(bufnumber, 1, 100)
                                let include_info.lines = getbufline(bufnumber, 1, 100)
                            
                                " Check include files contained bufname.
                                let include_files = s:get_buffer_include_files(bufnumber)
                            
                                " Check include files from function.
                                let filetype = getbufvar(a:bufnumber, '&filetype')
                                let function = get(g:neocomplcache_include_functions, filetype, '')
                                if function != '' && getbufvar(bufnumber, '&buftype') !~ 'nofile'
                                  let path = get(g:neocomplcache_include_paths, filetype,
                                        \ getbufvar(a:bufnumber, '&path'))
                                  let include_files += call(function,
                                        \ [getbufline(bufnumber, 1, (a:is_force ? '$' : 1000)), path])
                                endif
                            
                                if getbufvar(bufnumber, '&buftype') !~ 'nofile'
                                      \ && filereadable(filename)
                                  call add(include_files, filename)
                                endif
                                let include_info.include_files = neocomplcache#util#uniq(include_files)
                              endif
                            
                              if g:neocomplcache_include_max_processes <= 0
                                return
                              endif
                            
                              let filetype = getbufvar(bufnumber, '&filetype')
                              if filetype == ''
                                let filetype = 'nothing'
                              endif
                            
                              for filename in include_info.include_files
                                if (a:is_force || !has_key(include_info.async_files, filename))
                                      \ && !has_key(s:include_cache, filename)
                                  if !a:is_force && has_key(s:async_include_cache, filename)
                                        \ && len(s:async_include_cache[filename])
                                        \            >= g:neocomplcache_include_max_processes
                                    break
                                  endif
                            
                                  " Caching.
                                  let s:async_include_cache[filename]
                                        \ = [ s:initialize_include(filename, filetype) ]
                                  let include_info.async_files[filename] = 1
                                endif
                              endfor
                            endfunction"}}}
    1              0.000004 function! s:get_buffer_include_files(bufnumber) "{{{
                              let filetype = getbufvar(a:bufnumber, '&filetype')
                              if filetype == ''
                                return []
                              endif
                            
                              if (filetype ==# 'python' || filetype ==# 'python3')
                                    \ && (executable('python') || executable('python3'))
                                " Initialize python path pattern.
                            
                                let path = ''
                                if executable('python3')
                                  let path .= ',' . neocomplcache#system('python3 -',
                                      \ 'import sys;sys.stdout.write(",".join(sys.path))')
                                  call neocomplcache#util#set_default_dictionary(
                                        \ 'g:neocomplcache_include_paths', 'python3', path)
                                endif
                                if executable('python')
                                  let path .= ',' . neocomplcache#system('python -',
                                      \ 'import sys;sys.stdout.write(",".join(sys.path))')
                                endif
                                let path = join(neocomplcache#util#uniq(filter(
                                      \ split(path, ',', 1), "v:val != ''")), ',')
                                call neocomplcache#util#set_default_dictionary(
                                      \ 'g:neocomplcache_include_paths', 'python', path)
                              elseif filetype ==# 'cpp' && isdirectory('/usr/include/c++')
                                " Add cpp path.
                                call neocomplcache#util#set_default_dictionary(
                                      \ 'g:neocomplcache_include_paths', 'cpp',
                                      \ getbufvar(a:bufnumber, '&path') .
                                      \ ','.join(split(glob('/usr/include/c++/*'), '\n'), ','))
                              endif
                            
                              let pattern = get(g:neocomplcache_include_patterns, filetype,
                                    \ getbufvar(a:bufnumber, '&include'))
                              if pattern == ''
                                return []
                              endif
                              let path = get(g:neocomplcache_include_paths, filetype,
                                    \ getbufvar(a:bufnumber, '&path'))
                              let expr = get(g:neocomplcache_include_exprs, filetype,
                                    \ getbufvar(a:bufnumber, '&includeexpr'))
                              if has_key(g:neocomplcache_include_suffixes, filetype)
                                let suffixes = &l:suffixesadd
                              endif
                            
                              " Change current directory.
                              let cwd_save = getcwd()
                              let buffer_dir = fnamemodify(bufname(a:bufnumber), ':p:h')
                              if isdirectory(buffer_dir)
                                execute 'lcd' fnameescape(buffer_dir)
                              endif
                            
                              let include_files = s:get_include_files(0,
                                    \ getbufline(a:bufnumber, 1, 100), filetype, pattern, path, expr)
                            
                              if isdirectory(buffer_dir)
                                execute 'lcd' fnameescape(cwd_save)
                              endif
                            
                              " Restore option.
                              if has_key(g:neocomplcache_include_suffixes, filetype)
                                let &l:suffixesadd = suffixes
                              endif
                            
                              return include_files
                            endfunction"}}}
    1              0.000005 function! s:get_include_files(nestlevel, lines, filetype, pattern, path, expr) "{{{
                              let include_files = []
                              for line in a:lines "{{{
                                if line =~ a:pattern
                                  let match_end = matchend(line, a:pattern)
                                  if a:expr != ''
                                    let eval = substitute(a:expr, 'v:fname',
                                          \ string(matchstr(line[match_end :], '\f\+')), 'g')
                                    let filename = fnamemodify(findfile(eval(eval), a:path), ':p')
                                  else
                                    let filename = fnamemodify(findfile(
                                          \ matchstr(line[match_end :], '\f\+'), a:path), ':p')
                                  endif
                            
                                  if filereadable(filename)
                                    call add(include_files, filename)
                            
                                    if (a:filetype == 'c' || a:filetype == 'cpp') && a:nestlevel < 1
                                      let include_files += s:get_include_files(
                                            \ a:nestlevel + 1, readfile(filename)[:100],
                                            \ a:filetype, a:pattern, a:path, a:expr)
                                    endif
                                  elseif isdirectory(filename) && a:filetype ==# 'java'
                                    " For Java import with *.
                                    " Ex: import lejos.nxt.*
                                    let include_files +=
                                          \ neocomplcache#util#glob(filename . '/*.java')
                                  endif
                                endif
                              endfor"}}}
                            
                              return include_files
                            endfunction"}}}
                            
    1              0.000003 function! s:check_cache() "{{{
                              if neocomplcache#is_disabled_source('include_complete')
                                return
                              endif
                            
                              let release_accessd_time = localtime() - g:neocomplcache_release_cache_time
                            
                              for key in keys(s:include_cache)
                                if has_key(s:cache_accessed_time, key)
                                      \ && s:cache_accessed_time[key] < release_accessd_time
                                  call remove(s:include_cache, key)
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000003 function! s:initialize_include(filename, filetype) "{{{
                              " Initialize include list from tags.
                              return {
                                    \ 'filename' : a:filename,
                                    \ 'cachename' : neocomplcache#cache#async_load_from_tags(
                                    \              'include_cache', a:filename, a:filetype, 'I', 1)
                                    \ }
                            endfunction"}}}
    1              0.000006 function! neocomplcache#sources#include_complete#caching_include(bufname) "{{{
                              let bufnumber = (a:bufname == '') ? bufnr('%') : bufnr(a:bufname)
                              if has_key(s:async_include_cache, bufnumber)
                                    \ && filereadable(s:async_include_cache[bufnumber].cache_name)
                                " Delete old cache.
                                call delete(s:async_include_cache[bufnumber].cache_name)
                              endif
                            
                              " Initialize.
                              if has_key(s:include_info, bufnumber)
                                call remove(s:include_info, bufnumber)
                              endif
                            
                              call s:check_buffer(bufnumber, 1)
                            endfunction"}}}
                            
                            " Analyze include files functions.
    1              0.000006 function! neocomplcache#sources#include_complete#analyze_vim_include_files(lines, path) "{{{
                              let include_files = []
                              let dup_check = {}
                              for line in a:lines
                                if line =~ '\<\h\w*#' && line !~ '\<function!\?\>'
                                  let filename = 'autoload/' . substitute(matchstr(line, '\<\%(\h\w*#\)*\h\w*\ze#'),
                                        \ '#', '/', 'g') . '.vim'
                                  if filename == '' || has_key(dup_check, filename)
                                    continue
                                  endif
                                  let dup_check[filename] = 1
                            
                                  let filename = fnamemodify(findfile(filename, &runtimepath), ':p')
                                  if filereadable(filename)
                                    call add(include_files, filename)
                                  endif
                                endif
                              endfor
                            
                              return include_files
                            endfunction"}}}
    1              0.000006 function! neocomplcache#sources#include_complete#analyze_ruby_include_files(lines, path) "{{{
                              let include_files = []
                              let dup_check = {}
                              for line in a:lines
                                if line =~ '\<autoload\>'
                                  let args = split(line, ',')
                                  if len(args) < 2
                                    continue
                                  endif
                                  let filename = substitute(matchstr(args[1], '["'']\zs\f\+\ze["'']'),
                                        \ '\.', '/', 'g') . '.rb'
                                  if filename == '' || has_key(dup_check, filename)
                                    continue
                                  endif
                                  let dup_check[filename] = 1
                            
                                  let filename = fnamemodify(findfile(filename, a:path), ':p')
                                  if filereadable(filename)
                                    call add(include_files, filename)
                                  endif
                                endif
                              endfor
                            
                              return include_files
                            endfunction"}}}
                            
    1              0.000003 function! s:initialize_variables() "{{{
                              let s:include_info = {}
                              let s:include_cache = {}
                              let s:cache_accessed_time = {}
                              let s:async_include_cache = {}
                              let s:cached_pattern = {}
                            
                              " Initialize include pattern. "{{{
                              let g:neocomplcache_include_patterns =
                                    \ get(g:, 'neocomplcache_include_patterns', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_include_patterns',
                                    \ 'java,haskell', '^\s*\<import')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_include_patterns',
                                    \ 'cs', '^\s*\<using')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_include_patterns',
                                    \ 'ruby', '^\s*\<\%(load\|require\|require_relative\)\>')
                              "}}}
                              " Initialize expr pattern. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_include_exprs', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_include_exprs',
                                    \ 'haskell,cs',
                                    \ "substitute(v:fname, '\\.', '/', 'g')")
                              "}}}
                              " Initialize path pattern. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_include_paths', {})
                              "}}}
                              " Initialize include suffixes. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_include_suffixes', {})
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_include_suffixes',
                                    \ 'haskell', '.hs')
                              "}}}
                              " Initialize include functions. "{{{
                              call neocomplcache#util#set_default(
                                    \ 'g:neocomplcache_include_functions', {})
                              " call neocomplcache#util#set_default_dictionary(
                              "       \ 'g:neocomplcache_include_functions', 'vim',
                              "       \ 'neocomplcache#sources#include_complete#analyze_vim_include_files')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_include_functions', 'ruby',
                                    \ 'neocomplcache#sources#include_complete#analyze_ruby_include_files')
                              "}}}
                            endfunction"}}}
                            
    1              0.000005 if !exists('s:include_info')
    1   0.000495   0.000010   call s:initialize_variables()
    1              0.000002 endif
                            
    1              0.000008 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/vimproc/autoload/vimproc.vim
Sourced 1 time
Total time:   0.115217
 Self time:   0.060007

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: vimproc.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com> (Modified)
                            "          Yukihiro Nakadaira <yukihiro.nakadaira at gmail.com> (Original)
                            " Last Modified: 29 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
                            " Saving 'cpoptions' {{{
    1              0.000034 let s:save_cpo = &cpo
    1              0.000019 set cpo&vim
                            " }}}
                            
    1              0.000014 function! s:print_error(string)
                              echohl Error | echomsg a:string | echohl None
                            endfunction
                            
                            " MacVim trouble shooter {{{
    1              0.019226 if vimproc#util#is_mac() && !&encoding
    1              0.000208   set encoding=utf-8
    1              0.000006 endif
                            "}}}
                            
                            " Check 'encoding' "{{{
    1              0.000016 if &encoding =~# '^euc-jp'
                              call s:print_error('Sorry, vimproc is not supported this encoding environment.')
                              call s:print_error('You should set ''encoding'' option to "utf-8" '
                                    \ .'and set ''termencoding'' option to "euc-jp".')
                              finish
                            endif
                            "}}}
                            
                            " Global options definition. "{{{
                            " Set the default of g:vimproc_dll_path by judging OS "{{{
    1   0.000035   0.000026 if vimproc#util#is_windows()
                              if has('win64')
                                let s:vimproc_dll_basename = 'vimproc_win64.dll'
                              else
                                let s:vimproc_dll_basename = 'vimproc_win32.dll'
                              endif
                            elseif vimproc#util#is_cygwin()
                              let s:vimproc_dll_basename = 'vimproc_cygwin.dll'
                            elseif vimproc#util#is_mac()
    1              0.000011   let s:vimproc_dll_basename = 'vimproc_mac.so'
    1              0.000004 else
                              let s:vimproc_dll_basename = 'vimproc_unix.so'
                            endif
                            "}}}
                            
    1   0.000123   0.000066 call vimproc#util#set_default(
                                  \ 'g:vimproc#dll_path',
                                  \ expand('<sfile>:p:h') . '/' . s:vimproc_dll_basename,
                                  \ 'g:vimproc_dll_path')
    1              0.000010 unlet s:vimproc_dll_basename
                            
    1   0.000126   0.000068 call vimproc#util#set_default(
                                  \ 'g:vimproc#password_pattern',
                                  \ '\%(Enter \|[Oo]ld \|[Nn]ew \|login '  .
                                  \'\|Kerberos \|CVS \|UNIX \| SMB \|LDAP \|\[sudo] ' .
                                  \'\|^\|\n\|''s \)\%([Pp]assword\|[Pp]assphrase\)\>',
                                  \ 'g:vimproc_password_pattern')
    1   0.000102   0.000058 call vimproc#util#set_default(
                                  \ 'g:vimproc#popen2_commands', {
                                  \     'sh' : 1, 'bash' : 1, 'zsh' : 1, 'csh' : 1, 'tcsh' : 1,
                                  \     'tmux' : 1, 'screen' : 1, 'su' : 1,
                                  \     'python' : 1, 'rhino' : 1, 'ipython' : 1, 'ipython3' : 1, 'yaourt' : 1,
                                  \ }, 'g:vimproc_popen2_commands')
    1   0.000061   0.000021 call vimproc#util#set_default(
                                  \ 'g:stdinencoding', 'char')
    1   0.000056   0.000020 call vimproc#util#set_default(
                                  \ 'g:stdoutencoding', 'char')
    1   0.000055   0.000021 call vimproc#util#set_default(
                                  \ 'g:stderrencoding', 'char')
                            "}}}
                            
                            " Constants {{{
    1              0.000006 let g:vimproc#SIGINT = 2
    1              0.000006 let g:vimproc#SIGQUIT = 3
    1              0.000005 let g:vimproc#SIGILL = 4
    1              0.000006 let g:vimproc#SIGABRT = 6
    1              0.000006 let g:vimproc#SIGFPE = 8
    1              0.000006 let g:vimproc#SIGKILL = 9
    1              0.000006 let g:vimproc#SIGSEGV = 11
    1              0.000004 let g:vimproc#SIGPIPE = 13
    1              0.000018 let g:vimproc#SIGALRM = 14
    1              0.000007 let g:vimproc#SIGTERM = 15
    1              0.000007 let g:vimproc#SIGUSR1 = 10
    1              0.000006 let g:vimproc#SIGUSR2 = 12
    1              0.000007 let g:vimproc#SIGCHLD = 17
    1              0.000006 let g:vimproc#SIGCONT = 18
    1              0.000007 let g:vimproc#SIGSTOP = 19
    1              0.000006 let g:vimproc#SIGTSTP = 20
    1              0.000005 let g:vimproc#SIGTTIN = 21
    1              0.000005 let g:vimproc#SIGTTOU = 22
    1              0.000005 let g:vimproc#SIGWINCH = 28
                            " }}}
                            
    1   0.042053   0.000255 let g:vimproc#dll_path =
                                  \ vimproc#util#iconv(
                                  \ vimproc#util#substitute_path_separator(g:vimproc#dll_path),
                                  \ &encoding, vimproc#util#termencoding())
                            
                            " Backward compatibility.
    1              0.000010 let g:vimproc_password_pattern = g:vimproc#password_pattern
                            
    1              0.000053 if !filereadable(g:vimproc#dll_path) "{{{
                              function! vimproc#get_last_status()
                                return v:shell_error
                              endfunction
                            
                              function! vimproc#get_last_errmsg()
                                return ''
                              endfunction
                            
                              function! vimproc#system(...)
                                return call('system', a:000)
                              endfunction
                            
                              echoerr printf('vimproc''s DLL: "%s" is not found.
                                    \ Please read :help vimproc and make it.', g:vimproc#dll_path)
                            
                              finish
                            endif"}}}
                            
    1              0.000006 function! vimproc#version() "{{{
                              return str2nr(printf('%2d%02d', 7, 1))
                            endfunction"}}}
    1              0.000007 function! vimproc#dll_version() "{{{
                              let [dll_version] = s:libcall('vp_dlversion', [])
                              return str2nr(dll_version)
                            endfunction"}}}
                            
                            "-----------------------------------------------------------
                            " API
                            
    1              0.000006 function! vimproc#open(filename) "{{{
                              let filename = vimproc#util#iconv(fnamemodify(a:filename, ':p'),
                                    \ &encoding, vimproc#util#termencoding())
                            
                              if filename =~ '^\%(https\?\|ftp\)://'
                                      \ && !vimproc#host_exists(filename)
                                " URI is invalid.
                                call s:print_error('vimproc#open: URI "' . filename . '" is invalid.')
                                return
                              endif
                            
                              " Detect desktop environment.
                              if vimproc#util#is_windows()
                                " For URI only.
                                "execute '!start rundll32 url.dll,FileProtocolHandler' filename
                            
                                call s:libcall('vp_open', [filename])
                              elseif has('win32unix')
                                " Cygwin.
                                call vimproc#system(['cygstart', filename])
                              elseif executable('xdg-open')
                                " Linux.
                                call vimproc#system_bg(['xdg-open', filename])
                              elseif exists('$KDE_FULL_SESSION') && $KDE_FULL_SESSION ==# 'true'
                                " KDE.
                                call vimproc#system_bg(['kioclient', 'exec', filename])
                              elseif exists('$GNOME_DESKTOP_SESSION_ID')
                                " GNOME.
                                call vimproc#system_bg(['gnome-open', filename])
                              elseif executable('exo-open')
                                " Xfce.
                                call vimproc#system_bg(['exo-open', filename])
                              elseif vimproc#util#is_mac() && executable('open')
                                " Mac OS.
                                call vimproc#system_bg(['open', filename])
                              else
                                " Give up.
                                call s:print_error('vimproc#open: Not supported.')
                              endif
                            endfunction"}}}
                            
    1              0.000008 function! vimproc#get_command_name(command, ...) "{{{
                              let path = get(a:000, 0, $PATH)
                            
                              let cnt = a:0 < 2 ? 1 : a:2
                            
                              let files = split(substitute(vimproc#util#substitute_path_separator(
                                    \ vimproc#filepath#which(a:command, path)), '//', '/', 'g'), '\n')
                            
                              if cnt < 0
                                return files
                              endif
                            
                              let file = get(files, 0, '')
                            
                              if file == ''
                                throw printf(
                                      \ 'vimproc#get_command_name: File "%s" is not found.', a:command)
                              endif
                            
                              return file
                            endfunction"}}}
                            
    1              0.000013 function! s:system(cmdline, is_passwd, input, timeout, is_pty) "{{{
                              if empty(a:cmdline)
                                let s:last_status = 0
                                let s:last_errmsg = ''
                                return ''
                              endif
                            
                              " Open pipe.
                              let subproc = (type(a:cmdline[0]) == type('')) ? vimproc#popen3(a:cmdline) :
                                    \ a:is_pty ? vimproc#ptyopen(a:cmdline):
                                    \ vimproc#pgroup_open(a:cmdline)
                            
                              if a:input != ''
                                " Write input.
                                call subproc.stdin.write(a:input)
                              endif
                            
                              if a:timeout > 0 && has('reltime') && v:version >= 702
                                let start = reltime()
                                let timeout = a:timeout
                              else
                                let timeout = 0
                              endif
                            
                              if !a:is_passwd
                                call subproc.stdin.close()
                              endif
                            
                              let output = ''
                              let s:last_errmsg = ''
                              while !subproc.stdout.eof || !subproc.stderr.eof
                                if timeout > 0 "{{{
                                  " Check timeout.
                                  let end = split(reltimestr(reltime(start)))[0] * 1000
                                  if end > timeout && !subproc.stdout.eof
                                    " Kill process.
                                    " 15 == SIGTERM
                                    try
                                      call subproc.kill(15)
                                      call subproc.waitpid()
                                    catch
                                      " Ignore error.
                                    endtry
                            
                                    throw 'vimproc: vimproc#system(): Timeout.'
                                  endif
                                endif"}}}
                            
                                if !subproc.stdout.eof "{{{
                                  let out = subproc.stdout.read(1000, 0)
                            
                                  if a:is_passwd && out =~# g:vimproc_password_pattern
                                    redraw
                                    echo out
                            
                                    " Password input.
                                    set imsearch=0
                                    let in = vimproc#util#iconv(inputsecret('Input Secret : ')."\<NL>",
                                          \ &encoding, vimproc#util#termencoding())
                            
                                    call subproc.stdin.write(in)
                                  else
                                    let output .= out
                                  endif
                                endif"}}}
                            
                                if !subproc.stderr.eof "{{{
                                  let out = subproc.stderr.read(1000, 0)
                            
                                  if a:is_passwd && out =~# g:vimproc_password_pattern
                                    redraw
                                    echo out
                            
                                    " Password input.
                                    set imsearch=0
                                    let in = vimproc#util#iconv(inputsecret('Input Secret : ') . "\<NL>",
                                          \ &encoding, vimproc#util#termencoding())
                            
                                    call subproc.stdin.write(in)
                                  else
                                    let s:last_errmsg .= out
                                    let output .= out
                                  endif
                                endif"}}}
                              endwhile
                            
                              let [cond, status] = subproc.waitpid()
                            
                              " Newline convert.
                              if vimproc#util#is_mac()
                                let output = substitute(output, '\r\n\@!', '\n', 'g')
                              elseif has('win32') || has('win64')
                                let output = substitute(output, '\r\n', '\n', 'g')
                              endif
                            
                              return output
                            endfunction"}}}
    1              0.000009 function! vimproc#system(cmdline, ...) "{{{
                              if type(a:cmdline) == type('')
                                if a:cmdline =~ '&\s*$'
                                  let cmdline = substitute(a:cmdline, '&\s*$', '', '')
                                  return vimproc#system_bg(cmdline)
                                endif
                            
                                let args = vimproc#parser#parse_statements(a:cmdline)
                                for arg in args
                                  let arg.statement = vimproc#parser#parse_pipe(arg.statement)
                                endfor
                              else
                                let args = [{'statement' :
                                      \ [{ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                      \   'args' : a:cmdline }], 'condition' : 'always' }]
                              endif
                            
                              let timeout = get(a:000, 1, 0)
                              let input = get(a:000, 0, '')
                            
                              return s:system(args, 0, input, timeout, 0)
                            endfunction"}}}
    1              0.000007 function! vimproc#system2(...) "{{{
                              if empty(a:000)
                                return ''
                              endif
                            
                              if len(a:0) > 1
                                let args = deepcopy(a:000)
                                let args[1] = vimproc#util#iconv(
                                      \ args[1], &encoding, vimproc#util#stdinencoding())
                              else
                                let args = a:000
                              endif
                              let output = call('vimproc#system', args)
                            
                              " This function converts application encoding to &encoding.
                              let output = vimproc#util#iconv(
                                    \ output, vimproc#util#stdoutencoding(), &encoding)
                              let s:last_errmsg = vimproc#util#iconv(
                                    \ s:last_errmsg, vimproc#util#stderrencoding(), &encoding)
                            
                              return output
                            endfunction"}}}
    1              0.000008 function! vimproc#system_passwd(cmdline, ...) "{{{
                              if type(a:cmdline) == type('')
                                let args = vimproc#parser#parse_pipe(a:cmdline)
                              else
                                let args = [{ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                      \ 'args' : a:cmdline }]
                              endif
                            
                              let timeout = a:0 >= 2 ? a:2 : 0
                              let input = a:0 >= 1 ? a:1 : ''
                            
                              let lang_save = $LANG
                              try
                                let $LANG = 'C'
                            
                                return s:system(args, 1, input, timeout, 1)
                              finally
                                let $LANG = lang_save
                              endtry
                            endfunction"}}}
    1              0.000007 function! vimproc#system_bg(cmdline) "{{{
                              " Open pipe.
                              let subproc = vimproc#popen3(a:cmdline)
                              if empty(subproc)
                                " Not supported path error.
                                return ''
                              endif
                            
                              " Close handles.
                              call s:close_all(subproc)
                            
                              let s:bg_processes[subproc.pid] = subproc.pid
                            
                              return ''
                            endfunction"}}}
    1              0.000007 function! vimproc#system_gui(cmdline) "{{{
                              if vimproc#util#is_windows()
                                silent execute ':!start ' . join(map(vimproc#parser#split_args(a:cmdline), '"\"".v:val."\""'))
                                return ''
                              else
                                return vimproc#system_bg(a:cmdline)
                              endif
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#get_last_status() "{{{
                              return s:last_status
                            endfunction"}}}
    1              0.000007 function! vimproc#get_last_errmsg() "{{{
                              return substitute(vimproc#util#iconv(s:last_errmsg,
                                    \ vimproc#util#stderrencoding(), &encoding), '\n$', '', '')
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#shellescape(string) "{{{
                              return string(a:string)
                            endfunction"}}}
                            
    1              0.000012 function! vimproc#fopen(path, flags, ...) "{{{
                              let mode = get(a:000, 0, 0644)
                              let fd = s:vp_file_open(a:path, a:flags, mode)
                              let proc = s:fdopen(fd, 'vp_file_close', 'vp_file_read', 'vp_file_write')
                              return proc
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#popen2(args) "{{{
                              let args = type(a:args) == type('') ?
                                    \ vimproc#parser#split_args(a:args) :
                                    \ a:args
                            
                              return s:plineopen(2, [{
                                    \ 'args' : args,
                                    \ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                    \ }], 0)
                            endfunction"}}}
    1              0.000021 function! vimproc#popen3(args) "{{{
                              let args = type(a:args) == type('') ?
                                    \ vimproc#parser#split_args(a:args) :
                                    \ a:args
                            
                              return s:plineopen(3, [{
                                    \ 'args' : args,
                                    \ 'fd' : { 'stdin' : '', 'stdout' : '', 'stderr' : '' },
                                    \ }], 0)
                            endfunction"}}}
                            
    1              0.000008 function! vimproc#plineopen2(commands, ...) "{{{
                              let commands = type(a:commands) == type('') ?
                                    \ vimproc#parser#parse_pipe(a:commands) :
                                    \ a:commands
                              let is_pty = get(a:000, 0, 0)
                            
                              return s:plineopen(2, commands, is_pty)
                            endfunction"}}}
    1              0.000007 function! vimproc#plineopen3(commands, ...) "{{{
                              let commands = type(a:commands) == type('') ?
                                    \ vimproc#parser#parse_pipe(a:commands) :
                                    \ a:commands
                              let is_pty = get(a:000, 0, 0)
                            
                              return s:plineopen(3, commands, is_pty)
                            endfunction"}}}
    1              0.000013 function! s:plineopen(npipe, commands, is_pty) "{{{
                              let pid_list = []
                              let stdin_list = []
                              let stdout_list = []
                              let stderr_list = []
                              let npipe = a:npipe
                            
                              " Open input.
                              let hstdin = (empty(a:commands) || a:commands[0].fd.stdin == '')?
                                    \ 0 : vimproc#fopen(a:commands[0].fd.stdin, 'O_RDONLY').fd
                            
                              let is_pty = !vimproc#util#is_windows() && a:is_pty
                            
                              let cnt = 0
                              for command in a:commands
                                if is_pty && command.fd.stdout == '' && cnt == 0
                                      \ && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstdout = 1
                                else
                                  let mode = 'O_WRONLY | O_CREAT'
                                  if command.fd.stdout =~ '^>'
                                    let mode .= ' | O_APPEND'
                                    let command.fd.stdout = command.fd.stdout[1:]
                                  else
                                    let mode .= ' | O_TRUNC'
                                  endif
                            
                                  let hstdout = s:is_pseudo_device(command.fd.stdout) ?
                                        \ 0 : vimproc#fopen(command.fd.stdout, mode).fd
                                endif
                            
                                if is_pty && command.fd.stderr == '' && cnt == 0
                                      \ && len(a:commands) != 1
                                  " pty_open() use pipe.
                                  let hstderr = 1
                                else
                                  let mode = 'O_WRONLY | O_CREAT'
                                  if command.fd.stderr =~ '^>'
                                    let mode .= ' | O_APPEND'
                                    let command.fd.stderr = command.fd.stderr[1:]
                                  else
                                    let mode .= ' | O_TRUNC'
                                  endif
                                  let hstderr = s:is_pseudo_device(command.fd.stderr) ?
                                        \ 0 : vimproc#fopen(command.fd.stderr, mode).fd
                                endif
                            
                                if command.fd.stderr ==# '/dev/stdout'
                                  let npipe = 2
                                endif
                            
                                let args = s:convert_args(command.args)
                                let command_name = fnamemodify(args[0], ':t:r')
                                let pty_npipe = cnt == 0
                                      \ && hstdin == 0 && hstdout == 0 && hstderr == 0
                                      \ && exists('g:vimproc_popen2_commands')
                                      \ && get(g:vimproc_popen2_commands, command_name, 0) != 0 ?
                                      \ 2 : npipe
                            
                                if is_pty && (cnt == 0 || cnt == len(a:commands)-1)
                                  " Use pty_open().
                                  let pipe = s:vp_pty_open(pty_npipe, winwidth(0)-5, winheight(0),
                                        \ hstdin, hstdout, hstderr, args)
                                else
                                  let pipe = s:vp_pipe_open(pty_npipe,
                                        \ hstdin, hstdout, hstderr, args)
                                endif
                            
                                if len(pipe) == 4
                                  let [pid, fd_stdin, fd_stdout, fd_stderr] = pipe
                                  let stderr = s:fdopen(fd_stderr,
                                        \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                else
                                  let [pid, fd_stdin, fd_stdout] = pipe
                                  let stderr = s:closed_fdopen(
                                        \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                endif
                            
                                call add(pid_list, pid)
                                let stdin = s:fdopen(fd_stdin,
                                      \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                let stdin.is_pty = is_pty
                                      \ && (cnt == 0 || cnt == len(a:commands)-1)
                                      \ && hstdin == 0
                                call add(stdin_list, stdin)
                                let stdout = s:fdopen(fd_stdout,
                                      \ 'vp_pipe_close', 'vp_pipe_read', 'vp_pipe_write')
                                let stdout.is_pty = is_pty
                                      \ && (cnt == 0 || cnt == len(a:commands)-1)
                                      \ && hstdout == 0
                                call add(stdout_list, stdout)
                                let stderr.is_pty = is_pty
                                      \ && (cnt == 0 || cnt == len(a:commands)-1)
                                      \ && hstderr == 0
                                call add(stderr_list, stderr)
                            
                                let hstdin = stdout_list[-1].fd
                                let cnt += 1
                              endfor
                            
                              let proc = {}
                              let proc.pid_list = pid_list
                              let proc.pid = pid_list[-1]
                              let proc.stdin = s:fdopen_pipes(stdin_list,
                                    \ 'vp_pipes_close', 'read_pipes', 'write_pipes')
                              let proc.stdout = s:fdopen_pipes(stdout_list,
                                    \ 'vp_pipes_close', 'read_pipes', 'write_pipes')
                              let proc.stderr = s:fdopen_pipes(stderr_list,
                                    \ 'vp_pipes_close', 'read_pipes', 'write_pipes')
                              let proc.get_winsize = s:funcref('vp_get_winsize')
                              let proc.set_winsize = s:funcref('vp_set_winsize')
                              let proc.kill = s:funcref('vp_kill')
                              let proc.waitpid = s:funcref('vp_waitpid')
                              let proc.checkpid = s:funcref('vp_checkpid')
                              let proc.is_valid = 1
                              let proc.is_pty = is_pty
                              if a:is_pty
                                let proc.ttyname = ''
                                let proc.get_winsize = s:funcref('vp_get_winsize')
                                let proc.set_winsize = s:funcref('vp_set_winsize')
                              endif
                            
                              return proc
                            endfunction"}}}
                            
    1              0.000008 function! s:is_pseudo_device(filename) "{{{
                              if vimproc#util#is_windows() && (
                                \    a:filename ==# '/dev/stdin'
                                \ || a:filename ==# '/dev/stdout'
                                \ || a:filename ==# '/dev/stderr')
                                return 1
                              endif
                            
                              return a:filename == ''
                                    \ || a:filename ==# '/dev/null'
                                    \ || a:filename ==# '/dev/clip'
                                    \ || a:filename ==# '/dev/quickfix'
                            endfunction"}}}
                            
    1              0.000008 function! vimproc#pgroup_open(statements, ...) "{{{
                              if type(a:statements) == type('')
                                let statements =
                                      \ vimproc#parser#parse_statements(a:statements)
                                for statement in statements
                                  let statement.statement =
                                        \ vimproc#parser#parse_pipe(statement.statement)
                                endfor
                              else
                                let statements = a:statements
                              endif
                            
                              let is_pty = get(a:000, 0, 0)
                              let npipe = get(a:000, 1, 3)
                            
                              return s:pgroup_open(statements, is_pty && !vimproc#util#is_windows(), npipe)
                            endfunction"}}}
                            
    1              0.000007 function! s:pgroup_open(statements, is_pty, npipe) "{{{
                              let proc = {}
                              let proc.current_proc =
                                    \ vimproc#plineopen{a:npipe}(a:statements[0].statement, a:is_pty)
                            
                              let proc.pid = proc.current_proc.pid
                              let proc.pid_list = proc.current_proc.pid_list
                              let proc.condition = a:statements[0].condition
                              let proc.statements = a:statements[1:]
                              let proc.stdin = s:fdopen_pgroup(proc, proc.current_proc.stdin,
                                    \ 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                              let proc.stdout = s:fdopen_pgroup(proc, proc.current_proc.stdout,
                                    \ 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                              let proc.stderr = s:fdopen_pgroup(proc, proc.current_proc.stderr,
                                    \ 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                              let proc.kill = s:funcref('vp_pgroup_kill')
                              let proc.waitpid = s:funcref('vp_pgroup_waitpid')
                              let proc.is_valid = 1
                              let proc.is_pty = 0
                              " echomsg expand('<sfile>')
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdin.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stdout.fd), 'v:val.fd'))
                              " echomsg 'open:' string(map(copy(proc.current_proc.stderr.fd), 'v:val.fd'))
                            
                              return proc
                            endfunction"}}}
                            
    1              0.000008 function! vimproc#ptyopen(commands, ...) "{{{
                              let commands = type(a:commands) == type('') ?
                                    \ vimproc#parser#parse_pipe(a:commands) :
                                    \ a:commands
                              let npipe = get(a:000, 0, 3)
                            
                              return s:plineopen(npipe, commands, !vimproc#util#is_windows())
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#socket_open(host, port) "{{{
                              let fd = s:vp_socket_open(a:host, a:port)
                              return s:fdopen(fd, 'vp_socket_close', 'vp_socket_read', 'vp_socket_write')
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#host_exists(host) "{{{
                              let rval = s:vp_host_exists(
                                    \ substitute(substitute(a:host, '^\a\+://', '', ''), '/.*$', '', ''))
                              return 0 + rval
                            endfunction"}}}
                            
    1              0.000006 function! vimproc#kill(pid, sig) "{{{
                              try
                                call s:libcall('vp_kill', [a:pid, a:sig])
                              catch /kill() error:/
                                let s:last_errmsg = v:exception
                                return 1
                              endtry
                            
                              return 0
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#decode_signal(signal) "{{{
                              if a:signal == 2
                                return 'SIGINT'
                              elseif a:signal == 3
                                return 'SIGQUIT'
                              elseif a:signal == 4
                                return 'SIGILL'
                              elseif a:signal == 6
                                return 'SIGABRT'
                              elseif a:signal == 8
                                return 'SIGFPE'
                              elseif a:signal == 9
                                return 'SIGKILL'
                              elseif a:signal == 11
                                return 'SIGSEGV'
                              elseif a:signal == 13
                                return 'SIGPIPE'
                              elseif a:signal == 14
                                return 'SIGALRM'
                              elseif a:signal == 15
                                return 'SIGTERM'
                              elseif a:signal == 10
                                return 'SIGUSR1'
                              elseif a:signal == 12
                                return 'SIGUSR2'
                              elseif a:signal == 17
                                return 'SIGCHLD'
                              elseif a:signal == 18
                                return 'SIGCONT'
                              elseif a:signal == 19
                                return 'SIGSTOP'
                              elseif a:signal == 20
                                return 'SIGTSTP'
                              elseif a:signal == 21
                                return 'SIGTTIN'
                              elseif a:signal == 22
                                return 'SIGTTOU'
                              else
                                return 'UNKNOWN'
                              endif
                            endfunction"}}}
                            
    1              0.000009 function! vimproc#write(filename, string, ...) "{{{
                              if a:string == ''
                                return
                              endif
                            
                              let mode = get(a:000, 0,
                                    \ a:filename =~ '^>' ? 'a' : 'w')
                            
                              let filename = a:filename =~ '^>' ?
                                    \ a:filename[1:] : a:filename
                            
                              if filename ==# '/dev/null'
                                " Nothing.
                              elseif filename ==# '/dev/clip'
                                " Write to clipboard.
                            
                                if mode =~ 'a'
                                  let @+ .= a:string
                                else
                                  let @+ = a:string
                                endif
                              elseif filename ==# '/dev/quickfix'
                                " Write to quickfix.
                                let qflist = getqflist()
                            
                                for str in split(a:string, '\n\|\r\n')
                                  if str =~ '^.\+:.\+:.\+$'
                                    let line = split(str[2:], ':')
                                    let filename = str[:1] . line[0]
                            
                                    if len(line) >= 3 && line[1] =~ '^\d\+$'
                                      call add(qflist, {
                                            \ 'filename' : filename,
                                            \ 'lnum' : line[1],
                                            \ 'text' : join(line[2:], ':'),
                                            \ })
                                    else
                                      call add(qflist, {
                                            \ 'text' : str,
                                            \ })
                                    endif
                                  endif
                                endfor
                            
                                call setqflist(qflist)
                              else
                                " Write file.
                            
                                let mode = 'O_WRONLY | O_CREAT'
                                if mode =~ 'a'
                                  " Append mode.
                                  let mode .= '| O_APPEND'
                                endif
                            
                                let hfile = vimproc#fopen(filename, mode)
                                call hfile.write(a:string)
                                call hfile.close()
                              endif
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#readdir(dirname) "{{{
                              let dirname = substitute(substitute(
                                    \ vimproc#util#expand(a:dirname),
                                    \ '\\', '/', 'g'), '/$', '', '')
                              if dirname == ''
                                let dirname = getcwd()
                              endif
                            
                              if !isdirectory(dirname)
                                return []
                              endif
                            
                              let dirname = vimproc#util#iconv(dirname, &encoding,
                                    \ vimproc#util#termencoding())
                            
                              try
                                let files = s:libcall('vp_readdir', [dirname])
                              catch /vp_readdir/
                                return []
                              endtry
                            
                              call map(files, 'vimproc#util#iconv(
                                    \ v:val, vimproc#util#termencoding(), &encoding)')
                              if vimproc#util#is_windows()
                                call map(files, 'vimproc#util#substitute_path_separator(v:val)')
                              endif
                            
                              return files
                            endfunction"}}}
                            
    1              0.000008 function! vimproc#delete_trash(filename) "{{{
                              if !vimproc#util#is_windows()
                                call s:print_error('Not implemented in this platform.')
                                return
                              endif
                            
                              let filename = a:filename
                            
                              " Delete last /.
                              if filename =~ '[^:]/$'
                                " Delete last /.
                                let filename = filename[: -2]
                              endif
                            
                              " Substitute path separator to "/".
                              let filename = substitute(
                                    \ fnamemodify(filename, ':p'), '/', '\\', 'g')
                            
                              " Encoding conversion.
                              let filename = vimproc#util#iconv(filename,
                                    \ &encoding, vimproc#util#termencoding())
                            
                              let [ret] = s:libcall('vp_delete_trash', [filename])
                            
                              return str2nr(ret)
                            endfunction"}}}
                            
    1              0.000007 function! vimproc#test_readdir(dirname) "{{{
                              let start = reltime()
                              call split(glob(a:dirname.'/*'), '\n')
                              echomsg reltimestr(reltime(start))
                            
                              let start = reltime()
                              call vimproc#readdir(a:dirname)
                              echomsg reltimestr(reltime(start))
                            endfunction"}}}
                            
    1              0.000005 function! s:close_all(self) "{{{
                              if has_key(a:self, 'stdin')
                                call a:self.stdin.close()
                              endif
                              if has_key(a:self, 'stdout')
                                call a:self.stdout.close()
                              endif
                              if has_key(a:self, 'stderr')
                                call a:self.stderr.close()
                              endif
                            endfunction"}}}
    1              0.000005 function! s:close() dict "{{{
                              if self.is_valid
                                call self.f_close()
                              endif
                            
                              let self.is_valid = 0
                              let self.eof = 1
                              let self.__eof = 1
                            endfunction"}}}
    1              0.000005 function! s:read(...) dict "{{{
                              if self.__eof
                                let self.eof = 1
                                return ''
                              endif
                            
                              let number = get(a:000, 0, -1)
                              let timeout = get(a:000, 1, s:read_timeout)
                              let [hd, eof] = self.f_read(number, timeout)
                              let self.eof = eof
                              let self.__eof = eof
                            
                              return s:hd2str([hd])
                            endfunction"}}}
    1              0.000006 function! s:read_lines(...) dict "{{{
                              let res = self.buffer
                            
                              while !self.eof && stridx(res, "\n") < 0
                                let out = call(self.read, a:000, self)
                                if out  == ''
                                  break
                                endif
                            
                                let res .= out
                              endwhile
                            
                              let lines = split(res, '\r\?\n', 1)
                            
                              if self.eof
                                let self.buffer = ''
                                return lines
                              else
                                let self.buffer = empty(lines)? '' : lines[-1]
                                let lines = lines[ : -2]
                              endif
                            
                              let self.eof = (self.buffer != '') ? 0 : self.__eof
                              return lines
                            endfunction"}}}
    1              0.000005 function! s:read_line(...) dict "{{{
                              let lines = call(self.read_lines, a:000, self)
                              let self.buffer = join(lines[1:], "\n") . self.buffer
                              let self.eof = (self.buffer != '') ? 0 : self.__eof
                            
                              return get(lines, 0, '')
                            endfunction"}}}
                            
    1              0.000005 function! s:write(str, ...) dict "{{{
                              let timeout = get(a:000, 0, s:write_timeout)
                              let hd = s:str2hd(a:str)
                              return self.f_write(hd, timeout)
                            endfunction"}}}
                            
    1              0.000006 function! s:fdopen(fd, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'fd' : a:fd,
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000007 function! s:closed_fdopen(f_close, f_read, f_write) "{{{
                              return {
                                    \ 'fd' : -1,
                                    \ 'eof' : 1, '__eof' : 1, 'is_valid' : 0, 'buffer' : '',
                                    \ 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000008 function! s:fdopen_pty(fd_stdin, fd_stdout, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'fd_stdin' : a:fd_stdin, 'fd_stdout' : a:fd_stdout,
                                    \ 'f_close' : s:funcref(a:f_close), 'f_read' : s:funcref(a:f_read), 'f_write' : s:funcref(a:f_write), 
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref('read'), 'write' : s:funcref('write'),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000007 function! s:fdopen_pipes(fd, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'fd' : a:fd,
                                    \ 'f_close' : s:funcref(a:f_close),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
    1              0.000007 function! s:fdopen_pgroup(proc, fd, f_close, f_read, f_write) "{{{
                              return {
                                    \ 'eof' : 0, '__eof' : 0, 'is_valid' : 1, 'buffer' : '',
                                    \ 'proc' : a:proc, 'fd' : a:fd,
                                    \ 'f_close' : s:funcref(a:f_close),
                                    \ 'close' : s:funcref('close'), 'read' : s:funcref(a:f_read), 'write' : s:funcref(a:f_write),
                                    \ 'read_line' : s:funcref('read_line'), 'read_lines' : s:funcref('read_lines'),
                                    \}
                            endfunction"}}}
                            
    1              0.000006 function! s:garbage_collect() "{{{
                              for pid in values(s:bg_processes)
                                " Check processes.
                                try
                                  let [cond, status] = s:libcall('vp_waitpid', [pid])
                                  " echomsg string([pid, cond, status])
                                  if cond !=# 'run'
                                    if cond !=# 'exit'
                                      " Kill process.
                                      " 15 == SIGTERM
                                      call vimproc#kill(pid, 15)
                                    endif
                            
                                    if vimproc#util#is_windows()
                                      call s:libcall('vp_close_handle', [pid])
                                    endif
                                    call remove(s:bg_processes, pid)
                                  endif
                                catch
                                  " Ignore error.
                                endtry
                              endfor
                            endfunction"}}}
                            
                            "-----------------------------------------------------------
                            " UTILS
                            
    1              0.000012 function! s:str2hd(str)
                              return join(map(range(len(a:str)),
                                    \ 'printf("%02X", char2nr(a:str[v:val]))'), '')
                            endfunction
                            
    1              0.000006 function! s:hd2str(hd)
                              " a:hd is a list because to avoid copying the value.
                              return get(s:libcall('vp_decode', [a:hd[0]]), 0, '')
                            endfunction
                            
    1              0.000005 function! s:str2list(str)
                              return map(range(len(a:str)), 'char2nr(a:str[v:val])')
                            endfunction
                            
    1              0.000005 function! s:list2str(lis)
                              return s:hd2str(s:list2hd([a:lis]))
                            endfunction
                            
    1              0.000005 function! s:hd2list(hd)
                              return map(split(a:hd, '..\zs'), 'str2nr(v:val, 16)')
                            endfunction
                            
    1              0.000004 function! s:list2hd(lis)
                              return join(map(a:lis, 'printf("%02X", v:val)'), '')
                            endfunction
                            
    1              0.000006 function! s:convert_args(args) "{{{
                              if empty(a:args)
                                return []
                              endif
                            
                              if vimproc#util#is_windows() && !executable(a:args[0])
                                " Search from internal commands.
                                let internal_commands = [
                                      \ 'copy', 'dir', 'echo', 'erase', 'ftype',
                                      \ 'md', 'mkdir', 'move', 'path', 'rd', 'ren', 'rename',
                                      \ 'rmdir', 'start', 'time', 'type', 'ver', 'vol']
                                let index = index(internal_commands, a:args[0])
                                if index >= 0
                                  " Use cmd.exe
                                  return ['cmd', '/c', internal_commands[index]] + a:args[1:]
                                endif
                              endif
                            
                              let command_name = vimproc#get_command_name(a:args[0])
                            
                              return vimproc#analyze_shebang(command_name) + a:args[1:]
                            endfunction"}}}
                            
    1              0.000006 function! vimproc#analyze_shebang(filename) "{{{
                              if !filereadable(a:filename) ||
                                    \ getfsize(a:filename) > 100000 ||
                                    \ (vimproc#util#is_windows() &&
                                    \ '.'.fnamemodify(a:filename, ':e') !~?
                                    \   '^'.substitute($PATHEXT, ';', '$\\|^', 'g').'$')
                                  " Maybe a binary file.
                                return [a:filename]
                              endif
                            
                              let lines = readfile(a:filename, '', 1)
                              if empty(lines) || lines[0] !~ '^#!.\+'
                                " Shebang not found.
                                return [a:filename]
                              endif
                            
                              " Get shebang line.
                              let shebang = split(matchstr(lines[0], '^#!\zs.\+'))
                            
                              " Convert command name.
                              if vimproc#util#is_windows()
                                    \ && shebang[0] =~ '^/'
                                let shebang[0] = vimproc#get_command_name(
                                      \ fnamemodify(shebang[0], ':t'))
                              endif
                            
                              return shebang + [a:filename]
                            endfunction"}}}
                            
                            "-----------------------------------------------------------
                            " LOW LEVEL API
                            
    1              0.000008 augroup vimproc
    1              0.000125   autocmd!
    1              0.000017   autocmd VimLeave * call s:finalize()
    1              0.000011   autocmd CursorHold,BufWritePost * call s:garbage_collect()
    1              0.000002 augroup END
                            
                            " Initialize.
    1              0.000009 let s:lasterr = []
    1              0.000005 let s:read_timeout = 100
    1              0.000003 let s:write_timeout = 100
    1              0.000005 let s:bg_processes = {}
                            
    1              0.000005 function! s:split(str, sep)
                              let [result, pos] = [[], 0]
                              while 1
                                let tmp = stridx(a:str, a:sep, pos)
                                if tmp == -1
                                  call add(result, strpart(a:str, pos))
                                  break
                                endif
                                call add(result, strpart(a:str, pos, tmp - pos))
                                let pos = tmp + 1
                              endwhile
                            
                              return result
                            endfunction
                            
    1              0.000004 function! s:libcall(func, args) "{{{
                              " End Of Value
                              let EOV = "\xFF"
                              let args = empty(a:args) ? '' : (join(reverse(copy(a:args)), EOV) . EOV)
                              let stack_buf = libcall(g:vimproc#dll_path, a:func, args)
                              let result = s:split(stack_buf, EOV)
                              if !empty(result) && result[-1] != ''
                                if stack_buf[len(stack_buf) - 1] ==# EOV
                                  " Note: If &encoding equals "cp932" and output ends multibyte first byte,
                                  "       will fail split.
                                  return result
                                endif
                                let s:lasterr = result
                                let msg = vimproc#util#iconv(string(result),
                                      \ vimproc#util#termencoding(), &encoding)
                            
                                throw printf('vimproc: %s: %s', a:func, msg)
                              endif
                              return result[:-2]
                            endfunction"}}}
                            
    1              0.000008 function! s:SID_PREFIX()
                              return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
                            endfunction
                            
                            " Get funcref.
    1              0.000003 function! s:funcref(funcname)
                              return function(s:SID_PREFIX().a:funcname)
                            endfunction
                            
    1              0.000003 function! s:finalize()
                              call s:garbage_collect()
                            
                              if exists('s:dll_handle')
                                call s:vp_dlclose(s:dll_handle)
                              endif
                            endfunction
                            
    1              0.000004 function! s:vp_dlopen(path)
                              let [handle] = s:libcall('vp_dlopen', [a:path])
                              return handle
                            endfunction
                            
    1              0.000003 function! s:vp_dlclose(handle)
                              call s:libcall('vp_dlclose', [a:handle])
                            endfunction
                            
    1              0.000004 function! s:vp_file_open(path, flags, mode)
                              let [fd] = s:libcall('vp_file_open', [a:path, a:flags, a:mode])
                              return fd
                            endfunction
                            
    1              0.000003 function! s:vp_file_close() dict
                              if self.fd != 0
                                call s:libcall('vp_file_close', [self.fd])
                                let self.fd = 0
                              endif
                            endfunction
                            
    1              0.000004 function! s:vp_file_read(number, timeout) dict
                              let [hd, eof] = s:libcall('vp_file_read', [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000004 function! s:vp_file_write(hd, timeout) dict
                              let [nleft] = s:libcall('vp_file_write', [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000003 function! s:quote_arg(arg)
                              return a:arg =~ '[ "]' ? '"' . substitute(a:arg, '"', '\\"', 'g') . '"' : a:arg
                            endfunction
                            
    1              0.000005 function! s:vp_pipe_open(npipe, hstdin, hstdout, hstderr, argv) "{{{
                              if vimproc#util#is_windows()
                                let cmdline = s:quote_arg(substitute(a:argv[0], '/', '\', 'g'))
                                for arg in a:argv[1:]
                                  let cmdline .= ' ' . s:quote_arg(arg)
                                endfor
                                let [pid; fdlist] = s:libcall('vp_pipe_open',
                                      \ [a:npipe, a:hstdin, a:hstdout, a:hstderr, cmdline])
                              else
                                let [pid; fdlist] = s:libcall('vp_pipe_open',
                                      \ [a:npipe, a:hstdin, a:hstdout, a:hstderr, len(a:argv)] + a:argv)
                              endif
                            
                              if a:npipe != len(fdlist)
                                call s:print_error(printf('a:npipe = %d, a:argv = %s', a:npipe, string(a:argv)))
                                call s:print_error(printf('fdlist = %s', string(fdlist)))
                                echoerr 'Bug behavior is detected!: ' . pid
                              endif
                            
                              return [pid] + fdlist
                            endfunction"}}}
                            
    1              0.000004 function! s:vp_pipe_close() dict
                              " echomsg 'close:'.self.fd
                              if self.fd != 0
                                call s:libcall('vp_pipe_close', [self.fd])
                                let self.fd = 0
                              endif
                            endfunction
                            
    1              0.000005 function! s:vp_pipes_close() dict
                              for fd in self.fd
                                try
                                  call fd.close()
                                catch /vimproc: vp_pipe_close: /
                                  " Ignore error.
                                endtry
                              endfor
                            endfunction
                            
    1              0.000004 function! s:vp_pgroup_close() dict
                              call self.fd.close()
                            endfunction
                            
    1              0.000008 function! s:vp_pipe_read(number, timeout) dict
                              if self.fd == 0
                                return ['', 1]
                              endif
                            
                              let [hd, eof] = s:libcall('vp_pipe_read', [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000004 function! s:vp_pipe_write(hd, timeout) dict
                              if self.fd == 0
                                return 0
                              endif
                            
                              let [nleft] = s:libcall('vp_pipe_write', [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000004 function! s:read_pipes(...) dict "{{{
                              if type(self.fd[-1]) != type({})
                                let self.eof = 1
                                return ''
                              endif
                            
                              let number = get(a:000, 0, -1)
                              let timeout = get(a:000, 1, s:read_timeout)
                            
                              let output = self.fd[-1].read(number, timeout)
                              let self.eof = self.fd[-1].eof
                            
                              return output
                            endfunction"}}}
                            
    1              0.000004 function! s:write_pipes(str, ...) dict "{{{
                              let timeout = get(a:000, 0, s:write_timeout)
                            
                              if self.fd[0].eof
                                return 0
                              endif
                            
                              " Write data.
                              let nleft = self.fd[0].write(a:str, timeout)
                              let self.eof = self.fd[0].eof
                            
                              return nleft
                            endfunction"}}}
                            
    1              0.000003 function! s:read_pgroup(...) dict "{{{
                              let number = get(a:000, 0, -1)
                              let timeout = get(a:000, 1, s:read_timeout)
                            
                              let output = ''
                            
                              if !self.fd.eof
                                let output = self.fd.read(number, timeout)
                              endif
                            
                              if self.proc.current_proc.stdout.eof && self.proc.current_proc.stderr.eof
                                " Get status.
                                let [cond, status] = self.proc.current_proc.waitpid()
                            
                                if empty(self.proc.statements)
                                      \ || (self.proc.condition ==# 'true' && status)
                                      \ || (self.proc.condition ==# 'false' && !status)
                                  let self.proc.statements = []
                            
                                  " Caching status.
                                  let self.proc.cond = cond
                                  let self.proc.status = status
                                else
                                  " Initialize next statement.
                                  let proc = vimproc#plineopen3(self.proc.statements[0].statement)
                                  let self.proc.current_proc = proc
                            
                                  let self.pid = proc.pid
                                  let self.pid_list = proc.pid_list
                                  let self.proc.condition = self.proc.statements[0].condition
                                  let self.proc.statements = self.proc.statements[1:]
                            
                                  let self.proc.stdin = s:fdopen_pgroup(self.proc, proc.stdin, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                  let self.proc.stdout = s:fdopen_pgroup(self.proc, proc.stdout, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                  let self.proc.stderr = s:fdopen_pgroup(self.proc, proc.stderr, 'vp_pgroup_close', 'read_pgroup', 'write_pgroup')
                                endif
                              endif
                            
                              if self.proc.current_proc.stdout.eof
                                let self.proc.stdout.eof = 1
                                let self.proc.stdout.__eof = 1
                              endif
                            
                              if self.proc.current_proc.stderr.eof
                                let self.proc.stderr.eof = 1
                                let self.proc.stderr.__eof = 1
                              endif
                            
                              return output
                            endfunction"}}}
                            
    1              0.000005 function! s:write_pgroup(str, ...) dict "{{{
                              let timeout = get(a:000, 0, s:write_timeout)
                            
                              let nleft = 0
                              if !self.fd.eof
                                " Write data.
                                let nleft = self.fd.write(a:str, timeout)
                              endif
                            
                              return nleft
                            endfunction"}}}
                            
    1              0.000006 function! s:vp_pty_open(npipe, width, height, hstdin, hstdout, hstderr, argv)
                              let [pid; fdlist] = s:libcall('vp_pty_open',
                                    \ [a:npipe, a:width, a:height,
                                    \  a:hstdin, a:hstdout, a:hstderr, len(a:argv)] + a:argv)
                              return [pid] + fdlist
                            endfunction
                            
    1              0.000003 function! s:vp_pty_close() dict
                              call s:libcall('vp_pty_close', [self.fd])
                            endfunction
                            
    1              0.000004 function! s:vp_pty_read(number, timeout) dict
                              let [hd, eof] = s:libcall('vp_pty_read', [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000003 function! s:vp_pty_write(hd, timeout) dict
                              let [nleft] = s:libcall('vp_pty_write', [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000004 function! s:vp_get_winsize() dict
                              if self.is_pty && vimproc#util#is_windows()
                                return [winwidth(0)-5, winheight(0)]
                              endif
                            
                              for pid in self.pid_list
                                let [width, height] = s:libcall('vp_pty_get_winsize', [pid])
                              endfor
                            
                              return [width, height]
                            endfunction
                            
    1              0.000004 function! s:vp_set_winsize(width, height) dict
                              if vimproc#util#is_windows() || !self.is_valid
                                " Not implemented.
                                return
                              endif
                            
                              if self.is_pty
                                if self.stdin.eof == 0 && self.stdin.fd[-1].is_pty
                                  call s:libcall('vp_pty_set_winsize',
                                        \ [self.stdin.fd[-1].fd, a:width-5, a:height])
                                endif
                                if self.stdout.eof == 0 && self.stdout.fd[0].is_pty
                                  call s:libcall('vp_pty_set_winsize',
                                        \ [self.stdout.fd[0].fd, a:width-5, a:height])
                                endif
                                if self.stderr.eof == 0 && self.stderr.fd[0].is_pty
                                  call s:libcall('vp_pty_set_winsize',
                                        \ [self.stderr.fd[0].fd, a:width-5, a:height])
                                endif
                              endif
                            
                              " Send SIGWINCH = 28 signal.
                              for pid in self.pid_list
                                call vimproc#kill(pid, 28)
                              endfor
                            endfunction
                            
    1              0.000004 function! s:vp_kill(sig) dict
                              call s:close_all(self)
                            
                              let self.is_valid = 0
                            
                              if has_key(self, 'pid_list')
                                for pid in self.pid_list
                                  call vimproc#kill(pid, a:sig)
                                endfor
                              else
                                call vimproc#kill(self.pid, a:sig)
                              endif
                            endfunction
                            
    1              0.000004 function! s:vp_pgroup_kill(sig) dict
                              call s:close_all(self)
                              let self.is_valid = 0
                            
                              if self.pid == 0
                                " Ignore.
                                return
                              endif
                            
                              call self.current_proc.kill(a:sig)
                            endfunction
                            
    1              0.000004 function! s:waitpid(pid)
                              try
                                let [cond, status] = s:libcall('vp_waitpid', [a:pid])
                                " echomsg string([cond, status])
                                if cond ==# 'run'
                                  " Add process list.
                                  let s:bg_processes[a:pid] = a:pid
                            
                                  let [cond, status] = ['exit', '0']
                                elseif vimproc#util#is_windows()
                                  call s:libcall('vp_close_handle', [a:pid])
                                endif
                            
                                let s:last_status = status
                              catch
                                let [cond, status] = ['error', '0']
                              endtry
                            
                              return [cond, str2nr(status)]
                            endfunction
                            
    1              0.000003 function! s:vp_checkpid() dict
                              try
                                let [cond, status] = s:libcall('vp_waitpid', [self.pid])
                                if cond !=# 'run'
                                  let [self.cond, self.status] = [cond, status]
                                endif
                              catch /waitpid() error:\|vp_waitpid:/
                                let [cond, status] = ['error', '0']
                              endtry
                            
                              return [cond, str2nr(status)]
                            endfunction
                            
    1              0.000003 function! s:vp_waitpid() dict
                              call s:close_all(self)
                            
                              let self.is_valid = 0
                            
                              if has_key(self, 'cond') && has_key(self, 'status')
                                " Use cache.
                                let [cond, status] = [self.cond, self.status]
                              else
                                let [cond, status] = s:waitpid(self.pid)
                              endif
                            
                              if cond ==# 'exit'
                                let self.pid = 0
                              endif
                            
                              if has_key(self, 'pid_list')
                                for pid in self.pid_list[: -2]
                                  call s:waitpid(pid)
                                endfor
                              endif
                            
                              return [cond, str2nr(status)]
                            endfunction
                            
    1              0.000004 function! s:vp_pgroup_waitpid() dict
                              call s:close_all(self)
                            
                              let self.is_valid = 0
                            
                              if !has_key(self, 'cond') ||
                                    \ !has_key(self, 'status')
                                return s:waitpid(self.pid)
                              endif
                            
                              return [self.cond, self.status]
                            endfunction
                            
    1              0.000005 function! s:vp_socket_open(host, port)
                              let [socket] = s:libcall('vp_socket_open', [a:host, a:port])
                              return socket
                            endfunction
                            
    1              0.000003 function! s:vp_socket_close() dict
                              call s:libcall('vp_socket_close', [self.fd])
                              let self.is_valid = 0
                            endfunction
                            
    1              0.000004 function! s:vp_socket_read(number, timeout) dict
                              let [hd, eof] = s:libcall('vp_socket_read',
                                    \ [self.fd, a:number, a:timeout])
                              return [hd, eof]
                            endfunction
                            
    1              0.000004 function! s:vp_socket_write(hd, timeout) dict
                              let [nleft] = s:libcall('vp_socket_write',
                                    \ [self.fd, a:hd, a:timeout])
                              return nleft
                            endfunction
                            
    1              0.000004 function! s:vp_host_exists(host)
                              let [rval] = s:libcall('vp_host_exists', [a:host])
                              return rval
                            endfunction
                            
                            " Initialize.
    1              0.000011 if !exists('s:dll_handle')
    1   0.011657   0.000023   let s:dll_handle = s:vp_dlopen(g:vimproc#dll_path)
    1              0.000009   let s:last_status = 0
    1              0.000005   let s:last_errmsg = ''
    1              0.000003 endif
                            
                            " vimproc dll version check. "{{{
    1              0.000003 try
    1   0.000412   0.000021   let dll_version = vimproc#dll_version()
    1   0.000033   0.000017   if dll_version < vimproc#version()
                                call s:print_error(printf('Your vimproc binary version is "%d",'.
                                      \ ' but vimproc version is "%d".',
                                      \ dll_version, vimproc#version()))
                              endif
    1              0.000003 catch
                              call s:print_error(v:throwpoint)
                              call s:print_error(v:exception)
                              call s:print_error('Your vimproc binary is too old!')
                              call s:print_error('Please re-compile it.')
                            endtry
                            
    1              0.000005 unlet dll_version
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1              0.000023 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            " }}}
                            
                            " __END__
                            " vim:foldmethod=marker:fen:sw=2:sts=2

SCRIPT  /Users/anvaka/.vim/bundle/vimproc/autoload/vimproc/util.vim
Sourced 1 time
Total time:   0.000816
 Self time:   0.000733

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: util.vim
                            " Last Modified: 31 Jan 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
                            " Saving 'cpoptions' {{{
    1              0.000028 let s:save_cpo = &cpo
    1              0.000015 set cpo&vim
                            " }}}
                            
    1              0.000023 let s:is_windows = has('win16') || has('win32') || has('win64')
    1              0.000007 let s:is_cygwin = has('win32unix')
    1              0.000016 let s:is_mac = !s:is_windows
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
                            
                            " iconv() wrapper for safety.
    1              0.000011 function! vimproc#util#iconv(expr, from, to) "{{{
                              if !has('iconv')
                                    \ || a:expr == '' || a:from == ''
                                    \ || a:to == '' || a:from ==# a:to
                                return a:expr
                              endif
                            
                              let result = iconv(a:expr, a:from, a:to)
                              return result != '' ? result : a:expr
                            endfunction"}}}
    1              0.000006 function! vimproc#util#termencoding() "{{{
                              return 'char'
                            endfunction"}}}
    1              0.000006 function! vimproc#util#stdinencoding() "{{{
                              return exists('g:stdinencoding') && type(g:stdinencoding) == type("") ?
                                    \ g:stdinencoding : vimproc#util#termencoding()
                            endfunction"}}}
    1              0.000005 function! vimproc#util#stdoutencoding() "{{{
                              return exists('g:stdoutencoding') && type(g:stdoutencoding) == type("") ?
                                    \ g:stdoutencoding : vimproc#util#termencoding()
                            endfunction"}}}
    1              0.000005 function! vimproc#util#stderrencoding() "{{{
                              return exists('g:stderrencoding') && type(g:stderrencoding) == type("") ?
                                    \ g:stderrencoding : vimproc#util#termencoding()
                            endfunction"}}}
    1              0.000005 function! vimproc#util#expand(path) "{{{
                              return expand(escape(a:path,
                                    \ vimproc#util#is_windows() ? '*?"={}' : '*?"={}[]'), 1)
                            endfunction"}}}
    1              0.000005 function! vimproc#util#is_windows() "{{{
                              return s:is_windows
                            endfunction"}}}
    1              0.000004 function! vimproc#util#is_mac() "{{{
                              return s:is_mac
                            endfunction"}}}
    1              0.000004 function! vimproc#util#is_cygwin() "{{{
                              return s:is_cygwin
                            endfunction"}}}
    1              0.000006 function! vimproc#util#substitute_path_separator(path) "{{{
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction"}}}
                            
    1              0.000005 function! vimproc#util#uniq(list, ...) "{{{
                              let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(a:0 ? list[i][1] : list[i])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:0 ? map(list, 'v:val[0]') : list
                            endfunction"}}}
    1              0.000007 function! vimproc#util#set_default(var, val, ...)  "{{{
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let alternate_var = get(a:000, 0, '')
                            
                                let {a:var} = exists(alternate_var) ?
                                      \ {alternate_var} : a:val
                              endif
                            endfunction"}}}
                            
                            " Global options definition. "{{{
    1   0.000059   0.000024 call vimproc#util#set_default(
                                  \ 'g:stdinencoding', 'char')
    1   0.000039   0.000014 call vimproc#util#set_default(
                                  \ 'g:stdoutencoding', 'char')
    1   0.000035   0.000012 call vimproc#util#set_default(
                                  \ 'g:stderrencoding', 'char')
                            "}}}
                            
                            " Restore 'cpoptions' {{{
    1              0.000031 let &cpo = s:save_cpo
                            " }}}
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/member_complete.vim
Sourced 1 time
Total time:   0.001278
 Self time:   0.001278

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: member_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 01 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000025 let s:save_cpo = &cpo
    1              0.000015 set cpo&vim
                            
                            " Important variables.
    1              0.000012 if !exists('s:member_sources')
    1              0.000005   let s:member_sources = {}
    1              0.000002 endif
                            
    1              0.000019 let s:source = {
                                  \ 'name' : 'member_complete',
                                  \ 'kind' : 'manual',
                                  \ 'mark' : '[M]',
                                  \ 'rank' : 5,
                                  \ 'min_pattern_length' : 0,
                                  \}
                            
    1              0.000006 function! s:source.initialize() "{{{
                              augroup neocomplcache "{{{
                                " Caching events
                                autocmd CursorHold * call s:caching_current_buffer(line('.')-10, line('.')+10)
                                autocmd InsertEnter,InsertLeave *
                                      \ call neocomplcache#sources#member_complete#caching_current_line()
                              augroup END"}}}
                            
                              " Initialize member prefix patterns. "{{{
                              if !exists('g:neocomplcache_member_prefix_patterns')
                                let g:neocomplcache_member_prefix_patterns = {}
                              endif
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_member_prefix_patterns',
                                    \ 'c,cpp,objc,objcpp', '\.\|->')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_member_prefix_patterns',
                                    \ 'perl,php', '->')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_member_prefix_patterns',
                                    \ 'cs,java,javascript,d,vim,ruby,python,perl6,scala,vb', '\.')
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_member_prefix_patterns',
                                    \ 'lua', '\.\|:')
                              "}}}
                            
                              " Initialize member patterns. "{{{
                              if !exists('g:neocomplcache_member_patterns')
                                let g:neocomplcache_member_patterns = {}
                              endif
                              call neocomplcache#util#set_default_dictionary(
                                    \ 'g:neocomplcache_member_patterns',
                                    \'default', '\h\w*\%(()\|\[\h\w*\]\)\?')
                              "}}}
                            
                              " Initialize script variables. "{{{
                              let s:member_sources = {}
                              "}}}
                            endfunction
                            "}}}
                            
    1              0.000004 function! s:source.get_keyword_pos(cur_text) "{{{
                              " Check member prefix pattern.
                              let filetype = neocomplcache#get_context_filetype()
                              if !has_key(g:neocomplcache_member_prefix_patterns, filetype)
                                    \ || g:neocomplcache_member_prefix_patterns[filetype] == ''
                                return -1
                              endif
                            
                              let member = s:get_member_pattern(filetype)
                              let prefix = g:neocomplcache_member_prefix_patterns[filetype]
                              let complete_pos = matchend(a:cur_text,
                                    \ '\%(' . member . '\%(' . prefix . '\m\)\)\+\ze\w*$')
                              return complete_pos
                            endfunction"}}}
                            
    1              0.000004 function! s:source.get_complete_words(complete_pos, complete_str) "{{{
                              " Check member prefix pattern.
                              let filetype = neocomplcache#get_context_filetype()
                              if !has_key(g:neocomplcache_member_prefix_patterns, filetype)
                                    \ || g:neocomplcache_member_prefix_patterns[filetype] == ''
                                return []
                              endif
                            
                              let cur_text = neocomplcache#get_cur_text()
                              let var_name = matchstr(cur_text,
                                    \ '\%(' . s:get_member_pattern(filetype) . '\%(' .
                                    \ g:neocomplcache_member_prefix_patterns[filetype] . '\m\)\)\+\ze\w*$')
                              if var_name == ''
                                return []
                              endif
                            
                              return neocomplcache#keyword_filter(
                                    \ copy(s:get_member_list(cur_text, var_name)), a:complete_str)
                            endfunction"}}}
                            
    1              0.000013 function! neocomplcache#sources#member_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000007 function! neocomplcache#sources#member_complete#caching_current_line() "{{{
                              " Current line caching.
                              return s:caching_current_buffer(line('.')-1, line('.')+1)
                            endfunction"}}}
    1              0.000007 function! neocomplcache#sources#member_complete#caching_current_buffer() "{{{
                              " Current line caching.
                              return s:caching_current_buffer(1, line('$'))
                            endfunction"}}}
    1              0.000006 function! s:caching_current_buffer(start, end) "{{{
                              " Current line caching.
                            
                              if !has_key(s:member_sources, bufnr('%'))
                                call s:initialize_source(bufnr('%'))
                              endif
                            
                              let filetype = neocomplcache#get_context_filetype(1)
                              if !has_key(g:neocomplcache_member_prefix_patterns, filetype)
                                    \ || g:neocomplcache_member_prefix_patterns[filetype] == ''
                                return
                              endif
                            
                              let source = s:member_sources[bufnr('%')]
                              let keyword_pattern =
                                    \ '\%(' . s:get_member_pattern(filetype) . '\%('
                                    \ . g:neocomplcache_member_prefix_patterns[filetype]
                                    \ . '\m\)\)\+' . s:get_member_pattern(filetype)
                              let keyword_pattern2 = '^'.keyword_pattern
                              let member_pattern = s:get_member_pattern(filetype) . '$'
                            
                              " Cache member pattern.
                              let [line_num, max_lines] = [a:start, a:end]
                              for line in getline(a:start, a:end)
                                let match = match(line, keyword_pattern)
                            
                                while match >= 0 "{{{
                                  let match_str = matchstr(line, keyword_pattern2, match)
                            
                                  " Next match.
                                  let match = matchend(line, keyword_pattern, match + len(match_str))
                            
                                  while match_str != ''
                                    let member_name = matchstr(match_str, member_pattern)
                                    if member_name == ''
                                      break
                                    endif
                                    let var_name = match_str[ : -len(member_name)-1]
                            
                                    if !has_key(source.member_cache, var_name)
                                      let source.member_cache[var_name] = {}
                                    endif
                                    if !has_key(source.member_cache[var_name], member_name)
                                      let source.member_cache[var_name][member_name] = member_name
                                    endif
                            
                                    let match_str = matchstr(var_name, keyword_pattern2)
                                  endwhile
                                endwhile"}}}
                              endfor
                            endfunction"}}}
                            
    1              0.000005 function! s:get_member_list(cur_text, var_name) "{{{
                              let keyword_list = []
                              for [key, source] in filter(s:get_sources_list(),
                                    \ 'has_key(v:val[1].member_cache, a:var_name)')
                                let keyword_list +=
                                      \ values(source.member_cache[a:var_name])
                              endfor
                            
                              return keyword_list
                            endfunction"}}}
                            
    1              0.000004 function! s:get_sources_list() "{{{
                              let sources_list = []
                            
                              let filetypes_dict = {}
                              for filetype in neocomplcache#get_source_filetypes(
                                    \ neocomplcache#get_context_filetype())
                                let filetypes_dict[filetype] = 1
                              endfor
                            
                              for [key, source] in items(s:member_sources)
                                if has_key(filetypes_dict, source.filetype)
                                      \ || has_key(filetypes_dict, '_')
                                      \ || bufnr('%') == key
                                      \ || (bufname('%') ==# '[Command Line]' && bufnr('#') == key)
                                  call add(sources_list, [key, source])
                                endif
                              endfor
                            
                              return sources_list
                            endfunction"}}}
                            
    1              0.000004 function! s:initialize_source(srcname) "{{{
                              let path = fnamemodify(bufname(a:srcname), ':p')
                              let filename = fnamemodify(path, ':t')
                              if filename == ''
                                let filename = '[No Name]'
                                let path .= '/[No Name]'
                              endif
                            
                              " Set cache line count.
                              let buflines = getbufline(a:srcname, 1, '$')
                              let end_line = len(buflines)
                            
                              let ft = getbufvar(a:srcname, '&filetype')
                              if ft == ''
                                let ft = 'nothing'
                              endif
                            
                              let s:member_sources[a:srcname] = {
                                    \ 'member_cache' : {}, 'filetype' : ft,
                                    \ 'keyword_pattern' : neocomplcache#get_keyword_pattern(ft),
                                    \}
                            endfunction"}}}
                            
    1              0.000005 function! s:get_member_pattern(filetype) "{{{
                              return has_key(g:neocomplcache_member_patterns, a:filetype) ?
                                    \ g:neocomplcache_member_patterns[a:filetype] :
                                    \ g:neocomplcache_member_patterns['default']
                            endfunction"}}}
                            
    1              0.000018 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/omni_complete.vim
Sourced 1 time
Total time:   0.035766
 Self time:   0.001090

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: omni_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 29 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000015 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000027 let s:source = {
                                  \ 'name' : 'omni_complete',
                                  \ 'kind' : 'manual',
                                  \ 'compare_func' : 'neocomplcache#compare_nothing',
                                  \ 'mark' : '[O]',
                                  \ 'rank' : 50,
                                  \}
                            
    1   0.034706   0.000030 let s:List = vital#of('neocomplcache').import('Data.List')
                            
    1              0.000003 function! s:source.initialize() "{{{
                              " Initialize omni completion pattern. "{{{
                              if !exists('g:neocomplcache_omni_patterns')
                                let g:neocomplcache_omni_patterns = {}
                              endif
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_omni_patterns',
                                    \'html,xhtml,xml,markdown',
                                    \'<[^>]*')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_omni_patterns',
                                    \'css,scss,sass',
                                    \'^\s\+\w\+\|\w\+[):;]\?\s\+\w*\|[@!]')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_omni_patterns',
                                    \'javascript',
                                    \'[^. \t]\.\%(\h\w*\)\?')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_omni_patterns',
                                    \'actionscript',
                                    \'[^. \t][.:]\h\w*')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'php',
                                    "\'[^. \t]->\h\w*\|\h\w*::')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_omni_patterns',
                                    \'java',
                                    \'\%(\h\w*\|)\)\.')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'perl',
                                    "\'\h\w*->\h\w*\|\h\w*::')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'c',
                                    "\'[^.[:digit:] *\t]\%(\.\|->\)'
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'cpp',
                                    "\'[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_omni_patterns',
                                    \'objc',
                                    \'[^.[:digit:] *\t]\%(\.\|->\)')
                              call neocomplcache#util#set_default_dictionary(
                                    \'g:neocomplcache_omni_patterns',
                                    \'objj',
                                    \'[\[ \.]\w\+$\|:\w*$')
                            
                              " External language interface check.
                              if has('ruby')
                                " call neocomplcache#util#set_default_dictionary(
                                      "\'g:neocomplcache_omni_patterns', 'ruby',
                                      "\'[^. *\t]\.\h\w*\|\h\w*::')
                              endif
                              if has('python/dyn') || has('python3/dyn')
                                    \ || has('python') || has('python3')
                                call neocomplcache#util#set_default_dictionary(
                                      \'g:neocomplcache_omni_patterns',
                                      \'python', '[^. \t]\.\w*')
                              endif
                              "}}}
                            endfunction"}}}
    1              0.000002 function! s:source.finalize() "{{{
                            endfunction"}}}
                            
    1              0.000025 function! s:source.get_keyword_pos(cur_text) "{{{
                              let syn_name = neocomplcache#helper#get_syn_name(1)
                              if syn_name ==# 'Comment' || syn_name ==# 'String'
                                " Skip omni_complete in string literal.
                                return -1
                              endif
                            
                              let filetype = neocomplcache#get_context_filetype()
                              let s:complete_results = s:set_complete_results_pos(
                                    \ s:get_omni_funcs(filetype), a:cur_text)
                            
                              return s:get_complete_pos(s:complete_results)
                            endfunction"}}}
                            
    1              0.000003 function! s:source.get_complete_words(complete_pos, complete_str) "{{{
                              return s:get_candidates(
                                    \ s:set_complete_results_words(s:complete_results),
                                    \ a:complete_pos, a:complete_str)
                            endfunction"}}}
                            
    1              0.000005 function! neocomplcache#sources#omni_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000003 function! s:get_omni_funcs(filetype) "{{{
                              let funcs = []
                              for ft in insert(split(a:filetype, '\.'), '_')
                                if has_key(g:neocomplcache_omni_functions, ft)
                                  let omnifuncs =
                                        \ (type(g:neocomplcache_omni_functions[ft]) == type([])) ?
                                        \ g:neocomplcache_omni_functions[ft] :
                                        \ [g:neocomplcache_omni_functions[ft]]
                                else
                                  let omnifuncs = [&l:omnifunc]
                                endif
                            
                                for omnifunc in omnifuncs
                                  if neocomplcache#check_invalid_omnifunc(omnifunc)
                                    " omnifunc is irregal.
                                    continue
                                  endif
                            
                                  if get(g:neocomplcache_omni_patterns, omnifunc, '') != ''
                                    let pattern = g:neocomplcache_omni_patterns[omnifunc]
                                  elseif get(g:neocomplcache_omni_patterns, ft, '') != ''
                                    let pattern = g:neocomplcache_omni_patterns[ft]
                                  else
                                    let pattern = ''
                                  endif
                            
                                  if pattern == ''
                                    continue
                                  endif
                            
                                  call add(funcs, [omnifunc, pattern])
                                endfor
                              endfor
                            
                              return s:List.uniq(funcs)
                            endfunction"}}}
    1              0.000003 function! s:get_omni_list(list) "{{{
                              let omni_list = []
                            
                              " Convert string list.
                              for val in deepcopy(a:list)
                                let dict = (type(val) == type('') ?
                                      \ { 'word' : val } : val)
                                let dict.menu = '[O]' . get(dict, 'menu', '')
                                call add(omni_list, dict)
                            
                                unlet val
                              endfor
                            
                              return omni_list
                            endfunction"}}}
                            
    1              0.000003 function! s:set_complete_results_pos(funcs, cur_text) "{{{
                              " Try omnifunc completion. "{{{
                              let complete_results = {}
                              for [omnifunc, pattern] in a:funcs
                                if neocomplcache#is_auto_complete()
                                      \ && a:cur_text !~ '\%(' . pattern . '\m\)$'
                                  continue
                                endif
                            
                                " Save pos.
                                let pos = getpos('.')
                            
                                try
                                  let complete_pos = call(omnifunc, [1, ''])
                                catch
                                  call neocomplcache#print_error(
                                        \ 'Error occured calling omnifunction: ' . omnifunc)
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  let complete_pos = -1
                                finally
                                  if getpos('.') != pos
                                    call setpos('.', pos)
                                  endif
                                endtry
                            
                                if complete_pos < 0
                                  continue
                                endif
                            
                                let complete_str = a:cur_text[complete_pos :]
                            
                                let complete_results[omnifunc] = {
                                      \ 'candidates' : [],
                                      \ 'complete_pos' : complete_pos,
                                      \ 'complete_str' : complete_str,
                                      \ 'omnifunc' : omnifunc,
                                      \}
                              endfor
                              "}}}
                            
                              return complete_results
                            endfunction"}}}
    1              0.000003 function! s:set_complete_results_words(complete_results) "{{{
                              " Try source completion.
                              for [omnifunc, result] in items(a:complete_results)
                                if neocomplcache#complete_check()
                                  return a:complete_results
                                endif
                            
                                let pos = getpos('.')
                            
                                " Note: For rubycomplete problem.
                                let complete_str =
                                      \ (omnifunc == 'rubycomplete#Complete') ?
                                      \ '' : result.complete_str
                            
                                try
                                  let list = call(omnifunc, [0, complete_str])
                                catch
                                  call neocomplcache#print_error(
                                        \ 'Error occured calling omnifunction: ' . omnifunc)
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  let list = []
                                finally
                                  if getpos('.') != pos
                                    call setpos('.', pos)
                                  endif
                                endtry
                            
                                if type(list) != type([])
                                  " Error.
                                  return a:complete_results
                                endif
                            
                                let list = s:get_omni_list(list)
                            
                                let result.candidates = list
                              endfor
                            
                              return a:complete_results
                            endfunction"}}}
    1              0.000024 function! s:get_complete_pos(complete_results) "{{{
                              if empty(a:complete_results)
                                return -1
                              endif
                            
                              let complete_pos = col('.')
                              for result in values(a:complete_results)
                                if complete_pos > result.complete_pos
                                  let complete_pos = result.complete_pos
                                endif
                              endfor
                            
                              return complete_pos
                            endfunction"}}}
    1              0.000003 function! s:get_candidates(complete_results, complete_pos, complete_str) "{{{
                              " Append prefix.
                              let candidates = []
                              let len_words = 0
                              for [source_name, result] in items(a:complete_results)
                                if result.complete_pos > a:complete_pos
                                  let prefix = a:complete_str[: result.complete_pos
                                        \                            - a:complete_pos - 1]
                            
                                  for keyword in result.candidates
                                    let keyword.word = prefix . keyword.word
                                  endfor
                                endif
                            
                                let candidates += result.candidates
                              endfor
                            
                              return candidates
                            endfunction"}}}
                            
    1              0.000010 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/syntax_complete.vim
Sourced 1 time
Total time:   0.001713
 Self time:   0.001713

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: syntax_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 28 Apr 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000031 let s:save_cpo = &cpo
    1              0.000019 set cpo&vim
                            
                            " Important variables.
    1              0.000015 if !exists('s:syntax_list')
    1              0.000007   let s:syntax_list = {}
    1              0.000003 endif
                            
    1              0.000022 let s:source = {
                                  \ 'name' : 'syntax_complete',
                                  \ 'kind' : 'keyword',
                                  \ 'mark' : '[S]',
                                  \ 'rank' : 4,
                                  \}
                            
    1              0.000007 function! s:source.initialize() "{{{
                              " Set caching event.
                              autocmd neocomplcache Syntax * call s:caching()
                            
                              " Create cache directory.
                              if !isdirectory(neocomplcache#get_temporary_directory() . '/syntax_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/syntax_cache')
                              endif
                            
                              " Initialize check.
                              call s:caching()
                            endfunction"}}}
                            
    1              0.000004 function! s:source.finalize() "{{{
                              delcommand NeoComplCacheCachingSyntax
                            endfunction"}}}
                            
    1              0.000005 function! s:source.get_keyword_list(complete_str) "{{{
                              if neocomplcache#within_comment()
                                return []
                              endif
                            
                              let list = []
                            
                              let filetype = neocomplcache#get_context_filetype()
                              if !has_key(s:syntax_list, filetype)
                                call s:caching()
                              endif
                            
                              for syntax in neocomplcache#get_sources_list(
                                    \ s:syntax_list, filetype)
                                let list += neocomplcache#dictionary_filter(syntax, a:complete_str)
                              endfor
                            
                              return list
                            endfunction"}}}
                            
    1              0.000013 function! neocomplcache#sources#syntax_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000005 function! s:caching() "{{{
                              if &filetype == '' || &filetype ==# 'vim'
                                return
                              endif
                            
                              for filetype in neocomplcache#get_source_filetypes(&filetype)
                                if !has_key(s:syntax_list, filetype)
                                  " Check old cache.
                                  let cache_name = neocomplcache#cache#encode_name('syntax_cache', &filetype)
                                  let syntax_files = split(
                                        \ globpath(&runtimepath, 'syntax/'.&filetype.'.vim'), '\n')
                                  if getftime(cache_name) < 0 || (!empty(syntax_files)
                                        \ && getftime(cache_name) <= getftime(syntax_files[0]))
                                    if filetype ==# &filetype
                                      " Caching from syn list.
                                      let s:syntax_list[filetype] = s:caching_from_syn(filetype)
                                    endif
                                  else
                                    let s:syntax_list[filetype] = neocomplcache#cache#index_load_from_cache(
                                          \      'syntax_cache', filetype, 1)
                                  endif
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000011 function! neocomplcache#sources#syntax_complete#recaching(filetype) "{{{
                              if a:filetype == ''
                                let filetype = &filetype
                              else
                                let filetype = a:filetype
                              endif
                            
                              " Caching.
                              let s:syntax_list[filetype] = s:caching_from_syn(filetype)
                            endfunction"}}}
                            
    1              0.000006 function! s:caching_from_syn(filetype) "{{{
                              call neocomplcache#print_caching(
                                    \ 'Caching syntax "' . a:filetype . '"... please wait.')
                            
                              " Get current syntax list.
                              redir => syntax_list
                              silent! syntax list
                              redir END
                            
                              if syntax_list =~ '^E\d\+' || syntax_list =~ '^No Syntax items'
                                return []
                              endif
                            
                              let group_name = ''
                              let keyword_pattern = neocomplcache#get_keyword_pattern(a:filetype)
                            
                              let dup_check = {}
                            
                              let filetype_pattern = substitute(a:filetype, '\W', '\\A', 'g') . '\u'
                            
                              let keyword_lists = {}
                              for line in split(syntax_list, '\n')
                                if line =~ '^\h\w\+'
                                  " Change syntax group name.
                                  let group_name = matchstr(line, '^\S\+')
                                  let line = substitute(line, '^\S\s*xxx', '', '')
                                endif
                            
                                if line =~ 'Syntax items' || line =~ '^\s*links to' ||
                                      \ line =~ '^\s*nextgroup=' ||
                                      \ group_name !~# filetype_pattern
                                  " Next line.
                                  continue
                                endif
                            
                                let line = substitute(line, 'contained\|skipwhite\|skipnl\|oneline', '', 'g')
                                let line = substitute(line, '^\s*nextgroup=.*\ze\s', '', '')
                            
                                if line =~ '^\s*match'
                                  let line = s:substitute_candidate(matchstr(line, '/\zs[^/]\+\ze/'))
                                elseif line =~ '^\s*start='
                                  let line =
                                        \s:substitute_candidate(matchstr(line, 'start=/\zs[^/]\+\ze/')) . ' ' .
                                        \s:substitute_candidate(matchstr(line, 'end=/zs[^/]\+\ze/'))
                                endif
                            
                                " Add keywords.
                                let match_num = 0
                                let completion_length = 2
                                let match_str = matchstr(line, keyword_pattern, match_num)
                                while match_str != ''
                                  " Ignore too short keyword.
                                  if len(match_str) >= g:neocomplcache_min_syntax_length
                                        \ && !has_key(dup_check, match_str)
                                        \&& match_str =~ '^[[:print:]]\+$'
                                    let key = tolower(match_str[: completion_length-1])
                                    if !has_key(keyword_lists, key)
                                      let keyword_lists[key] = []
                                    endif
                                    call add(keyword_lists[key], match_str)
                            
                                    let dup_check[match_str] = 1
                                  endif
                            
                                  let match_num += len(match_str)
                            
                                  let match_str = matchstr(line, keyword_pattern, match_num)
                                endwhile
                              endfor
                            
                              " Save syntax cache.
                              let unpack_lists = neocomplcache#unpack_dictionary(keyword_lists)
                              if !empty(unpack_lists)
                                call neocomplcache#cache#save_cache('syntax_cache', &filetype, unpack_lists)
                              endif
                            
                              call neocomplcache#print_caching('')
                            
                              return keyword_lists
                            endfunction"}}}
                            
    1              0.000014 function! s:substitute_candidate(candidate) "{{{
                              let candidate = a:candidate
                            
                              " Collection.
                              let candidate = substitute(candidate,
                                    \'\\\@<!\[[^\]]*\]', ' ', 'g')
                            
                              " Delete.
                              let candidate = substitute(candidate,
                                    \'\\\@<!\%(\\[=?+]\|\\%[\|\\s\*\)', '', 'g')
                              " Space.
                              let candidate = substitute(candidate,
                                    \'\\\@<!\%(\\[<>{}]\|[$^]\|\\z\?\a\)', ' ', 'g')
                            
                              if candidate =~ '\\%\?('
                                let candidate = join(s:split_pattern(candidate))
                              endif
                            
                              " \
                              let candidate = substitute(candidate, '\\\\', '\\', 'g')
                              " *
                              let candidate = substitute(candidate, '\\\*', '*', 'g')
                              return candidate
                            endfunction"}}}
                            
    1              0.000006 function! s:split_pattern(keyword_pattern) "{{{
                              let original_pattern = a:keyword_pattern
                              let result_patterns = []
                              let analyzing_patterns = [ '' ]
                            
                              let i = 0
                              let max = len(original_pattern)
                              while i < max
                                if match(original_pattern, '^\\%\?(', i) >= 0
                                  " Grouping.
                                  let end = s:match_pair(original_pattern, '\\%\?(', '\\)', i)
                                  if end < 0
                                    "call neocomplcache#print_error('Unmatched (.')
                                    return [ a:keyword_pattern ]
                                  endif
                            
                                  let save_pattern = analyzing_patterns
                                  let analyzing_patterns = []
                                  for keyword in split(original_pattern[matchend(original_pattern, '^\\%\?(', i) : end], '\\|')
                                    for prefix in save_pattern
                                      call add(analyzing_patterns, prefix . keyword)
                                    endfor
                                  endfor
                            
                                  let i = end + 1
                                elseif match(original_pattern, '^\\|', i) >= 0
                                  " Select.
                                  let result_patterns += analyzing_patterns
                                  let analyzing_patterns = [ '' ]
                                  let original_pattern = original_pattern[i+2 :]
                                  let max = len(original_pattern)
                            
                                  let i = 0
                                elseif original_pattern[i] == '\' && i+1 < max
                                  let save_pattern = analyzing_patterns
                                  let analyzing_patterns = []
                                  for prefix in save_pattern
                                    call add(analyzing_patterns, prefix . original_pattern[i] . original_pattern[i+1])
                                  endfor
                            
                                  " Escape.
                                  let i += 2
                                else
                                  let save_pattern = analyzing_patterns
                                  let analyzing_patterns = []
                                  for prefix in save_pattern
                                    call add(analyzing_patterns, prefix . original_pattern[i])
                                  endfor
                            
                                  let i += 1
                                endif
                              endwhile
                            
                              let result_patterns += analyzing_patterns
                              return result_patterns
                            endfunction"}}}
                            
    1              0.000016 function! s:match_pair(string, start_pattern, end_pattern, start_cnt) "{{{
                              let end = -1
                              let start_pattern = '\%(' . a:start_pattern . '\)'
                              let end_pattern = '\%(' . a:end_pattern . '\)'
                            
                              let i = a:start_cnt
                              let max = len(a:string)
                              let nest_level = 0
                              while i < max
                                let start = match(a:string, start_pattern, i)
                                let end = match(a:string, end_pattern, i)
                            
                                if start >= 0 && (end < 0 || start < end)
                                  let i = matchend(a:string, start_pattern, i)
                                  let nest_level += 1
                                elseif end >= 0 && (start < 0 || end < start)
                                  let nest_level -= 1
                            
                                  if nest_level == 0
                                    return end
                                  endif
                            
                                  let i = matchend(a:string, end_pattern, i)
                                else
                                  break
                                endif
                              endwhile
                            
                              if nest_level != 0
                                return -1
                              else
                                return end
                              endif
                            endfunction"}}}
                            
                            " Global options definition. "{{{
    1              0.000015 if !exists('g:neocomplcache_min_syntax_length')
    1              0.000009   let g:neocomplcache_min_syntax_length = 4
    1              0.000003 endif
                            "}}}
                            
    1              0.000019 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/tags_complete.vim
Sourced 1 time
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: tags_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 24 Apr 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000015 let s:save_cpo = &cpo
    1              0.000012 set cpo&vim
                            
                            " Important variables.
    1              0.000008 if !exists('s:tags_list')
    1              0.000006   let s:tags_list = {}
    1              0.000004   let s:async_tags_list = {}
    1              0.000002 endif
                            
    1              0.000011 let s:source = {
                                  \ 'name' : 'tags_complete',
                                  \ 'kind' : 'keyword',
                                  \}
                            
    1              0.000004 function! s:source.initialize() "{{{
                              let g:neocomplcache_tags_caching_limit_file_size =
                                    \ get(g:, 'neocomplcache_tags_caching_limit_file_size', 500000)
                            
                              " Create cache directory.
                              if !isdirectory(neocomplcache#get_temporary_directory() . '/tags_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/tags_cache', 'p')
                              endif
                            endfunction"}}}
                            
    1              0.000002 function! s:source.finalize() "{{{
                              delcommand NeoComplCacheCachingTags
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#sources#tags_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000004 function! s:source.get_keyword_list(complete_str) "{{{
                              if !has_key(s:async_tags_list, bufnr('%'))
                                    \ && !has_key(s:tags_list, bufnr('%'))
                                call neocomplcache#sources#tags_complete#caching_tags(0)
                              endif
                            
                              if neocomplcache#within_comment()
                                return []
                              endif
                            
                              call neocomplcache#cache#check_cache(
                                    \ 'tags_cache', bufnr('%'), s:async_tags_list, s:tags_list)
                            
                              if !has_key(s:tags_list, bufnr('%'))
                                return []
                              endif
                              let keyword_list = neocomplcache#dictionary_filter(
                                    \ s:tags_list[bufnr('%')], a:complete_str)
                            
                              return neocomplcache#keyword_filter(keyword_list, a:complete_str)
                            endfunction"}}}
                            
    1              0.000005 function! s:initialize_tags(filename) "{{{
                              " Initialize tags list.
                              let ft = &filetype
                              if ft == ''
                                let ft = 'nothing'
                              endif
                            
                              return {
                                    \ 'filename' : a:filename,
                                    \ 'cachename' : neocomplcache#cache#async_load_from_tags(
                                    \              'tags_cache', a:filename, ft, 'T', 0)
                                    \ }
                            endfunction"}}}
    1              0.000009 function! neocomplcache#sources#tags_complete#caching_tags(force) "{{{
                              let bufnumber = bufnr('%')
                            
                              let s:async_tags_list[bufnumber] = []
                              for tags in map(filter(tagfiles(), 'getfsize(v:val) > 0'),
                                    \ "neocomplcache#util#substitute_path_separator(
                                    \    fnamemodify(v:val, ':p'))")
                                if tags !~? '/doc/tags\%(-\w\+\)\?$' &&
                                      \ (a:force || getfsize(tags)
                                      \         < g:neocomplcache_tags_caching_limit_file_size)
                                  call add(s:async_tags_list[bufnumber],
                                        \ s:initialize_tags(tags))
                                endif
                              endfor
                            endfunction"}}}
                            
    1              0.000011 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neocomplcache/autoload/neocomplcache/sources/vim_complete.vim
Sourced 1 time
Total time:   0.000764
 Self time:   0.000764

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: vim_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 24 Apr 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000015 let s:save_cpo = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000022 let s:source = {
                                  \ 'name' : 'vim_complete',
                                  \ 'kind' : 'manual',
                                  \ 'filetypes' : { 'vim' : 1, },
                                  \ 'mark' : '[vim]',
                                  \ 'rank' : 300,
                                  \}
                            
    1              0.000005 function! s:source.initialize() "{{{
                              " Initialize.
                            
                              " Initialize complete function list. "{{{
                              if !exists('g:neocomplcache_vim_completefuncs')
                                let g:neocomplcache_vim_completefuncs = {}
                              endif
                              "}}}
                            
                              " Call caching event.
                              autocmd neocomplcache FileType *
                                    \ call neocomplcache#sources#vim_complete#helper#on_filetype()
                            
                              " Initialize check.
                              call neocomplcache#sources#vim_complete#helper#on_filetype()
                            
                              " Add command.
                              command! -nargs=? -complete=buffer NeoComplCacheCachingVim
                                    \ call neocomplcache#sources#vim_complete#helper#recaching(<q-args>)
                            endfunction"}}}
                            
    1              0.000003 function! s:source.finalize() "{{{
                              delcommand NeoComplCacheCachingVim
                            
                              if neocomplcache#exists_echodoc()
                                call echodoc#unregister('vim_complete')
                              endif
                            endfunction"}}}
                            
    1              0.000004 function! s:source.get_keyword_pos(cur_text) "{{{
                              let cur_text = neocomplcache#sources#vim_complete#get_cur_text()
                            
                              if cur_text =~ '^\s*"'
                                " Comment.
                                return -1
                              endif
                            
                              let pattern = '\.\%(\h\w*\)\?$\|' .
                                    \ neocomplcache#get_keyword_pattern_end('vim')
                              if cur_text != '' && cur_text !~
                                    \ '^[[:digit:],[:space:][:tab:]$''<>]*\h\w*$'
                                let command_completion =
                                      \ neocomplcache#sources#vim_complete#helper#get_completion_name(
                                      \   neocomplcache#sources#vim_complete#get_command(cur_text))
                                if command_completion =~ '\%(dir\|file\|shellcmd\)'
                                  let pattern = neocomplcache#get_keyword_pattern_end('filename')
                                endif
                              endif
                            
                              let [complete_pos, complete_str] =
                                    \ neocomplcache#match_word(a:cur_text, pattern)
                              if complete_pos < 0
                                " Use args pattern.
                                let [complete_pos, complete_str] =
                                      \ neocomplcache#match_word(a:cur_text, '\S\+$')
                              endif
                            
                              if a:cur_text !~ '\.\%(\h\w*\)\?$' && neocomplcache#is_auto_complete()
                                    \ && bufname('%') !=# '[Command Line]'
                                    \ && neocomplcache#util#mb_strlen(complete_str)
                                    \      < g:neocomplcache_auto_completion_start_length
                                return -1
                              endif
                            
                              return complete_pos
                            endfunction"}}}
                            
    1              0.000004 function! s:source.get_complete_words(complete_pos, complete_str) "{{{
                              let cur_text = neocomplcache#sources#vim_complete#get_cur_text()
                              if neocomplcache#is_auto_complete() && cur_text !~ '\h\w*\.\%(\h\w*\)\?$'
                                    \ && len(a:complete_str) < g:neocomplcache_auto_completion_start_length
                                    \ && bufname('%') !=# '[Command Line]'
                                return []
                              endif
                            
                              if cur_text =~ '\h\w*\.\%(\h\w*\)\?$'
                                " Dictionary.
                                let complete_str = matchstr(cur_text, '.\%(\h\w*\)\?$')
                                let list = neocomplcache#sources#vim_complete#helper#var_dictionary(
                                      \ cur_text, complete_str)
                                return neocomplcache#keyword_filter(list, complete_str)
                              elseif a:complete_str =~# '^&\%([gl]:\)\?'
                                " Options.
                                let prefix = matchstr(a:complete_str, '&\%([gl]:\)\?')
                                let list = deepcopy(
                                      \ neocomplcache#sources#vim_complete#helper#option(
                                      \   cur_text, a:complete_str))
                                for keyword in list
                                  let keyword.word =
                                        \ prefix . keyword.word
                                  let keyword.abbr = prefix .
                                        \ get(keyword, 'abbr', keyword.word)
                                endfor
                              elseif a:complete_str =~? '^\c<sid>'
                                " SID functions.
                                let prefix = matchstr(a:complete_str, '^\c<sid>')
                                let complete_str = substitute(a:complete_str, '^\c<sid>', 's:', '')
                                let list = deepcopy(
                                      \ neocomplcache#sources#vim_complete#helper#function(
                                      \     cur_text, complete_str))
                                for keyword in list
                                  let keyword.word = prefix . keyword.word[2:]
                                  let keyword.abbr = prefix .
                                        \ get(keyword, 'abbr', keyword.word)[2:]
                                endfor
                              elseif cur_text =~# '\<has([''"]\w*$'
                                " Features.
                                let list = neocomplcache#sources#vim_complete#helper#feature(
                                      \ cur_text, a:complete_str)
                              elseif cur_text =~# '\<expand([''"][<>[:alnum:]]*$'
                                " Expand.
                                let list = neocomplcache#sources#vim_complete#helper#expand(
                                      \ cur_text, a:complete_str)
                              elseif a:complete_str =~ '^\$'
                                " Environment.
                                let list = neocomplcache#sources#vim_complete#helper#environment(
                                      \ cur_text, a:complete_str)
                              elseif cur_text =~ '^[[:digit:],[:space:][:tab:]$''<>]*!\s*\f\+$'
                                " Shell commands.
                                let list = neocomplcache#sources#vim_complete#helper#shellcmd(
                                      \ cur_text, a:complete_str)
                              else
                                " Commands.
                                let list = neocomplcache#sources#vim_complete#helper#command(
                                      \ cur_text, a:complete_str)
                              endif
                            
                              return neocomplcache#keyword_filter(copy(list), a:complete_str)
                            endfunction"}}}
                            
    1              0.000012 function! neocomplcache#sources#vim_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000008 function! neocomplcache#sources#vim_complete#get_cur_text() "{{{
                              let cur_text = neocomplcache#get_cur_text(1)
                              if &filetype == 'vimshell' && exists('*vimshell#get_secondary_prompt')
                                    \   && empty(b:vimshell.continuation)
                                return cur_text[len(vimshell#get_secondary_prompt()) :]
                              endif
                            
                              let line = line('.')
                              let cnt = 0
                              while cur_text =~ '^\s*\\' && line > 1 && cnt < 5
                                let cur_text = getline(line - 1) .
                                      \ substitute(cur_text, '^\s*\\', '', '')
                                let line -= 1
                                let cnt += 1
                              endwhile
                            
                              return split(cur_text, '\s\+|\s\+\|<bar>', 1)[-1]
                            endfunction"}}}
    1              0.000008 function! neocomplcache#sources#vim_complete#get_command(cur_text) "{{{
                              return matchstr(a:cur_text, '\<\%(\d\+\)\?\zs\h\w*\ze!\?\|'.
                                    \ '\<\%([[:digit:],[:space:]$''<>]\+\)\?\zs\h\w*\ze/.*')
                            endfunction"}}}
                            
    1              0.000015 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neosnippet/autoload/neocomplcache/sources/snippets_complete.vim
Sourced 1 time
Total time:   0.000870
 Self time:   0.000870

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: snippets_complete.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 28 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000034 let s:save_cpo = &cpo
    1              0.000021 set cpo&vim
                            
    1              0.000029 let s:source = {
                                  \ 'name' : 'snippets_complete',
                                  \ 'kind' : 'complfunc',
                                  \ 'min_pattern_length' :
                                  \     g:neocomplcache_auto_completion_start_length,
                                  \}
                            
    1              0.000008 function! s:source.initialize() "{{{
                              " Initialize.
                              call neocomplcache#set_dictionary_helper(
                                    \ g:neocomplcache_source_rank, 'snippets_complete', 8)
                              call neocomplcache#set_completion_length('snippets_complete',
                                    \ g:neocomplcache_auto_completion_start_length)
                              call neosnippet#util#set_default(
                                    \ 'g:neosnippet#enable_preview', 0)
                            endfunction"}}}
                            
    1              0.000006 function! s:source.get_keyword_pos(cur_text) "{{{
                              let cur_word = matchstr(a:cur_text, '\w\+$')
                              let word_candidates = neocomplcache#keyword_filter(
                                    \ filter(values(neosnippet#get_snippets()),
                                    \ 'v:val.options.word'), cur_word)
                              if !empty(word_candidates)
                                return match(a:cur_text, '\w\+$')
                              endif
                            
                              return match(a:cur_text, '\S\+$')
                            endfunction"}}}
                            
    1              0.000005 function! s:source.get_complete_words(cur_keyword_pos, cur_keyword_str) "{{{
                              let list = s:keyword_filter(neosnippet#get_snippets(), a:cur_keyword_str)
                            
                              for snippet in list
                                let snippet.dup = 1
                            
                                let snippet.menu = neosnippet#util#strwidthpart(
                                      \ snippet.menu_template, winwidth(0)/3)
                                if g:neosnippet#enable_preview
                                  let snippet.info = snippet.snip
                                endif
                              endfor
                            
                              return list
                            endfunction"}}}
                            
    1              0.000008 function! s:keyword_filter(snippets, cur_keyword_str) "{{{
                              " Uniq by real_name.
                              let dict = {}
                            
                              " Use default filter.
                              let list = neocomplcache#keyword_filter(
                                    \ values(a:snippets), a:cur_keyword_str)
                            
                              " Add cur_keyword_str snippet.
                              if has_key(a:snippets, a:cur_keyword_str)
                                call add(list, a:snippets[a:cur_keyword_str])
                              endif
                            
                              for snippet in neocomplcache#dup_filter(list)
                                if !has_key(dict, snippet.real_name) ||
                                      \ len(dict[snippet.real_name].word) > len(snippet.word)
                                  let dict[snippet.real_name] = snippet
                                endif
                              endfor
                            
                              return values(dict)
                            endfunction"}}}
                            
    1              0.000013 function! neocomplcache#sources#snippets_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000009 function! neocomplcache#sources#snippets_complete#expandable() "{{{
                              return neosnippet#expandable()
                            endfunction"}}}
    1              0.000016 function! neocomplcache#sources#snippets_complete#force_expandable() "{{{
                              return neosnippet#expandable()
                            endfunction"}}}
    1              0.000009 function! neocomplcache#sources#snippets_complete#jumpable() "{{{
                              return neosnippet#jumpable()
                            endfunction"}}}
                            
    1              0.000009 function! neocomplcache#sources#snippets_complete#get_snippets() "{{{
                              return neosnippet#get_snippets()
                            endfunction"}}}
    1              0.000356 function! neocomplcache#sources#snippets_complete#get_snippets_dir() "{{{
                              return neosnippet#get_snippets_directory()
                            endfunction"}}}
                            
    1              0.000021 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neosnippet/autoload/neosnippet/util.vim
Sourced 1 time
Total time:   0.062025
 Self time:   0.000644

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: util.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 02 Mar 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000034 let s:save_cpo = &cpo
    1              0.000020 set cpo&vim
                            
    1   0.061402   0.000021 let s:V = vital#of('neosnippet')
                            
    1              0.000006 function! neosnippet#util#substitute_path_separator(...) "{{{
                              return call(s:V.substitute_path_separator, a:000)
                            endfunction"}}}
    1              0.000002 function! neosnippet#util#system(...) "{{{
                              return call(s:V.system, a:000)
                            endfunction"}}}
    1              0.000003 function! neosnippet#util#has_vimproc(...) "{{{
                              return call(s:V.has_vimproc, a:000)
                            endfunction"}}}
    1              0.000002 function! neosnippet#util#is_windows(...) "{{{
                              return call(s:V.is_windows, a:000)
                            endfunction"}}}
    1              0.000002 function! neosnippet#util#is_mac(...) "{{{
                              return call(s:V.is_mac, a:000)
                            endfunction"}}}
    1              0.000003 function! neosnippet#util#get_last_status(...) "{{{
                              return call(s:V.get_last_status, a:000)
                            endfunction"}}}
    1              0.000003 function! neosnippet#util#escape_pattern(...) "{{{
                              return call(s:V.escape_pattern, a:000)
                            endfunction"}}}
    1              0.000002 function! neosnippet#util#iconv(...) "{{{
                              return call(s:V.iconv, a:000)
                            endfunction"}}}
    1              0.000002 function! neosnippet#util#truncate(...) "{{{
                              return call(s:V.truncate, a:000)
                            endfunction"}}}
    1              0.000002 function! neosnippet#util#strwidthpart(...) "{{{
                              return call(s:V.strwidthpart, a:000)
                            endfunction"}}}
                            
    1              0.000003 function! neosnippet#util#expand(path) "{{{
                              return neosnippet#util#substitute_path_separator(
                                    \ expand(escape(a:path, '*?[]"={}'), 1))
                            endfunction"}}}
    1              0.000003 function! neosnippet#util#set_default(var, val, ...)  "{{{
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let alternate_var = get(a:000, 0, '')
                            
                                let {a:var} = exists(alternate_var) ?
                                      \ {alternate_var} : a:val
                              endif
                            endfunction"}}}
    1              0.000003 function! neosnippet#util#set_dictionary_helper(...) "{{{
                              return call(s:V.set_dictionary_helper, a:000)
                            endfunction"}}}
                            
    1              0.000003 function! neosnippet#util#get_cur_text() "{{{
                              return
                                    \ (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?
                                    \      getline('.') :
                                    \      matchstr(getline('.'),
                                    \         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))
                            endfunction"}}}
    1              0.000003 function! neosnippet#util#print_error(string) "{{{
                              echohl Error | echomsg a:string | echohl None
                            endfunction"}}}
                            
    1              0.000003 function! neosnippet#util#parse_options(args, options_list) "{{{
                              let args = []
                              let options = {}
                              for arg in split(a:args, '\%(\\\@<!\s\)\+')
                                let arg = substitute(arg, '\\\( \)', '\1', 'g')
                            
                                let matched_list = filter(copy(a:options_list),
                                      \  'stridx(arg, v:val) == 0')
                                for option in matched_list
                                  let key = substitute(substitute(option, '-', '_', 'g'), '=$', '', '')[1:]
                                  let options[key] = (option =~ '=$') ?
                                        \ arg[len(option) :] : 1
                                  break
                                endfor
                            
                                if empty(matched_list)
                                  call add(args, arg)
                                endif
                              endfor
                            
                              return [args, options]
                            endfunction"}}}
                            
                            
    1              0.000049 let &cpo = s:save_cpo
    1              0.000017 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/neosnippet/autoload/vital/_08a462e.vim
Sourced 1 time
Total time:   0.000767
 Self time:   0.000767

count  total (s)   self (s)
                            let s:self_version = expand('<sfile>:t:r')
                            
    1              0.000006 let s:loaded = {}
                            
    1              0.000010 function! s:import(name, ...)
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = s:_import(a:name, s:_scripts())
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
                            
    1              0.000004 function! s:load(...) dict
                              let scripts = s:_scripts()
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                while 1 <= len(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == type({})
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                            
                                if exists('dict')
                                  call extend(dict, s:_import(name, scripts))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
                            
    1              0.000004 function! s:unload()
                              let s:loaded = {}
                            endfunction
                            
    1              0.000004 function! s:_import(name, scripts)
                              if type(a:name) == type(0)
                                return s:_build_module(a:name)
                              endif
                              if a:name =~# '^[^A-Z]' || a:name =~# '\W[^A-Z]'
                                throw 'vital: module name must start with capital letter: ' . a:name
                              endif
                              let target = a:name ==# '' ? '' : '/' . substitute(a:name, '\W\+', '/', 'g')
                              let target = substitute(target, '\l\zs\ze\u', '_', 'g') " OrderedSet -> Ordered_Set
                              let target = substitute(target, '[/_]\zs\u', '\l\0', 'g') " Ordered_Set -> ordered_set
                              let tailpath = printf('autoload/vital/%s%s.vim', s:self_version, target)
                            
                              " Note: The extra argument to globpath() was added in Patch 7.2.051.
                              if v:version > 702 || v:version == 702 && has('patch51')
                                let paths = split(globpath(&runtimepath, tailpath, 1), "\n")
                              else
                                let paths = split(globpath(&runtimepath, tailpath), "\n")
                              endif
                              let path = s:_unify_path(get(paths, 0, ''))
                              let sid = get(a:scripts, path, 0)
                              if !sid
                                try
                                  execute 'source' fnameescape(path)
                                catch /^Vim\%((\a\+)\)\?:E484/
                                  throw 'vital: module not found: ' . a:name
                                catch /^Vim\%((\a\+)\)\?:E127/
                                  " Ignore.
                                endtry
                            
                                let sid = len(a:scripts) + 1  " We expect that the file newly read is +1.
                                let a:scripts[path] = sid
                              endif
                              return s:_build_module(sid)
                            endfunction
                            
    1              0.000004 function! s:_scripts()
                              let scripts = {}
                              for line in split(s:_redir('scriptnames'), "\n")
                                let list = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if !empty(list)
                                  let scripts[s:_unify_path(list[2])] = list[1] - 0
                                endif
                              endfor
                              return scripts
                            endfunction
                            
    1              0.000049 if filereadable(expand('<sfile>:r') . '.VIM')
    1              0.000010   function! s:_unify_path(path)
                                " Note: On windows, vim can't expand path names from 8.3 formats.
                                " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                                " vital load duplicated scripts. Below's :~ avoid this issue.
                                return tolower(fnamemodify(resolve(fnamemodify(
                                \              a:path, ':p:gs?[\\/]\+?/?')), ':~'))
                              endfunction
    1              0.000003 else
                              function! s:_unify_path(path)
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]\+?/?'))
                              endfunction
                            endif
                            
    1              0.000004 function! s:_build_module(sid)
                              if has_key(s:loaded, a:sid)
                                return copy(s:loaded[a:sid])
                              endif
                              let prefix = '<SNR>' . a:sid . '_'
                              let funcs = s:_redir('function')
                              let filter_pat = '^\s*function ' . prefix
                              let map_pat = prefix . '\zs\w\+'
                              let functions = map(filter(split(funcs, "\n"), 'v:val =~# filter_pat'),
                              \          'matchstr(v:val, map_pat)')
                            
                              let module = {}
                              for func in functions
                                let module[func] = function(prefix . func)
                              endfor
                              if has_key(module, '_vital_loaded')
                                let V = vital#{s:self_version}#new()
                                if has_key(module, '_vital_depends')
                                  call call(V.load, module._vital_depends(), V)
                                endif
                                try
                                  call module._vital_loaded(V)
                                catch
                                  " FIXME: Show an error message for debug.
                                endtry
                              endif
                              if !get(g:, 'vital_debug', 0)
                                call filter(module, 'v:key =~# "^\\a"')
                              endif
                              let s:loaded[a:sid] = module
                              return copy(module)
                            endfunction
                            
    1              0.000014 function! s:_redir(cmd)
                              let oldverbosefile = &verbosefile
                              set verbosefile=
                              redir => res
                                silent! execute a:cmd
                              redir END
                              let &verbosefile = oldverbosefile
                              return res
                            endfunction
                            
    1              0.000017 function! vital#{s:self_version}#new()
                              return s:_import('', s:_scripts()).load(['Prelude', ''])
                            endfunction

SCRIPT  /Users/anvaka/.vim/bundle/neosnippet/autoload/vital/_08a462e/prelude.vim
Sourced 1 time
Total time:   0.000940
 Self time:   0.000940

count  total (s)   self (s)
                            let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
                            " glob() wrapper which returns List
                            " and 'wildignore' does not affect
                            " this function's return value.
    1              0.000009 if v:version ># 703 ||
                            \  (v:version is 703 && has('patch465'))
                              function! s:glob(expr)
                                return glob(a:expr, 1, 1)
                              endfunction
                            else
    1              0.000003   function! s:glob(expr)
                                let R = glob(a:expr, 1)
                                return split(R, '\n')
                              endfunction
    1              0.000002 endif
                            " globpath() wrapper which returns List
                            " and 'suffixes' and 'wildignore' does not affect
                            " this function's return value.
    1              0.000002 function! s:globpath(path, expr)
                              let R = globpath(a:path, a:expr, 1)
                              return split(R, '\n')
                            endfunction
                            
                            " Wrapper functions for type().
    1              0.000038 let [
                            \   s:__TYPE_NUMBER,
                            \   s:__TYPE_STRING,
                            \   s:__TYPE_FUNCREF,
                            \   s:__TYPE_LIST,
                            \   s:__TYPE_DICT,
                            \   s:__TYPE_FLOAT
                            \] = [
                            \   type(3),
                            \   type(""),
                            \   type(function('tr')),
                            \   type([]),
                            \   type({}),
                            \   has('float') ? type(str2float('0')) : -1
                            \]
                            " __TYPE_FLOAT = -1 when -float
                            " This doesn't match to anything.
                            
                            " Number or Float
    1              0.000002 function! s:is_numeric(Value)
                              let _ = type(a:Value)
                              return _ ==# s:__TYPE_NUMBER
                              \   || _ ==# s:__TYPE_FLOAT
                            endfunction
                            " Number
    1              0.000001 function! s:is_integer(Value)
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
    1              0.000001 function! s:is_number(Value)
                              return type(a:Value) ==# s:__TYPE_NUMBER
                            endfunction
                            " Float
    1              0.000002 function! s:is_float(Value)
                              return type(a:Value) ==# s:__TYPE_FLOAT
                            endfunction
                            " String
    1              0.000002 function! s:is_string(Value)
                              return type(a:Value) ==# s:__TYPE_STRING
                            endfunction
                            " Funcref
    1              0.000002 function! s:is_funcref(Value)
                              return type(a:Value) ==# s:__TYPE_FUNCREF
                            endfunction
                            " List
    1              0.000001 function! s:is_list(Value)
                              return type(a:Value) ==# s:__TYPE_LIST
                            endfunction
                            " Dictionary
    1              0.000001 function! s:is_dict(Value)
                              return type(a:Value) ==# s:__TYPE_DICT
                            endfunction
                            
    1              0.000002 function! s:truncate_smart(str, max, footer_width, separator)
                              let width = s:wcswidth(a:str)
                              if width <= a:max
                                let ret = a:str
                              else
                                let header_width = a:max - s:wcswidth(a:separator) - a:footer_width
                                let ret = s:strwidthpart(a:str, header_width) . a:separator
                                      \ . s:strwidthpart_reverse(a:str, a:footer_width)
                              endif
                            
                              return s:truncate(ret, a:max)
                            endfunction
                            
    1              0.000002 function! s:truncate(str, width)
                              " Original function is from mattn.
                              " http://github.com/mattn/googlereader-vim/tree/master
                            
                              if a:str =~# '^[\x00-\x7f]*$'
                                return len(a:str) < a:width ?
                                      \ printf('%-'.a:width.'s', a:str) : strpart(a:str, 0, a:width)
                              endif
                            
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              if width > a:width
                                let ret = s:strwidthpart(ret, a:width)
                                let width = s:wcswidth(ret)
                              endif
                            
                              if width < a:width
                                let ret .= repeat(' ', a:width - width)
                              endif
                            
                              return ret
                            endfunction
                            
    1              0.000002 function! s:strchars(str)
                              return len(substitute(a:str, '.', 'x', 'g'))
                            endfunction
                            
    1              0.000002 function! s:strwidthpart(str, width)
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '.$')
                                let ret = ret[: -1 - len(char)]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
    1              0.000003 function! s:strwidthpart_reverse(str, width)
                              if a:width <= 0
                                return ''
                              endif
                              let ret = a:str
                              let width = s:wcswidth(a:str)
                              while width > a:width
                                let char = matchstr(ret, '^.')
                                let ret = ret[len(char) :]
                                let width -= s:wcswidth(char)
                              endwhile
                            
                              return ret
                            endfunction
                            
    1              0.000002 if v:version >= 703
                              " Use builtin function.
    1              0.000001   function! s:wcswidth(str)
                                return strwidth(a:str)
                              endfunction
    1              0.000000 else
                              function! s:wcswidth(str)
                                if a:str =~# '^[\x00-\x7f]*$'
                                  return strlen(a:str)
                                end
                            
                                let mx_first = '^\(.\)'
                                let str = a:str
                                let width = 0
                                while 1
                                  let ucs = char2nr(substitute(str, mx_first, '\1', ''))
                                  if ucs == 0
                                    break
                                  endif
                                  let width += s:_wcwidth(ucs)
                                  let str = substitute(str, mx_first, '', '')
                                endwhile
                                return width
                              endfunction
                            
                              " UTF-8 only.
                              function! s:_wcwidth(ucs)
                                let ucs = a:ucs
                                if (ucs >= 0x1100
                                      \  && (ucs <= 0x115f
                                      \  || ucs == 0x2329
                                      \  || ucs == 0x232a
                                      \  || (ucs >= 0x2e80 && ucs <= 0xa4cf
                                      \      && ucs != 0x303f)
                                      \  || (ucs >= 0xac00 && ucs <= 0xd7a3)
                                      \  || (ucs >= 0xf900 && ucs <= 0xfaff)
                                      \  || (ucs >= 0xfe30 && ucs <= 0xfe6f)
                                      \  || (ucs >= 0xff00 && ucs <= 0xff60)
                                      \  || (ucs >= 0xffe0 && ucs <= 0xffe6)
                                      \  || (ucs >= 0x20000 && ucs <= 0x2fffd)
                                      \  || (ucs >= 0x30000 && ucs <= 0x3fffd)
                                      \  ))
                                  return 2
                                endif
                                return 1
                              endfunction
                            endif
                            
    1              0.000012 let s:is_windows = has('win16') || has('win32') || has('win64')
    1              0.000005 let s:is_cygwin = has('win32unix')
    1              0.000008 let s:is_mac = !s:is_windows
                                  \ && (has('mac') || has('macunix') || has('gui_macvim') ||
                                  \   (!isdirectory('/proc') && executable('sw_vers')))
    1              0.000004 function! s:is_windows()
                              return s:is_windows
                            endfunction
    1              0.000002 function! s:is_cygwin()
                              return s:is_cygwin
                            endfunction
    1              0.000002 function! s:is_mac()
                              return s:is_mac
                            endfunction
                            
    1              0.000002 function! s:print_error(message)
                              echohl ErrorMsg
                              for m in split(a:message, "\n")
                                echomsg m
                              endfor
                              echohl None
                            endfunction
                            
    1              0.000002 function! s:smart_execute_command(action, word)
                              execute a:action . ' ' . (a:word == '' ? '' : '`=a:word`')
                            endfunction
                            
    1              0.000003 function! s:escape_file_searching(buffer_name)
                              return escape(a:buffer_name, '*[]?{}, ')
                            endfunction
    1              0.000002 function! s:escape_pattern(str)
                              return escape(a:str, '~"\.^$[]*')
                            endfunction
                            " iconv() wrapper for safety.
    1              0.000002 function! s:iconv(expr, from, to)
                              if a:from == '' || a:to == '' || a:from ==? a:to
                                return a:expr
                              endif
                              let result = iconv(a:expr, a:from, a:to)
                              return result != '' ? result : a:expr
                            endfunction
                            " Like builtin getchar() but returns string always.
    1              0.000002 function! s:getchar(...)
                              let c = call('getchar', a:000)
                              return type(c) == type(0) ? nr2char(c) : c
                            endfunction
                            " Like builtin getchar() but returns string always.
                            " and do inputsave()/inputrestore() before/after getchar().
    1              0.000002 function! s:getchar_safe(...)
                              let c = s:input_helper('getchar', a:000)
                              return type(c) == type("") ? c : nr2char(c)
                            endfunction
                            " Like builtin getchar() but
                            " do inputsave()/inputrestore() before/after input().
    1              0.000002 function! s:input_safe(...)
                                return s:input_helper('input', a:000)
                            endfunction
                            " Do inputsave()/inputrestore() before/after calling a:funcname.
    1              0.000004 function! s:input_helper(funcname, args)
                                let success = 0
                                if inputsave() !=# success
                                    throw 'inputsave() failed'
                                endif
                                try
                                    return call(a:funcname, a:args)
                                finally
                                    if inputrestore() !=# success
                                        throw 'inputrestore() failed'
                                    endif
                                endtry
                            endfunction
                            
    1              0.000002 function! s:set_default(var, val)
                              if !exists(a:var) || type({a:var}) != type(a:val)
                                let {a:var} = a:val
                              endif
                            endfunction
    1              0.000002 function! s:set_dictionary_helper(variable, keys, pattern)
                              for key in split(a:keys, '\s*,\s*')
                                if !has_key(a:variable, key)
                                  let a:variable[key] = a:pattern
                                endif
                              endfor
                            endfunction
    1              0.000003 function! s:substitute_path_separator(path)
                              return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path
                            endfunction
    1              0.000002 function! s:path2directory(path)
                              return s:substitute_path_separator(isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))
                            endfunction
    1              0.000005 function! s:path2project_directory(path, ...)
                              let is_allow_empty = get(a:000, 0, 0)
                              let search_directory = s:path2directory(a:path)
                              let directory = ''
                            
                              " Search VCS directory.
                              for d in ['.git', '.bzr', '.hg']
                                let d = finddir(d, s:escape_file_searching(search_directory) . ';')
                                if d != ''
                                  let directory = fnamemodify(d, ':p:h:h')
                                  break
                                endif
                              endfor
                            
                              " Search project file.
                              if directory == ''
                                for d in ['build.xml', 'prj.el', '.project', 'pom.xml',
                                      \ 'Makefile', 'configure', 'Rakefile', 'NAnt.build', 'tags', 'gtags']
                                  let d = findfile(d, s:escape_file_searching(search_directory) . ';')
                                  if d != ''
                                    let directory = fnamemodify(d, ':p:h')
                                    break
                                  endif
                                endfor
                              endif
                            
                              if directory == ''
                                " Search /src/ directory.
                                let base = s:substitute_path_separator(search_directory)
                                if base =~# '/src/'
                                  let directory = base[: strridx(base, '/src/') + 3]
                                endif
                              endif
                            
                              if directory == '' && !is_allow_empty
                                " Use original path.
                                let directory = search_directory
                              endif
                            
                              return s:substitute_path_separator(directory)
                            endfunction
                            " Check vimproc.
    1              0.000005 function! s:has_vimproc()
                              if !exists('s:exists_vimproc')
                                try
                                  call vimproc#version()
                                  let s:exists_vimproc = 1
                                catch
                                  let s:exists_vimproc = 0
                                endtry
                              endif
                              return s:exists_vimproc
                            endfunction
                            
    1              0.000003 function! s:system(str, ...)
                              let command = a:str
                              let input = a:0 >= 1 ? a:1 : ''
                              let command = s:iconv(command, &encoding, 'char')
                              let input = s:iconv(input, &encoding, 'char')
                            
                              if a:0 == 0
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command) : system(command)
                              elseif a:0 == 1
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command, input) : system(command, input)
                              else
                                " ignores 3rd argument unless you have vimproc.
                                let output = s:has_vimproc() ?
                                      \ vimproc#system(command, input, a:2) : system(command, input)
                              endif
                            
                              let output = s:iconv(output, 'char', &encoding)
                            
                              return output
                            endfunction
    1              0.000003 function! s:get_last_status()
                              return s:has_vimproc() ?
                                    \ vimproc#get_last_status() : v:shell_error
                            endfunction
                            
    1              0.000009 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:set et ts=2 sts=2 sw=2 tw=0:

SCRIPT  /Users/anvaka/.vim/bundle/vimshell/autoload/neocomplcache/sources/vimshell_complete.vim
Sourced 1 time
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: vimshell_complete.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu@gmail.com>
                            " Last Modified: 26 May 2013.
                            " License: MIT license  {{{
                            "     Permission is hereby granted, free of charge, to any person obtaining
                            "     a copy of this software and associated documentation files (the
                            "     "Software"), to deal in the Software without restriction, including
                            "     without limitation the rights to use, copy, modify, merge, publish,
                            "     distribute, sublicense, and/or sell copies of the Software, and to
                            "     permit persons to whom the Software is furnished to do so, subject to
                            "     the following conditions:
                            "
                            "     The above copyright notice and this permission notice shall be included
                            "     in all copies or substantial portions of the Software.
                            "
                            "     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                            "     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            "     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
                            "     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
                            "     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
                            "     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
                            "     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            " }}}
                            "=============================================================================
                            
    1              0.000020 let s:save_cpo = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000009 function! neocomplcache#sources#vimshell_complete#define() "{{{
                              return s:source
                            endfunction"}}}
                            
    1              0.000026 let s:source = {
                                  \ 'name' : 'vimshell_complete',
                                  \ 'kind' : 'ftplugin',
                                  \ 'min_pattern_length' :
                                  \      g:neocomplcache_auto_completion_start_length,
                                  \ 'filetypes' : { 'vimshell' : 1, },
                                  \ 'is_volatile' : 1,
                                  \ 'sorters' : [],
                                  \}
                            
    1              0.000004 function! s:source.get_keyword_pos(cur_text) "{{{
                              return vimshell#complete#get_keyword_position()
                            endfunction"}}}
                            
    1              0.000002 function! s:source.get_complete_words(cur_keyword_pos, cur_keyword_str) "{{{
                              return vimshell#complete#gather_candidates(a:cur_keyword_str)
                            endfunction"}}}
                            
    1              0.000007 let &cpo = s:save_cpo
    1              0.000003 unlet s:save_cpo
                            
                            " vim: foldmethod=marker

SCRIPT  /Users/anvaka/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim
Sourced 1 time
Total time:   0.000677
 Self time:   0.000414

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/utils.vim
                            " Description:   Utilities
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000020 fu! ctrlp#utils#lash()
                            	retu &ssl || !exists('+ssl') ? '/' : '\'
                            endf
                            
    1              0.000011 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000008 fu! ctrlp#utils#opts()
                            	let s:lash = ctrlp#utils#lash()
                            	let usrhome = $HOME . s:lash( $HOME )
                            	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
                            	let cadir = isdirectory(usrhome.'.ctrlp_cache')
                            		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
                            	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
                            	let s:cache_dir = cadir
                            endf
    1   0.000287   0.000024 cal ctrlp#utils#opts()
                            
    1              0.000009 let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
                            " Files and Directories {{{1
    1              0.000007 fu! ctrlp#utils#cachedir()
                            	retu s:cache_dir
                            endf
                            
    1              0.000016 fu! ctrlp#utils#cachefile(...)
                            	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
                            	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
                            	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
                            endf
                            
    1              0.000007 fu! ctrlp#utils#readfile(file)
                            	if filereadable(a:file)
                            		let data = readfile(a:file)
                            		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
                            		retu data
                            	en
                            	retu []
                            endf
                            
    1              0.000007 fu! ctrlp#utils#mkdir(dir)
                            	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
                            	retu a:dir
                            endf
                            
    1              0.000014 fu! ctrlp#utils#writecache(lines, ...)
                            	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
                            		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
                            	en
                            endf
                            
    1              0.000006 fu! ctrlp#utils#glob(...)
                            	let path = ctrlp#utils#fnesc(a:1, 'g')
                            	retu s:wig_cond ? glob(path, a:2) : glob(path)
                            endf
                            
    1              0.000006 fu! ctrlp#utils#globpath(...)
                            	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
                            endf
                            
    1              0.000007 fu! ctrlp#utils#fnesc(path, type, ...)
                            	if exists('*fnameescape')
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = fnameescape(a:path)
                            		en
                            	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
                            	retu a:0 ? escape(path, a:1) : path
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

FUNCTION  353()
Called 1 time
Total time:   0.000424
 Self time:   0.000072

count  total (s)   self (s)
                              " Initialize omni completion pattern. "{{{
    1              0.000003   if !exists('g:neocomplcache_omni_patterns')
    1              0.000002     let g:neocomplcache_omni_patterns = {}
    1              0.000001   endif
    1   0.000078   0.000006   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','html,xhtml,xml,markdown','<[^>]*')
    1   0.000060   0.000006   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','css,scss,sass','^\s\+\w\+\|\w\+[):;]\?\s\+\w*\|[@!]')
    1   0.000043   0.000005   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','javascript','[^. \t]\.\%(\h\w*\)\?')
    1   0.000042   0.000005   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','actionscript','[^. \t][.:]\h\w*')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'php',
                                    "\'[^. \t]->\h\w*\|\h\w*::')
    1   0.000047   0.000005   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','java','\%(\h\w*\|)\)\.')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'perl',
                                    "\'\h\w*->\h\w*\|\h\w*::')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'c',
                                    "\'[^.[:digit:] *\t]\%(\.\|->\)'
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'cpp',
                                    "\'[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::')
    1   0.000042   0.000006   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','objc','[^.[:digit:] *\t]\%(\.\|->\)')
    1   0.000040   0.000004   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','objj','[\[ \.]\w\+$\|:\w*$')
                            
                              " External language interface check.
    1              0.000003   if has('ruby')
                                " call neocomplcache#util#set_default_dictionary(
                                      "\'g:neocomplcache_omni_patterns', 'ruby',
                                      "\'[^. *\t]\.\h\w*\|\h\w*::')
    1              0.000001   endif
    1              0.000006   if has('python/dyn') || has('python3/dyn') || has('python') || has('python3')
    1   0.000042   0.000005     call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','python', '[^. \t]\.\w*')
    1              0.000001   endif
                              "}}}

FUNCTION  unite#sources#mru#save()
Called 1 time
Total time:   0.002049
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000004   let opts = {}
    1   0.000020   0.000013   if a:0 >= 1 && s:V.is_dict(a:1)
    1              0.000006     call extend(opts, a:1)
    1              0.000002   endif
                            
    3              0.000010   for m in values(s:MRUs)
    2   0.001994   0.000018     call m.save(opts)
    2              0.000003   endfor

FUNCTION  <SNR>70_savetofile()
Called 1 time
Total time:   0.001663
 Self time:   0.000016

count  total (s)   self (s)
    1   0.001662   0.000015 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  <SNR>64_init()
Called 6 times
Total time:   0.008622
 Self time:   0.002003

count  total (s)   self (s)
                            " Initialize variables:
                            
                            	" autoclose
    6   0.000446   0.000059 	call s:option_init("autoclose", 1)
                            
                            	" matchpairs
    6   0.000387   0.000075 	call s:option_init("matchpairs", string(&matchpairs)[1:-2])
    6   0.000595   0.000192 	call s:option_init("matchpairs_list", map(split(b:_l_delimitMate_matchpairs, ','), 'split(v:val, '':'')'))
    6   0.000415   0.000097 	call s:option_init("left_delims", map(copy(b:_l_delimitMate_matchpairs_list), 'v:val[0]'))
    6   0.000390   0.000086 	call s:option_init("right_delims", map(copy(b:_l_delimitMate_matchpairs_list), 'v:val[1]'))
                            
                            	" quotes
    6   0.000320   0.000040 	call s:option_init("quotes", "\" ' `")
    6   0.000421   0.000118 	call s:option_init("quotes_list", split(b:_l_delimitMate_quotes))
                            
                            	" nesting_quotes
    6   0.000331   0.000038 	call s:option_init("nesting_quotes", [])
                            
                            	" excluded_regions
    6   0.000335   0.000038 	call s:option_init("excluded_regions", "Comment")
    6   0.000433   0.000077 	call s:option_init("excluded_regions_list", split(b:_l_delimitMate_excluded_regions, ',\s*'))
    6              0.000036 	let enabled = len(b:_l_delimitMate_excluded_regions_list) > 0
    6   0.000409   0.000055 	call s:option_init("excluded_regions_enabled", enabled)
                            
                            	" excluded filetypes
    6   0.000343   0.000043 	call s:option_init("excluded_ft", "")
                            
                            	" expand_space
    6              0.000036 	if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                            		echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                            		echom "Read :help 'delimitMate_expand_space' for more details."
                            		unlet b:delimitMate_expand_space
                            		let b:delimitMate_expand_space = 1
                            	endif
    6              0.000036 	if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                            		echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                            		echom "Read :help 'delimitMate_expand_space' for more details."
                            		unlet g:delimitMate_expand_space
                            		let g:delimitMate_expand_space = 1
                            	endif
    6   0.000331   0.000042 	call s:option_init("expand_space", 0)
                            
                            	" expand_cr
    6              0.000034 	if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                            		echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                            		echom "Read :help 'delimitMate_expand_cr' for more details."
                            		unlet b:delimitMate_expand_cr
                            		let b:delimitMate_expand_cr = 1
                            	endif
    6              0.000036 	if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                            		echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                            		echom "Read :help 'delimitMate_expand_cr' for more details."
                            		unlet g:delimitMate_expand_cr
                            		let g:delimitMate_expand_cr = 1
                            	endif
    6              0.000083 	if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                            		echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
                            	endif
    6   0.000373   0.000048 	call s:option_init("expand_cr", 0)
                            
                            	" smart_matchpairs
    6   0.000372   0.000048 	call s:option_init("smart_matchpairs", '^\%(\w\|\!\|\|\$\|_\|["'']\s*\S\)')
                            
                            	" smart_quotes
    6   0.000336   0.000042 	call s:option_init("smart_quotes", 1)
                            
                            	" apostrophes
    6   0.000328   0.000039 	call s:option_init("apostrophes", "")
    6   0.000381   0.000076 	call s:option_init("apostrophes_list", split(b:_l_delimitMate_apostrophes, ":\s*"))
                            
                            	" tab2exit
    6   0.000328   0.000038 	call s:option_init("tab2exit", 1)
                            
                            	" balance_matchpairs
    6   0.000345   0.000038 	call s:option_init("balance_matchpairs", 0)
                            
                            	" eol marker
    6   0.000327   0.000038 	call s:option_init("eol_marker", "")
                            
    6              0.000018 	let b:_l_delimitMate_buffer = []
                            

FUNCTION  neocomplcache#util#uniq()
Called 1 time
Total time:   0.000084
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000083   0.000014   return call(s:List.uniq, a:000)

FUNCTION  <SNR>64_option_init()
Called 126 times
Total time:   0.006619
 Self time:   0.006619

count  total (s)   self (s)
  126              0.000738 	let b = exists("b:delimitMate_" . a:name)
  126              0.000601 	let g = exists("g:delimitMate_" . a:name)
  126              0.000300 	let prefix = "_l_delimitMate_"
                            
  126              0.000182 	if !b && !g
  120              0.000264 		let sufix = a:default
  120              0.000144 	elseif !b && g
    6              0.000035 		exec "let sufix = g:delimitMate_" . a:name
    6              0.000007 	else
                            		exec "let sufix = b:delimitMate_" . a:name
                            	endif
  126              0.000625 	if exists("b:" . prefix . a:name)
   42              0.000221 		exec "unlockvar! b:" . prefix . a:name
   42              0.000033 	endif
  126              0.001406 	exec "let b:" . prefix . a:name . " = " . string(sufix)
  126              0.000782 	exec "lockvar! b:" . prefix . a:name

FUNCTION  vimproc#util#iconv()
Called 1 time
Total time:   0.041768
 Self time:   0.041768

count  total (s)   self (s)
    1              0.000021   if !has('iconv') || a:expr == '' || a:from == '' || a:to == '' || a:from ==# a:to
                                return a:expr
                              endif
                            
    1              0.041714   let result = iconv(a:expr, a:from, a:to)
    1              0.000019   return result != '' ? result : a:expr

FUNCTION  neocomplcache#context_filetype#initialize()
Called 1 time
Total time:   0.000664
 Self time:   0.000139

count  total (s)   self (s)
                              " Initialize context filetype lists.
    1   0.000032   0.000010   call neocomplcache#util#set_default( 'g:neocomplcache_context_filetype_lists', {})
    1   0.000084   0.000016   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'c,cpp', [ {'filetype' : 'masm',  'start' : '_*asm_*\s\+\h\w*', 'end' : '$'}, {'filetype' : 'masm',  'start' : '_*asm_*\s*\%(\n\s*\)\?{', 'end' : '}'}, {'filetype' : 'gas',  'start' : '_*asm_*\s*\%(_*volatile_*\s*\)\?(', 'end' : ');'},])
    1   0.000057   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'd', [ {'filetype' : 'masm',  'start' : 'asm\s*\%(\n\s*\)\?{', 'end' : '}'},])
    1   0.000054   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'perl6', [ {'filetype' : 'pir', 'start' : 'Q:PIR\s*{', 'end' : '}'},])
    1   0.000064   0.000013   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'vimshell', [ {'filetype' : 'vim',  'start' : 'vexe \([''"]\)', 'end' : '\\\@<!\1'}, {'filetype' : 'vim', 'start' : ' :\w*', 'end' : '\n'}, {'filetype' : 'vim', 'start' : ' vexe\s\+', 'end' : '\n'},])
    1   0.000054   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'eruby', [ {'filetype' : 'ruby', 'start' : '<%[=#]\?', 'end' : '%>'},])
    1   0.000059   0.000014   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'vim', [ {'filetype' : 'python',  'start' : '^\s*py\%[thon\]3\? <<\s*\(\h\w*\)', 'end' : '^\1'}, {'filetype' : 'ruby',  'start' : '^\s*rub\%[y\] <<\s*\(\h\w*\)', 'end' : '^\1'}, {'filetype' : 'lua',  'start' : '^\s*lua <<\s*\(\h\w*\)', 'end' : '^\1'},])
    1   0.000071   0.000017   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'html,xhtml', [ {'filetype' : 'javascript', 'start' :'<script\%( [^>]*\)\? type="text/javascript"\%( [^>]*\)\?>',  'end' : '</script>'}, {'filetype' : 'coffee', 'start' :'<script\%( [^>]*\)\? type="text/coffeescript"\%( [^>]*\)\?>',  'end' : '</script>'}, {'filetype' : 'css', 'start' :'<style\%( [^>]*\)\? type="text/css"\%( [^>]*\)\?>',  'end' : '</style>'},])
    1   0.000056   0.000012   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'python', [ {'filetype' : 'vim',  'start' : 'vim.command\s*(\([''"]\)', 'end' : '\\\@<!\1\s*)'}, {'filetype' : 'vim',  'start' : 'vim.eval\s*(\([''"]\)', 'end' : '\\\@<!\1\s*)'},])
    1   0.000052   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'help', [ {'filetype' : 'vim', 'start' : '^>', 'end' : '^<'},])
    1   0.000067   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_context_filetype_lists', 'nyaos,int-nyaos', [ {'filetype' : 'lua',  'start' : '\<lua_e\s\+\(["'']\)', 'end' : '^\1'},])

FUNCTION  <SNR>12_default_register()
Called 2 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    2              0.000057   let clipboard_flags = split(&clipboard, ',')
    2              0.000028   if index(clipboard_flags, 'unnamedplus') >= 0
                                return "+"
                              elseif index(clipboard_flags, 'unnamed') >= 0
    2              0.000009     return "*"
                              else
                                return "\""
                              endif

FUNCTION  neocomplcache#init#_sources()
Called 1 time
Total time:   0.482394
 Self time:   0.101474

count  total (s)   self (s)
    1              0.000018   if !exists('s:loaded_source_files')
                                " Initialize.
    1              0.000005     let s:loaded_source_files = {}
    1              0.000004     let s:loaded_all_sources = 0
    1              0.000003     let s:runtimepath_save = ''
    1              0.000001   endif
                            
                              " Initialize sources table.
    1              0.000003   if s:loaded_all_sources && &runtimepath ==# s:runtimepath_save
                                return
                              endif
                            
    1   0.000048   0.000015   let runtimepath_save = neocomplcache#util#split_rtp(s:runtimepath_save)
    1   0.003511   0.000260   let runtimepath = neocomplcache#util#join_rtp( filter(neocomplcache#util#split_rtp(), 'index(runtimepath_save, v:val) < 0'))
    1   0.000025   0.000011   let sources = neocomplcache#variables#get_sources()
                            
    2              0.000015   for name in filter(copy(a:names), '!has_key(sources, v:val)')
                                " Search autoload.
   14              0.002162     for source_name in map(split(globpath(runtimepath, 'autoload/neocomplcache/sources/*.vim'), '\n'), "fnamemodify(v:val, ':t:r')")
   13              0.000080       if has_key(s:loaded_source_files, source_name)
                                    continue
                                  endif
                            
   13              0.000071       let s:loaded_source_files[source_name] = 1
                            
   13   0.149312   0.098379       let source = neocomplcache#sources#{source_name}#define()
   13              0.000070       if empty(source)
                                    " Ignore.
                                    continue
                                  endif
                            
   13   0.326822   0.000133       call neocomplcache#define_source(source)
   13              0.000029     endfor
                            
    1              0.000002     if name == '_'
    1              0.000002       let s:loaded_all_sources = 1
    1              0.000004       let s:runtimepath_save = &runtimepath
    1              0.000000     endif
    1              0.000001   endfor

FUNCTION  neocomplcache#get_context_filetype()
Called 2 times
Total time:   0.000085
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000071   0.000028   if !neocomplcache#is_enabled()
    2              0.000008     return &filetype
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              if a:0 != 0 || mode() !=# 'i' || neocomplcache.context_filetype == ''
                                call neocomplcache#context_filetype#set()
                              endif
                            
                              return neocomplcache.context_filetype

FUNCTION  60()
Called 1 time
Total time:   0.000153
 Self time:   0.000067

count  total (s)   self (s)
    1   0.000027   0.000007     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
    1   0.000018   0.000006     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
    1   0.000029   0.000011     let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
    1   0.000017   0.000005     if !nerdtree#runningWindows()
    1   0.000049   0.000025         let toReturn = escape(toReturn, nerdtree#escChars())
    1              0.000001     endif
    1              0.000002     return toReturn

FUNCTION  61()
Called 81 times
Total time:   0.004661
 Self time:   0.001704

count  total (s)   self (s)
   81   0.001552   0.000397     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
   81   0.001025   0.000307     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
   81   0.001665   0.000581     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  <SNR>17_DetectCoffee()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000014     if getline(1) =~ '^#!.*\<coffee\>'
                                    set filetype=coffee
                                endif

FUNCTION  <SNR>149_is_mac()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:is_mac

FUNCTION  neocomplcache#has_vimproc()
Called 1 time
Total time:   0.234652
 Self time:   0.000010

count  total (s)   self (s)
    1   0.234650   0.000008   return neocomplcache#util#has_vimproc()

FUNCTION  neocomplcache#init#_variables()
Called 1 time
Total time:   0.187414
 Self time:   0.002717

count  total (s)   self (s)
                              " Initialize keyword patterns. "{{{
    1   0.176542   0.001452   call neocomplcache#util#set_default( 'g:neocomplcache_keyword_patterns', {})
    1   0.000129   0.000035   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','_','\k\+')
    1   0.000109   0.000018   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_keyword_patterns','filename', neocomplcache#util#is_windows() ?'\%(\a\+:/\)\?\%([/[:alnum:]()$+_~.\x80-\xff-]\|[^[:print:]]\|\\.\)\+' :'\%([/\[\][:alnum:]()$+_~.-]\|[^[:print:]]\|\\.\)\+')
    1   0.000160   0.000011   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','lisp,scheme,clojure,int-gosh,int-clisp,int-clj','[[:alpha:]+*/@$_=.!?-][[:alnum:]+*/@$_:=.!?-]*')
    1   0.000096   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','ruby,int-irb','^=\%(b\%[egin]\|e\%[nd]\)\|\%(@@\|[:$@]\)\h\w*\|\h\w*\%(::\w*\)*[!?]\?')
    1   0.000097   0.000012   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','php,int-php','</\?\%(\h[[:alnum:]_-]*\s*\)\?\%(/\?>\)\?'.'\|\$\h\w*\|\h\w*\%(\%(\\\|::\)\w*\)*')
    1   0.000099   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','perl,int-perlsh','<\h\w*>\?\|[$@%&*]\h\w*\|\h\w*\%(::\w*\)*')
    1   0.000095   0.000011   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','perl6,int-perl6','<\h\w*>\?\|[$@%&][!.*?]\?\h[[:alnum:]_-]*'.'\|\h[[:alnum:]_-]*\%(::[[:alnum:]_-]*\)*')
    1   0.000077   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','pir','[$@%.=]\?\h\w*')
    1   0.000076   0.000008   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','pasm','[=]\?\h\w*')
    1   0.000131   0.000015   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','vim,help','-\h[[:alnum:]-]*=\?\|\c\[:\%(\h\w*:\]\)\?\|&\h[[:alnum:]_:]*\|'.'<SID>\%(\h\w*\)\?\|<Plug>([^)]*)\?'.'\|<\h[[:alnum:]_-]*>\?\|\h[[:alnum:]_:#]*!\?\|$\h\w*')
    1   0.000117   0.000018   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','tex','\\\a{\a\{1,2}}\|\\[[:alpha:]@][[:alnum:]@]*'.'\%({\%([[:alnum:]:_]\+\*\?}\?\)\?\)\?\|\a[[:alnum:]:_]*\*\?')
    1   0.000193   0.000014   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','sh,zsh,int-zsh,int-bash,int-sh','[[:alpha:]_.-][[:alnum:]_.-]*')
    1   0.000111   0.000016   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','vimshell','\$\$\?\w*\|[[:alpha:]_.\\/~-][[:alnum:]_.\\/~-]*\|\d\+\%(\.\d\+\)\+')
    1   0.000130   0.000015   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','ps1,int-powershell','\[\h\%([[:alnum:]_.]*\]::\)\?\|[$%@.]\?[[:alpha:]_.:-][[:alnum:]_.:-]*')
    1   0.000106   0.000012   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','c','^\s*#\s*\h\w*\|\h\w*')
    1   0.000105   0.000013   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','cpp','^\s*#\s*\h\w*\|\h\w*\%(::\w*\)*')
    1   0.000115   0.000013   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','objc','^\s*#\s*\h\w*\|\h\w*\|@\h\w*')
    1   0.000085   0.000016   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','objcpp','^\s*#\s*\h\w*\|\h\w*\%(::\w*\)*\|@\h\w*')
    1   0.000076   0.000008   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','objj','\h\w*\|@\h\w*')
    1   0.000075   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','d','\h\w*')
    1   0.000113   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','python,int-python,int-ipython','[@]\?\h\w*')
    1   0.000077   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','cs','\h\w*')
    1   0.000076   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','java','[@]\?\h\w*')
    1   0.000148   0.000011   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','javascript,actionscript,int-js,int-kjs,int-rhino','\h\w*')
    1   0.000095   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','coffee,int-coffee','[@]\?\h\w*')
    1   0.000078   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','awk','\h\w*')
    1   0.000103   0.000012   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','haskell,int-ghci','\%(\u\w*\.\)\+[[:alnum:]_'']*\|[[:alpha:]_''][[:alnum:]_'']*')
    1   0.000141   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','ml,ocaml,int-ocaml,int-sml,int-smlsharp','[''`#.]\?\h[[:alnum:]_'']*')
    1   0.000093   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','erlang,int-erl','^\s*-\h\w*\|\%(\h\w*:\)*\h\w\|\h[[:alnum:]_@]*')
    1   0.000140   0.000014   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','html,xhtml,xml,markdown,eruby','</\?\%([[:alnum:]_:-]\+\s*\)\?\%(/\?>\)\?\|&\h\%(\w*;\)\?'.'\|\h[[:alnum:]_-]*="\%([^"]*"\?\)\?\|\h[[:alnum:]_:-]*')
    1   0.000124   0.000011   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','css,stylus,scss,less','[@#.]\?[[:alpha:]_:-][[:alnum:]_:-]*')
    1   0.000077   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','tags','^[^!][^/[:blank:]]*')
    1   0.000076   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','pic','^\s*#\h\w*\|\h\w*')
    1   0.000075   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','arm','\h\w*')
    1   0.000076   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','asmh8300','[[:alpha:]_.][[:alnum:]_.]*')
    1   0.000076   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','masm','\.\h\w*\|[[:alpha:]_@?$][[:alnum:]_@?$]*\|\h\w*:\h\w*')
    1   0.000078   0.000011   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','nasm','^\s*\[\h\w*\|[%.]\?\h\w*\|\%(\.\.@\?\|%[%$!]\)\%(\h\w*\)\?\|\h\w*:\h\w*')
    1   0.000075   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','asm','[%$.]\?\h\w*\%(\$\h\w*\)\?')
    1   0.000081   0.000008   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','gas','[$.]\?\h\w*')
    1   0.000089   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','gdb,int-gdb','$\h\w*\|[[:alnum:]:._-]\+')
    1   0.000075   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','make','[[:alpha:]_.-][[:alnum:]_.-]*')
    1   0.000090   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','scala,int-scala','\h\w*')
    1   0.000083   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','int-termtter','\h[[:alnum:]_/-]*\|\$\a\+\|#\h\w*')
    1   0.000076   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','int-earthquake','[:#$]\h\w*\|\h[[:alnum:]_/-]*')
    1   0.000091   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','dosbatch,int-cmdproxy','\$\w+\|[[:alpha:]_./-][[:alnum:]_.-]*')
    1   0.000074   0.000008   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','vb','\h\w*\|#\h\w*')
    1   0.000074   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','lua','\h\w*')
    1   0.000080   0.000008   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns', 'zimbu','\h\w*')
    1   0.000076   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','konoha','[*$@%]\h\w*\|\h\w*')
    1   0.000075   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','cobol','\a[[:alnum:]-]*')
    1   0.000075   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','coq','\h[[:alnum:]_'']*')
    1   0.000073   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','tcl','[.-]\h\w*\|\h\w*')
    1   0.000089   0.000008   call neocomplcache#util#set_default_dictionary('g:neocomplcache_keyword_patterns','nyaos,int-nyaos','\h\w*')
                              "}}}
                            
                              " Initialize next keyword patterns. "{{{
    1   0.000037   0.000010   call neocomplcache#util#set_default( 'g:neocomplcache_next_keyword_patterns', {})
    1   0.000083   0.000013   call neocomplcache#util#set_default_dictionary('g:neocomplcache_next_keyword_patterns', 'perl','\h\w*>')
    1   0.000075   0.000009   call neocomplcache#util#set_default_dictionary('g:neocomplcache_next_keyword_patterns', 'perl6','\h\w*>')
    1   0.000091   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_next_keyword_patterns', 'vim,help','\w*()\?\|\w*:\]\|[[:alnum:]_-]*[)>=]')
    1   0.000076   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_next_keyword_patterns', 'python','\w*()\?')
    1   0.000076   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_next_keyword_patterns', 'tex','[[:alnum:]:_]\+[*[{}]')
    1   0.000122   0.000010   call neocomplcache#util#set_default_dictionary('g:neocomplcache_next_keyword_patterns', 'html,xhtml,xml,mkd','[[:alnum:]_:-]*>\|[^"]*"')
                              "}}}
                            
                              " Initialize same file type lists. "{{{
    1   0.000035   0.000009   call neocomplcache#util#set_default( 'g:neocomplcache_same_filetype_lists', {})
    1   0.000076   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'c', 'cpp')
    1   0.000081   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'cpp', 'c')
    1   0.000074   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'erb', 'ruby,html,xhtml')
    1   0.000070   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'html,xml', 'xhtml')
    1   0.000075   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'html,xhtml', 'css,stylus,less')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'css', 'scss')
    1   0.000058   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'scss', 'css')
    1   0.000058   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'stylus', 'css')
    1   0.000058   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'less', 'css')
    1   0.000056   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'xhtml', 'html,xml')
    1   0.000058   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'help', 'vim')
    1   0.000058   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'tex', 'bib,plaintex')
    1   0.000064   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'plaintex', 'bib,tex')
    1   0.000060   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'lingr-say', 'lingr-messages,lingr-members')
                            
                              " Interactive filetypes.
    1   0.000059   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-irb', 'ruby')
    1   0.000071   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-ghci,int-hugs', 'haskell')
    1   0.000076   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-python,int-ipython', 'python')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-gosh', 'scheme')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-clisp', 'lisp')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-erl', 'erlang')
    1   0.000058   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-zsh', 'zsh')
    1   0.000057   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-bash', 'bash')
    1   0.000058   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-sh', 'sh')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-cmdproxy', 'dosbatch')
    1   0.000064   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-powershell', 'powershell')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-perlsh', 'perl')
    1   0.000058   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-perl6', 'perl6')
    1   0.000058   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-ocaml', 'ocaml')
    1   0.000058   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-clj', 'clojure')
    1   0.000075   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-sml,int-smlsharp', 'sml')
    1   0.000082   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-js,int-kjs,int-rhino', 'javascript')
    1   0.000060   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-coffee', 'coffee')
    1   0.000064   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-gdb', 'gdb')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-scala', 'scala')
    1   0.000058   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-nyaos', 'nyaos')
    1   0.000059   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_same_filetype_lists', 'int-php', 'php')
                              "}}}
                            
                              " Initialize delimiter patterns. "{{{
    1   0.000027   0.000006   call neocomplcache#util#set_default( 'g:neocomplcache_delimiter_patterns', {})
    1   0.000070   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'vim,help', ['#'])
    1   0.000086   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'erlang,lisp,int-clisp', [':'])
    1   0.000068   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'lisp,int-clisp', ['/', ':'])
    1   0.000070   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'clojure,int-clj', ['/', '\.'])
    1   0.000075   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'perl,cpp', ['::'])
    1   0.000060   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'php', ['\', '::'])
    1   0.000338   0.000011   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'java,d,javascript,actionscript,'. 'ruby,eruby,haskell,int-ghci,coffee,zimbu,konoha', ['\.'])
    1   0.000097   0.000017   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'lua', ['\.', ':'])
    1   0.000066   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_delimiter_patterns', 'perl6', ['\.', '::'])
                              "}}}
                            
                              " Initialize ctags arguments. "{{{
    1   0.000030   0.000008   call neocomplcache#util#set_default( 'g:neocomplcache_ctags_arguments_list', {})
    1   0.000064   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_ctags_arguments_list', '_', '')
    1   0.000066   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_ctags_arguments_list', 'vim', '--extra=fq --fields=afmiKlnsStz ' . "--regex-vim='/function!? ([a-z#:_0-9A-Z]+)/\\1/function/'")
    1   0.000019   0.000007   if neocomplcache#util#is_mac()
    1   0.000080   0.000022     call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_ctags_arguments_list', 'c', '--c-kinds=+p --fields=+iaS --extra=+q -I__DARWIN_ALIAS,__DARWIN_ALIAS_C,__DARWIN_ALIAS_I,__DARWIN_INODE64 -I__DARWIN_1050,__DARWIN_1050ALIAS,__DARWIN_1050ALIAS_C,__DARWIN_1050ALIAS_I,__DARWIN_1050INODE64 -I__DARWIN_EXTSN,__DARWIN_EXTSN_C -I__DARWIN_LDBL_COMPAT,__DARWIN_LDBL_COMPAT2')
    1              0.000002   else
                                call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_ctags_arguments_list', 'c', '-R --sort=1 --c-kinds=+p --fields=+iaS --extra=+q ' . '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                              endif
    1   0.000068   0.000013   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_ctags_arguments_list', 'cpp', '--language-force=C++ -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q '. '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
                              "}}}
                            
                              " Initialize text mode filetypes. "{{{
    1   0.000049   0.000029   call neocomplcache#util#set_default( 'g:neocomplcache_text_mode_filetypes', {})
    1   0.000129   0.000015   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_text_mode_filetypes', 'text,help,tex,gitcommit,vcs-commit', 1)
                              "}}}
                            
                              " Initialize tags filter patterns. "{{{
    1   0.000028   0.000008   call neocomplcache#util#set_default( 'g:neocomplcache_tags_filter_patterns', {})
    1   0.000073   0.000007   call neocomplcache#util#set_default_dictionary('g:neocomplcache_tags_filter_patterns', 'c,cpp','v:val.word !~ ''^[~_]''')
                              "}}}
                            
                              " Initialize force omni completion pattern. "{{{
    1   0.000026   0.000007   call neocomplcache#util#set_default( 'g:neocomplcache_force_omni_patterns', {})
    1   0.000062   0.000008   call neocomplcache#util#set_default_dictionary('g:neocomplcache_force_omni_patterns', 'objc','\h\w\+\|[^.[:digit:] *\t]\%(\.\|->\)')
                              "}}}
                            
                              " Initialize ignore composite filetypes
    1   0.000026   0.000006   call neocomplcache#util#set_default( 'g:neocomplcache_ignore_composite_filetype_lists', {})
                            
                              " Must g:neocomplcache_auto_completion_start_length > 1.
    1              0.000002   if g:neocomplcache_auto_completion_start_length < 1
                                let g:neocomplcache_auto_completion_start_length = 1
                              endif
                              " Must g:neocomplcache_min_keyword_length > 1.
    1              0.000002   if g:neocomplcache_min_keyword_length < 1
                                let g:neocomplcache_min_keyword_length = 1
                              endif
                            
                              " Initialize omni function list. "{{{
    1              0.000004   if !exists('g:neocomplcache_omni_functions')
                                let g:neocomplcache_omni_functions = {}
                              endif
                              "}}}
                            
                              " Set custom.
    1   0.001119   0.000009   call s:set_default_custom()

FUNCTION  <SNR>12_get_yankstack_head()
Called 2 times
Total time:   0.143989
 Self time:   0.143861

count  total (s)   self (s)
    2   0.000164   0.000036   let reg = s:default_register()
    2              0.143819   return { 'text': getreg(reg), 'type': getregtype(reg) }

FUNCTION  <SNR>64_DelimitMateDo()
Called 6 times
Total time:   0.037180
 Self time:   0.000378

count  total (s)   self (s)
                            
                            	" First, remove all magic, if needed:
    6              0.000037 	if exists("b:delimitMate_enabled") && b:delimitMate_enabled == 1
    2   0.001895   0.000028 		call s:Unmap()
    2              0.000001 	endif
                            
                            	" Check if this file type is excluded:
    6              0.000045 	if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                            
                            		" Finish here:
                            		return 1
                            	endif
                            
                            	" Check if user tried to disable using b:loaded_delimitMate
    6              0.000023 	if exists("b:loaded_delimitMate")
                            		return 1
                            	endif
                            
                            	" Initialize settings:
    6   0.008659   0.000037 	call s:init()
                            
                            	" Now, add magic:
    6              0.000029 	if !exists("g:delimitMate_offByDefault") || !g:delimitMate_offByDefault
    6   0.026349   0.000036 		call s:Map()
    6              0.000005 	endif
                            
    6              0.000009 	if a:0 > 0
                            		echo "delimitMate has been reset."
                            	endif

FUNCTION  neocomplcache#util#is_mac()
Called 1 time
Total time:   0.000012
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000011   0.000008   return call(s:V.is_mac, a:000)

FUNCTION  <SNR>12_before_yank()
Called 2 times
Total time:   0.144120
 Self time:   0.000131

count  total (s)   self (s)
    2   0.144030   0.000041   let head = s:get_yankstack_head()
    2              0.000041   if !empty(head.text) && (empty(s:yankstack_tail) || (head != s:yankstack_tail[0]))
    1              0.000008     call insert(s:yankstack_tail, head)
    1              0.000013     let s:yankstack_tail = s:yankstack_tail[: g:yankstack_size-1]
    1              0.000002   endif

FUNCTION  vimproc#util#substitute_path_separator()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000015   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  <SNR>29_LoadIndent()
Called 2 times
Total time:   0.000726
 Self time:   0.000726

count  total (s)   self (s)
    2              0.000007     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    2              0.000007     let s = expand("<amatch>")
    2              0.000004     if s != ""
    2              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    4              0.000012       for name in split(s, '\.')
    2              0.000669 	exe 'runtime! indent/' . name . '.vim'
    2              0.000002       endfor
    2              0.000001     endif

FUNCTION  bufferline#generate_string()
Called 30 times
Total time:   0.011849
 Self time:   0.001911

count  total (s)   self (s)
   30   0.010350   0.000412   let names = s:generate_names()
                            
                              " force active buffer to be second in line always and wrap the others
   30              0.000144   if g:bufferline_rotate && len(names) > 1
                                let current = bufnr('%')
                                while names[1][0] != current
                                  let first = remove(names, 0)
                                  call add(names, first)
                                endwhile
                              endif
                            
   30              0.000077   let line = ''
   60              0.000149   for val in names
   30              0.000176     let line .= val[1]
   30              0.000054   endfor
                            
   30              0.000061   return line

FUNCTION  neocomplcache#util#join_rtp()
Called 1 time
Total time:   0.003136
 Self time:   0.000825

count  total (s)   self (s)
    1   0.003135   0.000824   return join(map(copy(a:list), 's:escape(v:val)'), ',')

FUNCTION  <SNR>112_restore_statusline()
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000015   if &filetype !=# 'unite' || !g:unite_force_overwrite_statusline
    3              0.000004     return
                              endif
                            
                              let unite = unite#get_current_unite()
                            
                              if &l:statusline != unite.statusline
                                " Restore statusline.
                                let &l:statusline = unite.statusline
                              endif

FUNCTION  nerdtree#getPath()
Called 2 times
Total time:   0.003985
 Self time:   0.000816

count  total (s)   self (s)
    2              0.000023     let line = getline(a:ln)
                            
    2   0.000308   0.000033     let rootLine = g:NERDTreeFileNode.GetRootLineNum()
                            
                                "check to see if we have the root node
    2              0.000010     if a:ln == rootLine
                                    return b:NERDTreeRoot.path
                                endif
                            
    2              0.000008     if !g:NERDTreeDirArrows
                                    " in case called from outside the tree
                                    if line !~# '^ *[|` ]' || line =~# '^$'
                                        return {}
                                    endif
                                endif
                            
    2   0.000028   0.000020     if line ==# nerdtree#treeUpDirLine()
                                    return b:NERDTreeRoot.path.getParent()
                                endif
                            
    2   0.000138   0.000019     let indent = nerdtree#indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
    2   0.000307   0.000024     let curFile = nerdtree#stripMarkupFromLine(line, 0)
                            
    2              0.000005     let wasdir = 0
    2              0.000010     if curFile =~# '/$'
    2              0.000006         let wasdir = 1
    2              0.000026         let curFile = substitute(curFile, '/\?$', '/', "")
    2              0.000003     endif
                            
    2              0.000005     let dir = ""
    2              0.000007     let lnum = a:ln
    6              0.000016     while lnum > 0
    6              0.000023         let lnum = lnum - 1
    6              0.000035         let curLine = getline(lnum)
    6   0.000938   0.000072         let curLineStripped = nerdtree#stripMarkupFromLine(curLine, 1)
                            
                                    "have we reached the top of the tree?
    6              0.000018         if lnum == rootLine
    2   0.000319   0.000050             let dir = b:NERDTreeRoot.path.str({'format': 'UI'}) . dir
    2              0.000004             break
                                    endif
    4              0.000027         if curLineStripped =~# '/$'
    4   0.000252   0.000067             let lpindent = nerdtree#indentLevelFor(curLine)
    4              0.000012             if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', "", "") . dir
                                            continue
                                        endif
    4              0.000004         endif
    4              0.000005     endwhile
    2              0.000016     let curFile = b:NERDTreeRoot.path.drive . dir . curFile
    2   0.001184   0.000020     let toReturn = g:NERDTreePath.New(curFile)
    2              0.000004     return toReturn

FUNCTION  neocomplcache#set_dictionary_helper()
Called 1 time
Total time:   0.000087
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000086   0.000022   return neocomplcache#util#set_dictionary_helper( a:variable, a:keys, a:value)

FUNCTION  350()
Called 1 time
Total time:   0.000722
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000004   augroup neocomplcache "{{{
                                " Caching events
    1              0.000010     autocmd CursorHold * call s:caching_current_buffer(line('.')-10, line('.')+10)
    1              0.000019     autocmd InsertEnter,InsertLeave * call neocomplcache#sources#member_complete#caching_current_line()
    1              0.000001   augroup END"}}}
                            
                              " Initialize member prefix patterns. "{{{
    1              0.000007   if !exists('g:neocomplcache_member_prefix_patterns')
    1              0.000004     let g:neocomplcache_member_prefix_patterns = {}
    1              0.000001   endif
    1   0.000163   0.000012   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'c,cpp,objc,objcpp', '\.\|->')
    1   0.000105   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'perl,php', '->')
    1   0.000211   0.000011   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'cs,java,javascript,d,vim,ruby,python,perl6,scala,vb', '\.')
    1   0.000086   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'lua', '\.\|:')
                              "}}}
                            
                              " Initialize member patterns. "{{{
    1              0.000006   if !exists('g:neocomplcache_member_patterns')
    1              0.000004     let g:neocomplcache_member_patterns = {}
    1              0.000001   endif
    1   0.000082   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_patterns','default', '\h\w*\%(()\|\[\h\w*\]\)\?')
                              "}}}
                            
                              " Initialize script variables. "{{{
    1              0.000003   let s:member_sources = {}
                              "}}}

FUNCTION  neobundle#config#source_bundles()
Called 27 times
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
   27              0.000100   if !empty(a:bundles)
                                call neobundle#config#source(map(copy(a:bundles), "type(v:val) == type({}) ? v:val.name : v:val"))
                              endif

FUNCTION  <SNR>148__import()
Called 15 times
Total time:   0.078488
 Self time:   0.002483

count  total (s)   self (s)
   15              0.000044   if type(a:name) == type(0)
                                return s:_build_module(a:name)
                              endif
   15   0.007622   0.000086   let path = s:_get_module_path(a:name)
   15              0.000030   if path ==# ''
                                throw 'vital: module not found: ' . a:name
                              endif
   15              0.000050   let sid = get(a:scripts, path, 0)
   15              0.000015   if !sid
    3              0.000002     try
    3   0.003418   0.001229       execute 'source' fnameescape(path)
    3              0.000006     catch /^Vim\%((\a\+)\)\?:E484/
                                  throw 'vital: module not found: ' . a:name
                                catch /^Vim\%((\a\+)\)\?:E127/
                                  " Ignore.
                                endtry
                            
    3              0.000015     let sid = len(a:scripts) + 1  " We expect that the file newly read is +1.
    3              0.000013     let a:scripts[path] = sid
    3              0.000002   endif
   15   0.037916   0.015289   return s:_build_module(sid)

FUNCTION  nerdtree#restoreScreenState()
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000007     if !exists("b:NERDTreeOldTopLine") || !exists("b:NERDTreeOldPos") || !exists("b:NERDTreeOldWindowSize")
                                    return
                                endif
    1              0.000006     exec("silent vertical resize ".b:NERDTreeOldWindowSize)
                            
    1              0.000002     let old_scrolloff=&scrolloff
    1              0.000004     let &scrolloff=0
    1              0.000004     call cursor(b:NERDTreeOldTopLine, 0)
    1              0.000018     normal! zt
    1              0.000004     call setpos(".", b:NERDTreeOldPos)
    1              0.000002     let &scrolloff=old_scrolloff

FUNCTION  indent_guides#calculate_guide_size()
Called 13 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
   13              0.000037   let l:guide_size = g:indent_guides_guide_size
                            
   13              0.000040   if l:guide_size == 0 || l:guide_size > s:indent_size
                                let l:guide_size = s:indent_size
                              endif
                            
   13              0.000018   return l:guide_size

FUNCTION  367()
Called 1 time
Total time:   0.082970
 Self time:   0.020244

count  total (s)   self (s)
                              " Initialize.
    1   0.000099   0.000012   call neocomplcache#set_dictionary_helper( g:neocomplcache_source_rank, 'snippets_complete', 8)
    1   0.000064   0.000013   call neocomplcache#set_completion_length('snippets_complete', g:neocomplcache_auto_completion_start_length)
    1   0.082804   0.020216   call neosnippet#util#set_default( 'g:neosnippet#enable_preview', 0)

FUNCTION  unite#sources#history_yank#_append()
Called 5 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    5              0.000034   if (!empty(s:yank_histories) && s:yank_histories[0][0] ==# @") || len(@") < 2
    5              0.000003     return
                              endif
                            
                              call s:load()
                            
                              " Append @" value.
                              call insert(s:yank_histories, [getreg('"'), getregtype('"')])
                            
                              if g:unite_source_history_yank_limit < len(s:yank_histories)
                                let s:yank_histories = s:yank_histories[ : g:unite_source_history_yank_limit - 1]
                              endif
                            
                              call s:save()

FUNCTION  neocomplcache#get_context()
Called 13 times
Total time:   0.000411
 Self time:   0.000127

count  total (s)   self (s)
   13   0.000402   0.000118   return neocomplcache#get_current_neocomplcache().context

FUNCTION  <SNR>121_Highlight_Matching_Pair()
Called 9 times
Total time:   0.000488
 Self time:   0.000488

count  total (s)   self (s)
                              " Remove any previous match.
    9              0.000032   if exists('w:paren_hl_on') && w:paren_hl_on
                                3match none
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    9              0.000031   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    9              0.000024   let c_lnum = line('.')
    9              0.000022   let c_col = col('.')
    9              0.000012   let before = 0
                            
    9              0.000038   let c = getline(c_lnum)[c_col - 1]
    9              0.000080   let plist = split(&matchpairs, '.\zs[:,]')
    9              0.000031   let i = index(plist, c)
    9              0.000011   if i < 0
                                " not found, in Insert mode try character before the cursor
    9              0.000033     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = 1
                                  let c = getline(c_lnum)[c_col - 2]
                                  let i = index(plist, c)
                                endif
    9              0.000009     if i < 0
                                  " not found, nothing to do
    9              0.000009       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let save_cursor = winsaveview()
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " When not in a string or comment ignore matches inside them.
                              let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' . '=~?  "string\\|character\\|singlequote\\|comment"'
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              try
                                " Limit the search time to 300 msec to avoid a hang on very long lines.
                                " This fails when a timeout is not supported.
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, 300)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                call winrestview(save_cursor)
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>28_LoadFTPlugin()
Called 2 times
Total time:   0.004543
 Self time:   0.004543

count  total (s)   self (s)
    2              0.000006     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    2              0.000005     let s = expand("<amatch>")
    2              0.000003     if s != ""
    2              0.000012       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    4              0.000011       for name in split(s, '\.')
    2              0.004476 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    2              0.000005       endfor
    2              0.000002     endif

FUNCTION  <SNR>48_shellslash()
Called 4 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    4              0.000018   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
    4              0.000008     return a:path
                              endif

FUNCTION  DetectNode()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000005   if !did_filetype()
    1              0.000011     if getline(1) =~ '^#.*\<node\>'
                                  setfiletype javascript
                                endif
    1              0.000002   endif

FUNCTION  neocomplcache#sources#filename_include#define()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  neocomplcache#helper#unite_patterns()
Called 1 time
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
    1              0.000002   let keyword_patterns = []
    1              0.000002   let dup_check = {}
                            
                              " Composite filetype.
    2              0.000010   for ft in split(a:filetype, '\.')
    1              0.000005     if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
                                  let dup_check[ft] = 1
                                  call add(keyword_patterns, a:pattern_var[ft])
                                endif
                            
                                " Same filetype.
    1              0.000004     if has_key(g:neocomplcache_same_filetype_lists, ft)
                                  for ft in split(g:neocomplcache_same_filetype_lists[ft], ',')
                                    if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
                                      let dup_check[ft] = 1
                                      call add(keyword_patterns, a:pattern_var[ft])
                                    endif
                                  endfor
                                endif
    1              0.000001   endfor
                            
    1              0.000005   if empty(keyword_patterns)
    1              0.000012     let default = get(a:pattern_var, '_', get(a:pattern_var, 'default', ''))
    1              0.000004     if default != ''
    1              0.000006       call add(keyword_patterns, default)
    1              0.000002     endif
    1              0.000001   endif
                            
    1              0.000006   return join(keyword_patterns, '\m\|')

FUNCTION  neocomplcache#util#expand()
Called 4 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
    4              0.000169   return expand(escape(a:path, '*?[]"={}'), 1)

FUNCTION  <SNR>85_generate_names()
Called 30 times
Total time:   0.009938
 Self time:   0.009938

count  total (s)   self (s)
   30              0.000142   let names = []
   30              0.000095   let i = 1
   30              0.000184   let last_buffer = bufnr('$')
   30              0.000186   let current_buffer = bufnr('%')
  136              0.000415   while i <= last_buffer
  106              0.000576     if bufexists(i) && buflisted(i)
   30              0.000112       let modified = ' '
   30              0.000310       if getbufvar(i, '&mod')
                                    let modified = g:bufferline_modified
                                  endif
   30              0.000255       let fname = fnamemodify(bufname(i), ":t")
   30              0.000312       let fname = substitute(fname, "%", "%%", "g")
                            
   30              0.000084       let name = ''
   30              0.000088       if g:bufferline_show_bufnr
   30              0.000171         let name =  i . ':'
   30              0.000049       endif
   30              0.000162       let name .= fname . modified
                            
   30              0.000085       if current_buffer == i
   30              0.000229         let name = g:bufferline_active_buffer_left . name . g:bufferline_active_buffer_right
   30              0.000044       else
                                    let name = g:bufferline_seperator . name . g:bufferline_seperator
                                  endif
                            
   30              0.000207       call add(names, [i, name])
   30              0.000042     endif
  106              0.000273     let i += 1
  106              0.000163   endwhile
   30              0.000072   return names

FUNCTION  nerdtree#treeExistsForBuf()
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000009     return exists("b:NERDTreeRoot")

FUNCTION  nerdtree#findAndRevealPath()
Called 3 times
Total time:   0.303400
 Self time:   0.000887

count  total (s)   self (s)
    3              0.000018     try
    3   0.002784   0.000398         let p = g:NERDTreePath.New(expand("%:p"))
    2              0.000006     catch /^NERDTree.InvalidArgumentsError/
    1   0.000070   0.000028         call nerdtree#echo("no file for the current buffer")
    1              0.000005         return
                                endtry
                            
    2   0.000340   0.000036     if p.isUnixHiddenPath()
                                    let showhidden=g:NERDTreeShowHidden
                                    let g:NERDTreeShowHidden = 1
                                endif
                            
    2   0.000045   0.000027     if !nerdtree#treeExistsForTab()
    1              0.000002         try
    1   0.000553   0.000030             let cwd = g:NERDTreePath.New(getcwd())
    1              0.000002         catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("current directory does not exist.")
                                        let cwd = p.getParent()
                                    endtry
                            
    1   0.000385   0.000014         if p.isUnder(cwd)
                                        call g:NERDTreeCreator.CreatePrimary(cwd.str())
                                    else
    1   0.207384   0.000052             call g:NERDTreeCreator.CreatePrimary(p.getParent().str())
    1              0.000001         endif
    1              0.000000     else
    1   0.000487   0.000019         if !p.isUnder(g:NERDTreeFileNode.GetRootForTab().path)
                                        if !nerdtree#isTreeOpen()
                                            call g:NERDTreeCreator.TogglePrimary('')
                                        else
                                            call nerdtree#putCursorInTreeWin()
                                        endif
                                        let b:NERDTreeShowHidden = g:NERDTreeShowHidden
                                        call nerdtree#chRoot(g:NERDTreeDirNode.New(p.getParent()))
                                    else
    1   0.000042   0.000006             if !nerdtree#isTreeOpen()
    1   0.078810   0.000016                 call g:NERDTreeCreator.TogglePrimary("")
    1              0.000001             endif
    1              0.000000         endif
    1              0.000001     endif
    2   0.000151   0.000009     call nerdtree#putCursorInTreeWin()
    2   0.012074   0.000009     call b:NERDTreeRoot.reveal(p)
                            
    2   0.000040   0.000008     if p.isUnixHiddenFile()
                                    let g:NERDTreeShowHidden = showhidden
                                endif

FUNCTION  fugitive#detect()
Called 2 times
Total time:   0.002039
 Self time:   0.000127

count  total (s)   self (s)
    2              0.000011   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    2              0.000007   if !exists('b:git_dir')
    2   0.001932   0.000020     let dir = fugitive#extract_git_dir(a:path)
    2              0.000004     if dir !=# ''
                                  let b:git_dir = dir
                                endif
    2              0.000001   endif
    2              0.000006   if exists('b:git_dir')
                                silent doautocmd User Fugitive
                                cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
                                nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
                                let buffer = fugitive#buffer()
                                if expand('%:p') =~# '//'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
                                if stridx(buffer.getvar('&tags'), escape(b:git_dir.'/tags', ', ')) == -1
                                  call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  if &filetype !=# ''
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
                                endif
                              endif

FUNCTION  <SNR>159_caching()
Called 1 time
Total time:   0.002461
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000007   if !bufloaded(bufnr('%'))
                                return
                              endif
                            
    1   0.000076   0.000022   let key = neocomplcache#is_text_mode() ? 'text' : neocomplcache#get_context_filetype()
    2   0.002103   0.000012   for filetype in neocomplcache#get_source_filetypes(key)
    1              0.000007     if !has_key(s:dictionary_list, filetype) && !has_key(s:async_dictionary_list, filetype)
    1   0.000248   0.000011       call neocomplcache#sources#dictionary_complete#recaching(filetype)
    1              0.000001     endif
    1              0.000001   endfor

FUNCTION  306()
Called 14 times
Total time:   0.001456
 Self time:   0.000357

count  total (s)   self (s)
   14   0.001095   0.000069   let path = self.path()
                            
   14              0.000028   if empty(path)
    7              0.000007     return
                              endif
                            
    7              0.000013   if empty(self.candidates)
                                call self.load()
                              endif
                            
    7              0.000013   let save_ignorecase = &ignorecase
    7   0.000053   0.000037   let &ignorecase = unite#util#is_windows()
                            
    7              0.000018   let time = localtime()
    7   0.000110   0.000053   call insert(self.candidates, s:convert2dictionary([path, time]))
                            
    7              0.000017   let &ignorecase = save_ignorecase
                            
    7              0.000018   if (time - self.mtime) > self.update_interval
                                call self.save()
                              endif

FUNCTION  107()
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000011     let line = getline(".")
    2              0.000027     let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    2              0.000005     if name != line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
                                endif
    2              0.000004     return {}

FUNCTION  311()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                              " everything is loaded, done!
    1              0.000002   if self.is_loaded >= 2
                                return
                              endif
                            
                              " Load Order:
                              " 1. (load)  short mru list
                              " 2. (merge) long list on_redraw
    1              0.000008   let mru_file = empty(self.candidates) ? self.mru_file.short : self.mru_file.long
                            
    1              0.000017   if !filereadable(mru_file)
    1              0.000002     return
                              endif
                            
                              let file = readfile(mru_file)
                              if empty(file)
                                return
                              endif
                            
                              let [ver; items] = file
                              if !self.version_check(ver)
                                return
                              endif
                            
                              " Assume properly saved and sorted. unique sort is not necessary here
                              call extend(self.candidates, s:convert2candidates(items))
                            
                              if mru_file == self.mru_file.short
                                let self.mtime = getftime(mru_file)
                                let self.is_loaded = 1
                              elseif mru_file == self.mru_file.long
                                let self.is_loaded = 2
                              endif

FUNCTION  313()
Called 7 times
Total time:   0.000531
 Self time:   0.000443

count  total (s)   self (s)
    7   0.000254   0.000235   let path = unite#util#substitute_path_separator(expand('%:p'))
    7              0.000048   if path !~ '\a\+:'
    7   0.000102   0.000089     let path = unite#util#substitute_path_separator( simplify(resolve(path)))
    7              0.000005   endif
                            
                              " Append the current buffer to the mru list.
    7   0.000091   0.000035   if !s:is_file_exist(path) || &l:buftype =~# 'help\|nofile'
    7              0.000007     return ''
                              endif
                            
                              return path

FUNCTION  315()
Called 7 times
Total time:   0.000495
 Self time:   0.000480

count  total (s)   self (s)
    7              0.000035   let filetype = getbufvar(bufnr('%'), '&filetype')
    7              0.000025   if filetype ==# 'vimfiler' && type(getbufvar(bufnr('%'), 'vimfiler')) == type({})
                                let path = getbufvar(bufnr('%'), 'vimfiler').current_dir
                              elseif filetype ==# 'vimshell' && type(getbufvar(bufnr('%'), 'vimshell')) == type({})
                                let path = getbufvar(bufnr('%'), 'vimshell').current_dir
                              else
    7              0.000090     let path = getcwd()
    7              0.000006   endif
                            
    7   0.000129   0.000114   let path = unite#util#substitute_path_separator( simplify(resolve(path)))
                              " Chomp last /.
    7              0.000049   let path = substitute(path, '/$', '', '')
                            
                              " Append the current buffer to the mru list.
    7              0.000052   if !isdirectory(path) || &buftype =~ 'help'
                                return ''
                              endif
    7              0.000005   return path

FUNCTION  316()
Called 1 time
Total time:   0.000251
 Self time:   0.000251

count  total (s)   self (s)
    1              0.000003   if self.do_validate
    1              0.000245     call filter(self.candidates, 'getftype(v:val.action__path) ==# "dir"')
    1              0.000003   endif

FUNCTION  nerdtree#indentLevelFor()
Called 12 times
Total time:   0.000434
 Self time:   0.000401

count  total (s)   self (s)
   12   0.000240   0.000207     let level = match(a:line, '[^ \-+~`|]') / nerdtree#treeWid()
                                " check if line includes arrows
   12              0.000082     if match(a:line, '[]') > -1
                                    " decrement level as arrow uses 3 ascii chars
   12              0.000042         let level = level - 1
   12              0.000014     endif
   12              0.000016     return level

FUNCTION  <SNR>173__scripts()
Called 2 times
Total time:   0.025324
 Self time:   0.010820

count  total (s)   self (s)
    2              0.000009   let scripts = {}
  348   0.001957   0.000936   for line in split(s:_redir('scriptnames'), "\n")
  346              0.004479     let list = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
  346              0.000724     if !empty(list)
  346   0.016331   0.002848       let scripts[s:_unify_path(list[2])] = list[1] - 0
  346              0.000376     endif
  346              0.001243   endfor
    2              0.000002   return scripts

FUNCTION  signature#SignRefresh()
Called 10 times
Total time:   0.022793
 Self time:   0.011879

count  total (s)   self (s)
                              " Description: Add signs for new marks/marksers and remove signs for deleted marks/markers
                            
   10              0.000056   if !exists('b:sig_status')  | let b:sig_status  = 1  | endif
                            
                              " If Signature has been disabled, return
   10              0.000028   if ( !b:sig_status ) | return | endif
                            
   10              0.000043   if !exists('b:sig_marks')   | let b:sig_marks   = {} | endif
   10              0.000041   if !exists('b:sig_markers') | let b:sig_markers = {} | endif
                            
   10              0.000068   let l:SignatureIncludeMarks = ( exists('b:SignatureIncludeMarks') ? b:SignatureIncludeMarks : g:SignatureIncludeMarks )
   10   0.010983   0.000069   let l:used_marks = s:UsedMarks()
                            
                              " Remove signs for absent marks
  530              0.001026   for i in split(l:SignatureIncludeMarks, '\zs')
  520              0.002730     let l:pair = items(filter(copy(b:sig_marks), 'v:val =~# i'))
  520              0.001061     if !empty(l:pair)
                                  let l:found = 0
                                  for j in l:used_marks
                                    if j[0] ==# i && j[1] == l:pair[0][0]
                                      let l:found = 1
                                      break
                                    endif
                                  endfor
                                  if !(l:found)
                                    call s:ToggleSign(i, 0, 0)
                                  endif
                                endif
  520              0.000407   endfor
                            
                              " Add signs for present marks
   10              0.000017   for k in l:used_marks
                                if !has_key(b:sig_marks, k[1])
                                  call s:ToggleSign(k[0], 1, k[1])
                                elseif b:sig_marks[k[1]] !~# k[0]
                                  call s:ToggleSign(k[0], 0, 0)
                                  call s:ToggleSign(k[0], 1, k[1])
                                endif
                              endfor
                            
                              " Add signs for markers
   10              0.000028   for i in keys(b:sig_markers)
                                call s:ToggleSign(b:sig_markers[i], 1, i)
                              endfor

FUNCTION  25()
Called 26 times
Total time:   0.001438
 Self time:   0.001031

count  total (s)   self (s)
   26              0.000083     let prependCWD = 0
   26   0.000480   0.000138     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
   26              0.000183         let prependCWD = a:str !~# '^/'
   26              0.000035     endif
                            
   26              0.000072     let toReturn = a:str
   26              0.000039     if prependCWD
    2   0.000167   0.000102         let toReturn = getcwd() . s:Path.Slash() . a:str
    2              0.000004     endif
                            
   26              0.000047     return toReturn

FUNCTION  27()
Called 14 times
Total time:   0.000659
 Self time:   0.000431

count  total (s)   self (s)
   14   0.000203   0.000056     let self.cachedDisplayString = self.getLastPathComponent(1)
                            
   14              0.000014     if self.isExecutable
                                    let self.cachedDisplayString = self.cachedDisplayString . '*'
                                endif
                            
   14              0.000046     let self._bookmarkNames = []
   14   0.000127   0.000046     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
   14              0.000020     if !empty(self._bookmarkNames)
                                    let self.cachedDisplayString .= ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
   14              0.000011     if self.isSymLink
                                    let self.cachedDisplayString .=  ' -> ' . self.symLinkDest
                                endif
                            
   14              0.000011     if self.isReadOnly
                                    let self.cachedDisplayString .=  ' [RO]'
                                endif

FUNCTION  29()
Called 54 times
Total time:   0.011395
 Self time:   0.001677

count  total (s)   self (s)
   54   0.000755   0.000207     let thisPath = self.getLastPathComponent(1)
   54   0.000773   0.000212     let thatPath = a:path.getLastPathComponent(1)
                            
                                "if the paths are the same then clearly we return 0
   54              0.000084     if thisPath ==# thatPath
                                    return 0
                                endif
                            
   54   0.005114   0.000208     let thisSS = self.getSortOrderIndex()
   54   0.003905   0.000202     let thatSS = a:path.getSortOrderIndex()
                            
                                "compare the sort sequences, if they are different then the return
                                "value is easy
   54              0.000060     if thisSS < thatSS
                                    return -1
                                elseif thisSS > thatSS
   12              0.000011         return 1
                                else
                                    "if the sort sequences are the same then compare the paths
                                    "alphabetically
   42              0.000140         let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
   42              0.000041         if pathCompare
   18              0.000015             return -1
                                    else
   24              0.000012             return 1
                                    endif
                                endif

FUNCTION  127()
Called 3 times
Total time:   0.000508
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000507   0.000021     return self.path.str() ==# a:treenode.path.str()

FUNCTION  <SNR>48_diff_window_count()
Called 9 times
Total time:   0.000299
 Self time:   0.000299

count  total (s)   self (s)
    9              0.000030   let c = 0
   23              0.000079   for nr in range(1,winnr('$'))
   14              0.000063     let c += getwinvar(nr,'&diff')
   14              0.000029   endfor
    9              0.000016   return c

FUNCTION  neocomplcache#util#split_rtp()
Called 2 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    2              0.000011   let rtp = a:0 ? a:1 : &runtimepath
    2              0.000011   if type(rtp) == type([])
                                return rtp
                              endif
                            
    2              0.000035   if rtp !~ '\\'
    2              0.000078     return split(rtp, ',')
                              endif
                            
                              let split = split(rtp, '\\\@<!\%(\\\\\)*\zs,')
                              return map(split,'substitute(v:val, ''\\\([\\,]\)'', "\\1", "g")')

FUNCTION  nerdtree#compareNodes()
Called 54 times
Total time:   0.011650
 Self time:   0.000255

count  total (s)   self (s)
   54   0.011634   0.000239     return a:n1.path.compareTo(a:n2.path)

FUNCTION  ctrlp#utils#lash()
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000047 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  165()
Called 3 times
Total time:   0.020523
 Self time:   0.000074

count  total (s)   self (s)
    3              0.000008     let opts = a:0 ? a:1 : {}
                            
    3              0.000012     if has_key(opts, 'where') && !empty(opts['where'])
                                    let opener = g:NERDTreeOpener.New(self.path, opts)
                                    call opener.open(self)
                                else
    3              0.000007         let self.isOpen = 1
    3              0.000007         if self.children ==# []
    1   0.020463   0.000014             return self._initChildren(0)
                                    else
    2              0.000002             return 0
                                    endif
                                endif

FUNCTION  35()
Called 42 times
Total time:   0.000918
 Self time:   0.000259

count  total (s)   self (s)
   42              0.000062     if self.cachedDisplayString ==# ""
   14   0.000700   0.000041         call self.cacheDisplayString()
   14              0.000006     endif
                            
   42              0.000044     return self.cachedDisplayString

FUNCTION  37()
Called 26 times
Total time:   0.000974
 Self time:   0.000685

count  total (s)   self (s)
   26   0.000418   0.000129     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
   26              0.000070         let self.drive = ''
   26              0.000024     endif
                            

FUNCTION  309()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000019   return self.mtime < getftime(self.mru_file.short) || self.mtime < getftime(self.mru_file.long)

FUNCTION  nerdtree#putCursorInTreeWin()
Called 4 times
Total time:   0.000323
 Self time:   0.000073

count  total (s)   self (s)
    4   0.000118   0.000017     if !nerdtree#isTreeOpen()
                                    throw "NERDTree.InvalidOperationError: cant put cursor in NERD tree window, no window exists"
                                endif
                            
    4   0.000187   0.000038     call nerdtree#exec(nerdtree#getTreeWinNum() . "wincmd w")

FUNCTION  <SNR>67_CheckGrepCommandForChanges()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000004     if &grepprg != s:LastSeenGrepprg
                                    if s:IsCommandAck()
                                        if !s:IsModeAll() && !s:IsModeBuffers()
                                            call s:Info("==================================================================================")
                                            call s:Info("The 'grepprg' has changed to '".s:GetGrepCommandName()."' since last inspected")
                                            call s:Info("Switching to 'All' mode as the '".s:GetModeName(g:EasyGrepMode)."' mode is incompatible with this program")
                                            if !g:EasyGrepRecursive
                                                call s:Info("And setting g:EasyGrepRecusive to 'On', as ".s:GetGrepProgramPair()." is inherently recursive")
                                                let g:EasyGrepRecursive = 1
                                            endif
                                            call s:Info("==================================================================================")
                                            call s:ForceGrepMode(s:EasyGrepModeAll)
                                        endif
                                    endif
                                    let s:LastSeenGrepprg = &grepprg
                                    return 0
                                endif
    1              0.000001     return 1

FUNCTION  126()
Called 42 times
Total time:   0.001062
 Self time:   0.000144

count  total (s)   self (s)
   42   0.001046   0.000128     return self.path.displayString()

FUNCTION  <SNR>6_expand()
Called 5 times
Total time:   0.000131
 Self time:   0.000104

count  total (s)   self (s)
    5   0.000126   0.000099   return neobundle#util#substitute_path_separator( (a:path =~ '^\~') ? substitute(a:path, '^\~', expand('~'), '') : (a:path =~ '^\$\h\w*') ? substitute(a:path,               '^\$\h\w*', '\=eval(submatch(0))', '') : a:path)

FUNCTION  335()
Called 1 time
Total time:   0.002682
 Self time:   0.000105

count  total (s)   self (s)
                              " Initialize dictionary. "{{{
    1              0.000007   if !exists('g:neocomplcache_dictionary_filetype_lists')
    1              0.000004     let g:neocomplcache_dictionary_filetype_lists = {}
    1              0.000001   endif
    1              0.000005   if !has_key(g:neocomplcache_dictionary_filetype_lists, 'default')
    1              0.000006     let g:neocomplcache_dictionary_filetype_lists['default'] = ''
    1              0.000001   endif
                              "}}}
                            
                              " Initialize dictionary completion pattern. "{{{
    1              0.000005   if !exists('g:neocomplcache_dictionary_patterns')
    1              0.000004     let g:neocomplcache_dictionary_patterns = {}
    1              0.000001   endif
                              "}}}
                            
                              " Set caching event.
    1              0.000021   autocmd neocomplcache FileType * call s:caching()
                            
                              " Create cache directory.
    1   0.000135   0.000019   if !isdirectory(neocomplcache#get_temporary_directory() . '/dictionary_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/dictionary_cache')
                              endif
                            
                              " Initialize check.
    1   0.002472   0.000011   call s:caching()

FUNCTION  338()
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  neocomplcache#sources#dictionary_complete#recaching()
Called 1 time
Total time:   0.000237
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000006   if !exists('g:neocomplcache_dictionary_filetype_lists')
                                call neocomplcache#initialize()
                              endif
                            
    1              0.000002   let filetype = a:filetype
    1              0.000002   if filetype == ''
                                let filetype = neocomplcache#get_context_filetype(1)
                              endif
                            
                              " Caching.
    1              0.000006   let dictionaries = get( g:neocomplcache_dictionary_filetype_lists, filetype, '')
                            
    1              0.000002   if dictionaries == ''
    1              0.000005     if filetype != &filetype && &l:dictionary != '' && &l:dictionary !=# &g:dictionary
                                  let dictionaries .= &l:dictionary
                                endif
    1              0.000001   endif
                            
    1              0.000004   let s:async_dictionary_list[filetype] = []
                            
    1   0.000158   0.000015   let pattern = get(g:neocomplcache_dictionary_patterns, filetype, neocomplcache#get_keyword_pattern(filetype))
    1              0.000011   for dictionary in split(dictionaries, ',')
                                let dictionary = neocomplcache#util#substitute_path_separator( fnamemodify(dictionary, ':p'))
                                if filereadable(dictionary)
                                  call neocomplcache#print_debug('Caching dictionary: ' . dictionary)
                                  call add(s:async_dictionary_list[filetype], { 'filename' : dictionary, 'cachename' : neocomplcache#cache#async_load_from_file(       'dictionary_cache', dictionary, pattern, 'D') })
                                endif
                              endfor

FUNCTION  <SNR>67_CreateDict()
Called 7 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    7              0.000021     if exists("s:Dict")
    7              0.000007         return
                                endif
                            
                                let s:Dict = [ ]
                                call add(s:Dict, [ "All" , "*", g:EasyGrepMode==s:EasyGrepModeAll ? 1 : 0 ] )
                                call add(s:Dict, [ "Buffers" , "*Buffers*", g:EasyGrepMode==s:EasyGrepModeBuffers ? 1 : 0  ] )
                                call add(s:Dict, [ "TrackExt" , "*", g:EasyGrepMode==s:EasyGrepModeTracked ? 1 : 0  ] )
                                call add(s:Dict, [ "User" , "", g:EasyGrepMode==s:EasyGrepModeUser ? 1 : 0  ] )
                            
                                if len(s:Dict) != s:EasyGrepNumModes
                                    call s:InternalFailure("EasyGrep's default settings are not internally consistent; please reinstall")
                                endif
                            
                                call s:ParseFileAssociationList()
                                let s:NumFileAssociations = len(s:Dict) - s:EasyGrepNumModes
                            

FUNCTION  43()
Called 2 times
Total time:   0.000032
 Self time:   0.000011

count  total (s)   self (s)
    2   0.000032   0.000011     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  44()
Called 2 times
Total time:   0.000304
 Self time:   0.000244

count  total (s)   self (s)
    2   0.000090   0.000030     if self.getLastPathComponent(0) =~# '^\.'
                                    return 1
                                else
   14              0.000040         for segment in self.pathSegments
   12              0.000064             if segment =~# '^\.'
                                            return 1
                                        endif
   12              0.000028         endfor
    2              0.000004         return 0
                                endif

FUNCTION  45()
Called 48 times
Total time:   0.004524
 Self time:   0.001544

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
   48              0.000070     if b:NERDTreeIgnoreEnabled
  132              0.000151         for i in g:NERDTreeIgnore
   90   0.003306   0.000326             if self._ignorePatternMatches(i)
    6              0.000006                 return 1
                                        endif
   84              0.000060         endfor
   42              0.000022     endif
                            
                                "dont show hidden files unless instructed to
   42              0.000085     if b:NERDTreeShowHidden ==# 0 && self.isUnixHiddenFile()
                                    return 1
                                endif
                            
   42              0.000074     if b:NERDTreeShowFiles ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
   42              0.000138     if exists("*NERDTreeCustomIgnoreFilter") && NERDTreeCustomIgnoreFilter(self)
                                    return 1
                                endif
                            
   42              0.000027     return 0

FUNCTION  46()
Called 90 times
Total time:   0.002980
 Self time:   0.002105

count  total (s)   self (s)
   90              0.000150     let pat = a:pattern
   90              0.000320     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
   90   0.001328   0.000453     return self.getLastPathComponent(0) =~# pat

FUNCTION  47()
Called 4 times
Total time:   0.001160
 Self time:   0.000114

count  total (s)   self (s)
    4              0.000012     if a:path.isDirectory == 0
                                    return 0
                                endif
                            
    4   0.000546   0.000027     let this = self.str()
    4   0.000497   0.000027     let that = a:path.str()
    4   0.000087   0.000030     return stridx(this, that . s:Path.Slash()) == 0

FUNCTION  nerdtree#escChars()
Called 1 time
Total time:   0.000024
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000018   0.000006     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>"
                                endif
                            
    1              0.000002     return " \\`\|\"#%&,?()\*^<>[]"

FUNCTION  <SNR>140_is_file_exist()
Called 7 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    7              0.000054   return a:path !~ '^\a\w\+:' && getftype(a:path) ==# 'file'

FUNCTION  <SNR>70_mergelists()
Called 1 time
Total time:   0.050448
 Self time:   0.001045

count  total (s)   self (s)
    1   0.049415   0.000032 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000891 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000099 	let mrufs = s:mrufs + diskmrufs
    1   0.000040   0.000020 	retu s:chop(mrufs)

FUNCTION  131()
Called 3 times
Total time:   0.001777
 Self time:   0.000359

count  total (s)   self (s)
                                "if the node is the root then return the root line no.
    3   0.000563   0.000011     if self.isRoot()
    1   0.000050   0.000004         return s:TreeFileNode.GetRootLineNum()
                                endif
                            
    2              0.000005     let totalLines = line("$")
                            
                                "the path components we have matched so far
    2   0.000134   0.000028     let pathcomponents = [substitute(b:NERDTreeRoot.path.str({'format': 'UI'}), '/ *$', '', '')]
                                "the index of the component we are searching for
    2              0.000003     let curPathComponent = 1
                            
    2   0.000114   0.000013     let fullpath = self.path.str({'format': 'UI'})
                            
                            
    2   0.000102   0.000009     let lnum = s:TreeFileNode.GetRootLineNum()
    6              0.000007     while lnum > 0
    6              0.000011         let lnum = lnum + 1
                                    "have we reached the bottom of the tree?
    6              0.000011         if lnum ==# totalLines+1
                                        return -1
                                    endif
                            
    6              0.000014         let curLine = getline(lnum)
                            
    6   0.000157   0.000027         let indent = nerdtree#indentLevelFor(curLine)
    6              0.000010         if indent ==# curPathComponent
    6   0.000419   0.000029             let curLine = nerdtree#stripMarkupFromLine(curLine, 1)
                            
    6              0.000029             let curPath =  join(pathcomponents, '/') . '/' . curLine
    6              0.000019             if stridx(fullpath, curPath, 0) ==# 0
    2              0.000006                 if fullpath ==# curPath || strpart(fullpath, len(curPath)-1,1) ==# '/'
    2              0.000011                     let curLine = substitute(curLine, '/ *$', '', '')
    2              0.000006                     call add(pathcomponents, curLine)
    2              0.000005                     let curPathComponent = curPathComponent + 1
                            
    2              0.000004                     if fullpath ==# curPath
    2              0.000002                         return lnum
                                                endif
                                            endif
                                        endif
    4              0.000004         endif
    4              0.000002     endwhile
                                return -1

FUNCTION  133()
Called 5 times
Total time:   0.000414
 Self time:   0.000414

count  total (s)   self (s)
    5              0.000014     let rootLine = 1
   30              0.000219     while getline(rootLine) !~# '^\(/\|<\)'
   25              0.000080         let rootLine = rootLine + 1
   25              0.000041     endwhile
    5              0.000014     return rootLine

FUNCTION  134()
Called 2 times
Total time:   0.008360
 Self time:   0.000106

count  total (s)   self (s)
    2              0.000010     try
    2   0.004025   0.000040         let path = nerdtree#getPath(line("."))
    2              0.000006         if path ==# {}
                                        return {}
                                    endif
    2   0.004296   0.000027         return b:NERDTreeRoot.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  136()
Called 3 times
Total time:   0.000552
 Self time:   0.000035

count  total (s)   self (s)
    3   0.000021   0.000012     if !nerdtree#treeExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
                                endif
                            
    3   0.000521   0.000013     return self.equals(b:NERDTreeRoot)

FUNCTION  138()
Called 16 times
Total time:   0.000589
 Self time:   0.000302

count  total (s)   self (s)
   16              0.000027     if a:path.isDirectory
    6   0.000315   0.000028         return g:NERDTreeDirNode.New(a:path)
                                else
   10              0.000129         let newTreeNode = copy(self)
   10              0.000028         let newTreeNode.path = a:path
   10              0.000024         let newTreeNode.parent = {}
   10              0.000016         return newTreeNode
                                endif

FUNCTION  ctrlp#utils#readfile()
Called 1 time
Total time:   0.017890
 Self time:   0.017890

count  total (s)   self (s)
    1              0.000040 	if filereadable(a:file)
    1              0.017807 		let data = readfile(a:file)
    1              0.000021 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    1              0.000004 		retu data
                            	en
                            	retu []

FUNCTION  nerdtree#saveScreenState()
Called 2 times
Total time:   0.000307
 Self time:   0.000086

count  total (s)   self (s)
    2              0.000006     let win = winnr()
    2              0.000003     try
    2   0.000201   0.000020         call nerdtree#putCursorInTreeWin()
    2              0.000010         let b:NERDTreeOldPos = getpos(".")
    2              0.000014         let b:NERDTreeOldTopLine = line("w0")
    2              0.000008         let b:NERDTreeOldWindowSize = winwidth("")
    2   0.000054   0.000014         call nerdtree#exec(win . "wincmd w")
    2              0.000004     catch /^NERDTree.InvalidOperationError/
                                endtry

FUNCTION  <SNR>107_BufEnterHook()
Called 7 times
Total time:   0.000235
 Self time:   0.000163

count  total (s)   self (s)
                                " TODO: at this point there is no b:syntastic_loclist
    7              0.000036     let loclist = filter(getloclist(0), 'v:val["valid"] == 1')
    7   0.000117   0.000045     let buffers = syntastic#util#unique(map( loclist, 'v:val["bufnr"]' ))
    7              0.000051     if &bt=='quickfix' && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                    call g:SyntasticLoclistHide()
                                endif

FUNCTION  neocomplcache#util#set_default_dictionary()
Called 152 times
Total time:   0.010767
 Self time:   0.003923

count  total (s)   self (s)
  152              0.000668   if !exists('s:disable_dictionaries')
    1              0.000004     let s:disable_dictionaries = {}
    1              0.000001   endif
                            
  152              0.000605   if has_key(s:disable_dictionaries, a:variable)
                                return
                              endif
                            
  152   0.008476   0.001632   call neocomplcache#util#set_dictionary_helper({a:variable}, a:keys, a:value)

FUNCTION  <SNR>151__vital_loaded()
Called 1 time
Total time:   0.009580
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   let s:V = a:V
    1   0.009577   0.000012   let s:L = s:V.import('Data.List')

FUNCTION  50()
Called 26 times
Total time:   0.011824
 Self time:   0.001221

count  total (s)   self (s)
   26              0.000624     let newPath = copy(self)
                            
   26   0.012995   0.002392     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
   25              0.000103     let newPath.cachedDisplayString = ""
                            
   25              0.000040     return newPath

FUNCTION  51()
Called 170 times
Total time:   0.002399
 Self time:   0.000855

count  total (s)   self (s)
  170   0.002307   0.000763     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  52()
Called 51 times
Total time:   0.003006
 Self time:   0.003006

count  total (s)   self (s)
   51              0.000808     let tmp = resolve(a:path)
   51              0.002137     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  56()
Called 91 times
Total time:   0.009706
 Self time:   0.004336

count  total (s)   self (s)
   91              0.000278     let options = a:0 ? a:1 : {}
   91              0.000178     let toReturn = ""
                            
   91              0.000240     if has_key(options, 'format')
   10              0.000028         let format = options['format']
   10              0.000035         if has_key(self, '_strFor' . format)
   10   0.000378   0.000092             exec 'let toReturn = self._strFor' . format . '()'
   10              0.000008         else
                                        raise 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
   10              0.000013     else
   81   0.005078   0.000417         let toReturn = self._str()
   81              0.000076     endif
                            
   91   0.000850   0.000427     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
   91              0.000222     if has_key(options, 'truncateTo')
    3              0.000007         let limit = options['truncateTo']
    3              0.000006         if len(toReturn) > limit
    3              0.000015             let toReturn = "<" . strpart(toReturn, len(toReturn) - limit + 1)
    3              0.000001         endif
    3              0.000003     endif
                            
   91              0.000116     return toReturn

FUNCTION  57()
Called 9 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    9              0.000049     let toReturn = '/' . join(self.pathSegments, '/')
    9              0.000026     if self.isDirectory && toReturn != '/'
    9              0.000024         let toReturn  = toReturn . '/'
    9              0.000006     endif
    9              0.000011     return toReturn

FUNCTION  143()
Called 3 times
Total time:   0.001857
 Self time:   0.000080

count  total (s)   self (s)
    3   0.001791   0.000014     let ln = self.getLineNum()
    3              0.000004     if ln != -1
    3              0.000003         if a:isJump
    2              0.000003             mark '
    2              0.000001         endif
    3              0.000009         call cursor(ln, col("."))
    3              0.000002     else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && node.getLineNum() ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call nerdtree#renderView()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
                                endif

FUNCTION  neocomplcache#init#is_enabled()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000008   return s:is_enabled

FUNCTION  357()
Called 1 time
Total time:   0.000211
 Self time:   0.000078

count  total (s)   self (s)
                              " Set caching event.
    1              0.000024   autocmd neocomplcache Syntax * call s:caching()
                            
                              " Create cache directory.
    1   0.000146   0.000024   if !isdirectory(neocomplcache#get_temporary_directory() . '/syntax_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/syntax_cache')
                              endif
                            
                              " Initialize check.
    1   0.000024   0.000013   call s:caching()

FUNCTION  <SNR>164_libcall()
Called 3 times
Total time:   0.012408
 Self time:   0.012127

count  total (s)   self (s)
                              " End Of Value
    3              0.000017   let EOV = "\xFF"
    3              0.000058   let args = empty(a:args) ? '' : (join(reverse(copy(a:args)), EOV) . EOV)
    3              0.011797   let stack_buf = libcall(g:vimproc#dll_path, a:func, args)
    3   0.000377   0.000096   let result = s:split(stack_buf, EOV)
    3              0.000028   if !empty(result) && result[-1] != ''
                                if stack_buf[len(stack_buf) - 1] ==# EOV
                                  " Note: If &encoding equals "cp932" and output ends multibyte first byte,
                                  "       will fail split.
                                  return result
                                endif
                                let s:lasterr = result
                                let msg = vimproc#util#iconv(string(result), vimproc#util#termencoding(), &encoding)
                            
                                throw printf('vimproc: %s: %s', a:func, msg)
                              endif
    3              0.000016   return result[:-2]

FUNCTION  <SNR>56_UseConfigFiles()
Called 1 time
Total time:   0.013894
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000006     if s:editorconfig_core_mode == 'external_command'
                                    call s:UseConfigFiles_ExternalCommand()
                                elseif s:editorconfig_core_mode == 'python_builtin'
    1   0.013861   0.000019         call s:UseConfigFiles_Python_Builtin()
    1              0.000003     elseif s:editorconfig_core_mode == 'python_external'
                                    call s:UseConfigFiles_Python_External()
                                else
                                    echohl Error | echo "Unknown EditorConfig Core: " . s:editorconfig_core_mode | echohl None
                                endif

FUNCTION  62()
Called 25 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
   25              0.000296     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  64()
Called 26 times
Total time:   0.000513
 Self time:   0.000229

count  total (s)   self (s)
   26   0.000414   0.000130     if !nerdtree#runningWindows()
   26              0.000069         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  150()
Called 16 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   16              0.000054     call add(self.children, a:treenode)
   16              0.000037     let a:treenode.parent = self
                            
   16              0.000021     if a:inOrder
                                    call self.sortChildren()
                                endif

FUNCTION  153()
Called 16 times
Total time:   0.001001
 Self time:   0.000223

count  total (s)   self (s)
   16   0.000699   0.000110     let newTreeNode = g:NERDTreeFileNode.New(a:path)
   16   0.000268   0.000079     call self.addChild(newTreeNode, a:inOrder)
   16              0.000022     return newTreeNode

FUNCTION  154()
Called 16 times
Total time:   0.010978
 Self time:   0.005005

count  total (s)   self (s)
   16   0.003622   0.000075     if a:path.equals(self.path)
    4              0.000004         return self
                                endif
   12   0.002661   0.000118     if stridx(a:path.str(), self.path.str(), 0) ==# -1
    8              0.000011         return {}
                                endif
                            
    4              0.000006     if self.path.isDirectory
   12              0.000024         for i in self.children
   12              0.000055             let retVal = i.findNode(a:path)
   12              0.000024             if retVal != {}
    4              0.000005                 return retVal
                                        endif
    8              0.000008         endfor
                                endif
                                return {}

FUNCTION  155()
Called 4 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    4              0.000008     return len(self.children)

FUNCTION  neocomplcache#set_completion_length()
Called 1 time
Total time:   0.000051
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000023   0.000008   let custom = neocomplcache#variables#get_custom().sources
    1              0.000004   if !has_key(custom, a:source_name)
    1              0.000005     let custom[a:source_name] = {}
    1              0.000001   endif
                            
    1              0.000005   if !has_key(custom[a:source_name], 'min_pattern_length')
    1              0.000005     let custom[a:source_name].min_pattern_length = a:length
    1              0.000002   endif

FUNCTION  indent_guides#highlight_colors()
Called 13 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   13              0.000025   if s:auto_colors
                                if has('gui_running')
                                  call indent_guides#gui_highlight_colors()
                                else
                                  call indent_guides#basic_highlight_colors()
                                endif
                              endif

FUNCTION  161()
Called 3 times
Total time:   0.004937
 Self time:   0.000413

count  total (s)   self (s)
    3              0.000006     let toReturn = []
   51              0.000049     for i in self.children
   48   0.004687   0.000163         if i.path.ignore() ==# 0
   42              0.000089             call add(toReturn, i)
   42              0.000028         endif
   48              0.000028     endfor
    3              0.000003     return toReturn

FUNCTION  163()
Called 1 time
Total time:   0.020449
 Self time:   0.001257

count  total (s)   self (s)
                                "remove all the current child nodes
    1              0.000004     let self.children = []
                            
                                "get an array of all the files in the nodes dir
    1              0.000004     let dir = self.path
    1   0.000251   0.000012     let globDir = dir.str({'format': 'Glob'})
                            
    1              0.000002     if version >= 703
    1              0.000500         let filesStr = globpath(globDir, '*', 1) . "\n" . globpath(globDir, '.*', 1)
    1              0.000003     else
                                    let filesStr = globpath(globDir, '*') . "\n" . globpath(globDir, '.*')
                                endif
                            
    1              0.000031     let files = split(filesStr, "\n")
                            
    1              0.000005     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ...")
                                endif
                            
    1              0.000002     let invalidFilesFound = 0
   19              0.000035     for i in files
                            
                                    "filter out the .. and . directories
                                    "Note: we must match .. AND ../ cos sometimes the globpath returns
                                    "../ for path with strange chars (eg $)
   18              0.000184         if i !~# '\/\.\.\/\?$' && i !~# '\/\.\/\?$'
                            
                                        "put the next file in a new node and attach it
   16              0.000020             try
   16   0.006285   0.000105                 let path = g:NERDTreePath.New(i)
   16   0.001139   0.000138                 call self.createChild(path, 0)
   16              0.000027             catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound += 1
                                        endtry
   16              0.000008         endif
   18              0.000016     endfor
                            
    1   0.011773   0.000004     call self.sortChildren()
                            
    1              0.000003     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo("Please wait, caching a large dir ... DONE (". self.getChildCount() ." nodes cached).")
                                endif
                            
    1              0.000001     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
                                endif
    1   0.000007   0.000004     return self.getChildCount()

FUNCTION  164()
Called 7 times
Total time:   0.000366
 Self time:   0.000366

count  total (s)   self (s)
    7              0.000014     if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
                                endif
                            
    7              0.000211     let newTreeNode = copy(self)
    7              0.000022     let newTreeNode.path = a:path
                            
    7              0.000015     let newTreeNode.isOpen = 0
    7              0.000019     let newTreeNode.children = []
                            
    7              0.000024     let newTreeNode.parent = {}
                            
    7              0.000015     return newTreeNode

FUNCTION  neocomplcache#variables#get_sources()
Called 14 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
   14              0.000076   if !exists('s:sources')
    1              0.000003     let s:sources = {}
    1              0.000001   endif
   14              0.000027   return s:sources

FUNCTION  <SNR>67_SanitizeMode()
Called 1 time
Total time:   0.000076
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000002     if s:SanitizeLock
                                    return
                                endif
    1              0.000002     let s:SanitizeLock = 1
                            
                                " First check the grep command
    1   0.000044   0.000006     if !s:CheckGrepCommandForChanges()
                                    let s:SanitizeLock = 0
                                    return
                                endif
                            
                                " Next ensure that our mode is sensible
    1              0.000003     if g:EasyGrepMode < 0 || g:EasyGrepMode >= s:EasyGrepNumModesWithSpecial
                                    call s:Error("Invalid value for g:EasyGrepMode; reverting to 'All' mode.")
                                    call s:ForceGrepMode(s:EasyGrepModeAll)
                                elseif g:EasyGrepMode == s:EasyGrepModeMultipleChoice
                                    " This is OK
                                elseif s:Dict[g:EasyGrepMode][2] != 1
                                    " The user switched the mode by explicitly setting the g:EasyGrepMode
                                    " global variable; make sure to sync up with it
                                    call s:ForceGrepMode(g:EasyGrepMode)
                                endif
                            
    1              0.000001     let s:SanitizeLock = 0

FUNCTION  <SNR>94_UpdateList()
Called 11 times
Total time:   0.000762
 Self time:   0.000762

count  total (s)   self (s)
                              " Function to update the window list with info about the current buffer
   11              0.000033   if !exists('w:BufKillList')
    2              0.000004     let w:BufKillList = []
    2              0.000001   endif
   11              0.000031   if !exists('w:BufKillColumnList')
    2              0.000003     let w:BufKillColumnList = []
    2              0.000001   endif
   11              0.000025   if !exists('w:BufKillIndex')
    2              0.000004     let w:BufKillIndex = -1
    2              0.000001   endif
   11              0.000028   if !exists('w:BufKillLastCmd')
    2              0.000004     let w:BufKillLastCmd = ''
    2              0.000001   endif
   11              0.000031   let bufferNum = bufnr('%')
                            
   11              0.000046   if (w:BufKillLastCmd=~'bufchange')
                                " When stepping through files, the w:BufKillList should not be changed
                                " here, only by the GotoBuffer command since the files must already
                                " exist in the list to jump to them.
                              else
                                " Increment index
   11              0.000022     let w:BufKillIndex += 1
   11              0.000028     if w:BufKillIndex < len(w:BufKillList)
                                  " The branch is diverging, remove the end of the list
                                  call remove(w:BufKillList, w:BufKillIndex, -1)
                                  " Same for column list
                                  if w:BufKillIndex < len(w:BufKillColumnList)
                                    call remove(w:BufKillColumnList, w:BufKillIndex, -1)
                                  endif
                                endif
                                " Now remove any pre-existing instances of the buffer in the list
   11              0.000038     let existingIndex = index(w:BufKillList, bufferNum)
   11              0.000016     if existingIndex != -1
    6              0.000018       call remove(w:BufKillList, existingIndex)
    6              0.000012       let w:BufKillIndex -= 1
    6              0.000018       if existingIndex < len(w:BufKillColumnList)
    2              0.000005         call remove(w:BufKillColumnList, existingIndex)
    2              0.000001       endif
    6              0.000003     endif
                                " Now add the buffer to the list, at the end
   11              0.000031     let w:BufKillList += [bufferNum]
   11              0.000006   endif
                            
                              " Reset since command processed
   11              0.000019   let w:BufKillLastCmd = ''
                            

FUNCTION  <SNR>72_closeTreeWindow()
Called 2 times
Total time:   0.025318
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000011     if b:NERDTreeType ==# "secondary" && b:NERDTreePreviousBuf != -1
                                    exec "buffer " . b:NERDTreePreviousBuf
                                else
    2              0.000006         if winnr("$") > 1
    2   0.025284   0.000012             call nerdtree#closeTree()
    2              0.000001         else
                                        call nerdtree#echo("Cannot close last window")
                                    endif
    2              0.000001     endif

FUNCTION  86()
Called 8 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    8              0.000028     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    8              0.000013     return s:keyMaps

FUNCTION  87()
Called 6 times
Total time:   0.001821
 Self time:   0.001767

count  total (s)   self (s)
  256   0.000367   0.000313     for i in s:KeyMap.All()
  252              0.000706          if i.key ==# a:key && i.scope ==# a:scope
    2              0.000003             return i
                                    endif
  250              0.000204     endfor
    4              0.000006     return {}

FUNCTION  88()
Called 2 times
Total time:   0.005009
 Self time:   0.000548

count  total (s)   self (s)
  102   0.000117   0.000104     for i in s:KeyMap.All()
  100   0.004781   0.000333         call i.bind()
  100              0.000078     endfor

FUNCTION  89()
Called 100 times
Total time:   0.004448
 Self time:   0.004448

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
  100              0.000211     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
  100              0.000697     if self.key =~# specialNotationRegex
   16              0.000206         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
   16              0.000011     else
   84              0.000139         let keymapInvokeString = self.key
   84              0.000051     endif
                            
  100              0.000212     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
  100              0.002288     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  <SNR>87_UsedMarks()
Called 10 times
Total time:   0.010914
 Self time:   0.000943

count  total (s)   self (s)
                              " Description: Returns a list of [mark, line no.] pairs that are in use in the current buffer
                            
   10   0.010860   0.000889   let l:return_var = filter(s:MarksList(), 'v:val[1]>0')
                            
   10              0.000023   return l:return_var

FUNCTION  <SNR>173__import()
Called 2 times
Total time:   0.018952
 Self time:   0.001348

count  total (s)   self (s)
    2              0.000006   if type(a:name) == type(0)
                                return s:_build_module(a:name)
                              endif
    2              0.000013   if a:name =~# '^[^A-Z]' || a:name =~# '\W[^A-Z]'
                                throw 'vital: module name must start with capital letter: ' . a:name
                              endif
    2              0.000010   let target = a:name ==# '' ? '' : '/' . substitute(a:name, '\W\+', '/', 'g')
    2              0.000013   let target = substitute(target, '\l\zs\ze\u', '_', 'g') " OrderedSet -> Ordered_Set
    2              0.000012   let target = substitute(target, '[/_]\zs\u', '\l\0', 'g') " Ordered_Set -> ordered_set
    2              0.000010   let tailpath = printf('autoload/vital/%s%s.vim', s:self_version, target)
                            
                              " Note: The extra argument to globpath() was added in Patch 7.2.051.
    2              0.000005   if v:version > 702 || v:version == 702 && has('patch51')
    2              0.000732     let paths = split(globpath(&runtimepath, tailpath, 1), "\n")
    2              0.000002   else
                                let paths = split(globpath(&runtimepath, tailpath), "\n")
                              endif
    2   0.000086   0.000014   let path = s:_unify_path(get(paths, 0, ''))
    2              0.000006   let sid = get(a:scripts, path, 0)
    2              0.000002   if !sid
    1              0.000001     try
    1   0.001468   0.000436       execute 'source' fnameescape(path)
    1              0.000001     catch /^Vim\%((\a\+)\)\?:E484/
                                  throw 'vital: module not found: ' . a:name
                                catch /^Vim\%((\a\+)\)\?:E127/
                                  " Ignore.
                                endtry
                            
    1              0.000005     let sid = len(a:scripts) + 1  " We expect that the file newly read is +1.
    1              0.000008     let a:scripts[path] = sid
    1              0.000001   endif
    2   0.016527   0.000027   return s:_build_module(sid)

FUNCTION  173()
Called 2 times
Total time:   0.012065
 Self time:   0.000101

count  total (s)   self (s)
    2   0.000390   0.000010     if !a:path.isUnder(self.path)
                                    throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
                                endif
                            
    2   0.000044   0.000010     call self.open()
                            
    2   0.000922   0.000037     if self.path.equals(a:path.getParent())
    2   0.002265   0.000009         let n = self.findNode(a:path)
    2   0.006827   0.000009         call nerdtree#renderView()
    2   0.001600   0.000009         call n.putCursorHere(1,0)
    2              0.000001         return
                                endif
                            
                                let p = a:path
                                while !p.getParent().equals(self.path)
                                    let p = p.getParent()
                                endwhile
                            
                                let n = self.findNode(p)
                                call n.reveal(a:path)

FUNCTION  310()
Called 2 times
Total time:   0.001976
 Self time:   0.000570

count  total (s)   self (s)
    2              0.000008   if empty(self.candidates)
                                " nothing to save, mru is not loaded
    1              0.000002     return
                              endif
                            
    1              0.000003   let opts = {}
    1   0.000013   0.000008   if a:0 >= 1 && s:V.is_dict(a:1)
    1              0.000004     call extend(opts, a:1)
    1              0.000001   endif
                            
                              " should load all candidates
    1              0.000002   if self.is_loaded < 2
    1   0.000046   0.000008     call self.load()
    1              0.000001   endif
                            
    1   0.000030   0.000011   if self.has_external_update() && filereadable(self.mru_file.short)
                                " only need to get the short list which contains the latest MRUs
                                let [ver; items] = readfile(self.mru_file.short)
                                if self.version_check(ver)
                                  call extend(self.candidates, s:convert2candidates(items))
                                  let self.candidates = s:uniq_sort(self.candidates)
                                endif
                              endif
                            
    1              0.000006   if get(opts, 'event') ==# 'VimLeavePre'
    1   0.000259   0.000008     call self.validate()
    1              0.000001   endif
                            
    1   0.001036   0.000040   let self.candidates = s:L.uniq(self.candidates, 'v:val.action__path')
                            
    1   0.000493   0.000396   call writefile([self.version] + map(copy( self.candidates[: self.limit.short - 1]), 'join(s:convert2list(v:val), "\t")'), self.mru_file.short)
                            
    1              0.000006   if len(self.candidates) > self.limit.short
                                call writefile([self.version] + map(copy( self.candidates[self.limit.short : self.limit.long - 1]), 'join(s:convert2list(v:val), "\t")'), self.mru_file.long)
                                let self.mtime = getftime(self.mru_file.long)
                              else
    1              0.000010     let self.mtime = getftime(self.mru_file.short)
    1              0.000001   endif

FUNCTION  <SNR>148__scripts()
Called 15 times
Total time:   0.143676
 Self time:   0.062147

count  total (s)   self (s)
   15              0.000034   let scripts = {}
 2313   0.010586   0.005404   for line in split(s:_redir('scriptnames'), "\n")
 2298              0.025451     let list = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
 2298              0.004262     if !empty(list)
 2298   0.092791   0.016444       let scripts[s:_unify_path(list[2])] = list[1] - 0
 2298              0.002054     endif
 2298              0.007094   endfor
   15              0.000018   return scripts

FUNCTION  nerdtree#echo()
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000006     redraw
    1              0.000034     echomsg "NERDTree: " . a:msg

FUNCTION  <SNR>151__vital_depends()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return ['Data.List']

FUNCTION  neocomplcache#util#convert2list()
Called 13 times
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
   13              0.000098   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  175()
Called 1 time
Total time:   0.011769
 Self time:   0.000119

count  total (s)   self (s)
    1              0.000005     let CompareFunc = function("nerdtree#compareNodes")
    1   0.011763   0.000113     call sort(self.children, CompareFunc)

FUNCTION  91()
Called 2 times
Total time:   0.025363
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000017     let Callback = function(self.callback)
    2              0.000004     if a:0
                                    call Callback(a:1)
                                else
    2   0.025329   0.000011         call Callback()
    2              0.000002     endif

FUNCTION  92()
Called 2 times
Total time:   0.035880
 Self time:   0.000266

count  total (s)   self (s)
    2   0.008429   0.000069     let node = g:NERDTreeFileNode.GetSelected()
    2              0.000006     if !empty(node)
                            
                                    "try file node
    2              0.000004         if !node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "FileNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
    2              0.000003         if node.path.isDirectory
    2   0.000761   0.000021             let km = s:KeyMap.FindFor(a:key, "DirNode")
    2              0.000006             if !empty(km)
                                            return km.invoke(node)
                                        endif
    2              0.000002         endif
                            
                                    "try generic node
    2   0.000722   0.000019         let km = s:KeyMap.FindFor(a:key, "Node")
    2              0.000006         if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
    2              0.000002     endif
                            
                                "try bookmark
    2   0.000086   0.000016     let bm = g:NERDTreeBookmark.GetSelected()
    2              0.000006     if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
    2   0.000393   0.000015     let km = s:KeyMap.FindFor(a:key, "all")
    2              0.000005     if !empty(km)
    2   0.025374   0.000011         return km.invoke()
                                endif

FUNCTION  97()
Called 18 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
   18              0.000051     if !exists("g:NERDTreeBookmarks")
    1              0.000004         let g:NERDTreeBookmarks = []
    1              0.000002     endif
   18              0.000020     return g:NERDTreeBookmarks

FUNCTION  98()
Called 1 time
Total time:   0.000082
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000002     try
    1   0.000056   0.000009         call s:Bookmark.BookmarkFor(a:name)
                                    return 1
                                catch /^NERDTree.BookmarkNotFoundError/
    1              0.000003         return 0
                                endtry

FUNCTION  99()
Called 1 time
Total time:   0.000047
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000030   0.000010     for i in s:Bookmark.Bookmarks()
                                    if i.name ==# a:name
                                        return i
                                    endif
                                endfor
                                throw "NERDTree.BookmarkNotFoundError: no bookmark found for name: \"". a:name  .'"'

FUNCTION  <SNR>48_sub()
Called 28 times
Total time:   0.000394
 Self time:   0.000394

count  total (s)   self (s)
   28              0.000370   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  <SNR>173_load()
Called 1 time
Total time:   0.020992
 Self time:   0.000103

count  total (s)   self (s)
    1   0.010621   0.000008   let scripts = s:_scripts()
    2              0.000004   for arg in a:000
    1              0.000007     let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
    1              0.000006     let target = split(join(as, ''), '\W\+')
    1              0.000002     let dict = self
    1              0.000002     while 1 <= len(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == type({})
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                            
    1              0.000002     if exists('dict')
    1   0.010301   0.000025       call extend(dict, s:_import(name, scripts))
    1              0.000001     endif
    1              0.000001     unlet arg
    1              0.000004   endfor
    1              0.000001   return self

FUNCTION  neocomplcache#sources#jscomplete#define()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007   return s:source

FUNCTION  unite#_on_cursor_hold()
Called 3 times
Total time:   0.000212
 Self time:   0.000190

count  total (s)   self (s)
    3              0.000008   let is_async = 0
                            
    3   0.000042   0.000020   call s:restore_statusline()
                            
    3              0.000005   if &filetype ==# 'unite'
                                " Redraw.
                                call unite#redraw()
                                call s:change_highlight()
                            
                                let unite = unite#get_current_unite()
                                let is_async = unite.is_async
                            
                                if !unite.is_async && unite.context.auto_quit
                                  call unite#force_quit_session()
                                endif
                              else
                                " Search other unite window.
    3              0.000036     for winnr in filter(range(1, winnr('$')), "getbufvar(winbufnr(v:val), '&filetype') ==# 'unite'")
                                  let unite = getbufvar(winbufnr(winnr), 'unite')
                                  if unite.is_async
                                    " Redraw unite buffer.
                                    call unite#redraw(winnr)
                            
                                    let is_async = unite.is_async
                                  endif
                                endfor
    3              0.000001   endif
                            
    3              0.000003   if is_async
                                " Ignore key sequences.
                                call feedkeys("g\<ESC>", 'n')
                              endif

FUNCTION  <SNR>46_shellslash()
Called 3 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    3              0.000017   if exists('+shellslash') && !&shellslash
                                return s:gsub(a:path,'\\','/')
                              else
    3              0.000007     return a:path
                              endif

FUNCTION  editorconfig#ApplyHooks()
Called 1 time
Total time:   0.000107
 Self time:   0.000047

count  total (s)   self (s)
                                " apply hooks
                            
    2              0.000009     for Hook in s:hook_list
    1   0.000072   0.000012         let l:hook_ret = Hook(a:config)
                            
    1              0.000006         if type(l:hook_ret) != type(0) && l:hook_ret != 0
                                        " TODO print some debug info here
                                    endif
    1              0.000002     endfor

FUNCTION  190()
Called 2 times
Total time:   0.005301
 Self time:   0.000292

count  total (s)   self (s)
                                "make <cr> do the same as the default 'o' mapping
    2              0.000055     exec "nnoremap <silent> <buffer> <cr> :call nerdtree#invokeKeyMap('". g:NERDTreeMapActivateNode ."')<cr>"
                            
    2   0.005017   0.000008     call g:NERDTreeKeyMap.BindAll()
                            
    2              0.000026     command! -buffer -nargs=? Bookmark :call nerdtree#bookmarkNode('<args>')
    2              0.000028     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#revealBookmark('<args>')
    2              0.000024     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark :call nerdtree#openBookmark('<args>')
    2              0.000025     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#clearBookmarks('<args>')
    2              0.000026     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>')
    2              0.000036     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call nerdtree#renderView()
    2              0.000038     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call nerdtree#renderView()
    2              0.000019     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()

FUNCTION  191()
Called 1 time
Total time:   0.000667
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000666   0.000034     silent doautocmd User NERDTreeInit

FUNCTION  192()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return 'NERD_tree_'

FUNCTION  194()
Called 1 time
Total time:   0.206483
 Self time:   0.000096

count  total (s)   self (s)
    1   0.000710   0.000010     let path = self._pathForString(a:name)
                            
                                "if instructed to, then change the vim CWD to the dir the NERDTree is
                                "inited in
    1              0.000003     if g:NERDTreeChDirMode != 0
                                    call path.changeToDir()
                                endif
                            
    1   0.000017   0.000010     if nerdtree#treeExistsForTab()
                                    if nerdtree#isTreeOpen()
                                        call nerdtree#closeTree()
                                    endif
                                    unlet t:NERDTreeBufName
                                endif
                            
    1   0.000090   0.000011     let newRoot = g:NERDTreeDirNode.New(path)
    1   0.020496   0.000007     call newRoot.open()
                            
    1   0.180162   0.000005     call self._createTreeWin()
    1              0.000002     let b:treeShowHelp = 0
    1              0.000002     let b:NERDTreeIgnoreEnabled = 1
    1              0.000002     let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    1              0.000001     let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    1              0.000001     let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    1              0.000001     let b:NERDTreeRoot = newRoot
    1              0.000001     let b:NERDTreeType = "primary"
                            
    1   0.004027   0.000005     call nerdtree#renderView()
    1   0.000271   0.000005     call b:NERDTreeRoot.putCursorHere(0, 0)
                            
    1   0.000671   0.000004     call self._broadcastInitEvent()

FUNCTION  199()
Called 2 times
Total time:   0.258788
 Self time:   0.000994

count  total (s)   self (s)
                                "create the nerd tree window
    2              0.000010     let splitLocation = g:NERDTreeWinPos ==# "left" ? "topleft " : "botright "
    2              0.000004     let splitSize = g:NERDTreeWinSize
                            
    2              0.000008     if !exists('t:NERDTreeBufName')
    1   0.000025   0.000005         let t:NERDTreeBufName = self._nextBufferName()
    1   0.017238   0.000217         silent! exec splitLocation . 'vertical ' . splitSize . ' new'
    1   0.088224   0.000570         silent! exec "edit " . t:NERDTreeBufName
    1              0.000001     else
    1   0.004229   0.000090         silent! exec splitLocation . 'vertical ' . splitSize . ' split'
    1   0.011822   0.000048         silent! exec "buffer " . t:NERDTreeBufName
    1              0.000001     endif
                            
    2              0.000006     setlocal winfixwidth
    2   0.137196   0.000010     call self._setCommonBufOptions()

FUNCTION  nerdtree#invokeKeyMap()
Called 2 times
Total time:   0.035924
 Self time:   0.000044

count  total (s)   self (s)
    2   0.035918   0.000038     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  neocomplcache#commands#_initialize()
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000020   command! -nargs=? Neco call s:display_neco(<q-args>)
    1              0.000019   command! -nargs=1 NeoComplCacheAutoCompletionLength call s:set_auto_completion_length(<args>)

FUNCTION  vimproc#version()
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000027   return str2nr(printf('%2d%02d', 7, 1))

FUNCTION  neocomplcache#sources#filename_complete#define()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return s:source

FUNCTION  fugitive#extract_git_dir()
Called 2 times
Total time:   0.001912
 Self time:   0.001203

count  total (s)   self (s)
    2   0.000056   0.000030   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    2   0.000106   0.000080   let root = s:shellslash(simplify(fnamemodify(a:path, ':p:s?[\/]$??')))
    2              0.000006   let previous = ""
   16              0.000051   while root !=# previous
   14   0.000331   0.000120     let dir = s:sub(root, '[\/]$', '') . '/.git'
   14              0.000105     let type = getftype(dir)
   14              0.000053     if type ==# 'dir' && fugitive#is_git_dir(dir)
                                  return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
   14              0.000035     let previous = root
   14              0.000067     let root = fnamemodify(root, ':h')
   14              0.000055   endwhile
    2              0.000002   return ''

FUNCTION  neocomplcache#get_temporary_directory()
Called 4 times
Total time:   0.000450
 Self time:   0.000182

count  total (s)   self (s)
    4   0.000365   0.000097   let directory = neocomplcache#util#substitute_path_separator( neocomplcache#util#expand(g:neocomplcache_temporary_dir))
    4              0.000040   if !isdirectory(directory)
                                call mkdir(directory, 'p')
                              endif
                            
    4              0.000009   return directory

FUNCTION  signature#BufferMaps()
Called 9 times
Total time:   0.111469
 Self time:   0.028414

count  total (s)   self (s)
                              " Description: Set up mappings
                              " Arguments:   When mode = 0, disable mappings.
                              "                   mode = 1, enable  mappings.
                            
                              " To prevent maps from being called again when re-entering a buffer
    9              0.000046   if !exists('b:sig_map_set') | let b:sig_map_set = 0  | endif
                            
    9              0.000017   if ( a:mode && !b:sig_map_set ) "                   {{{
                            
                                " Create maps for marks a-z, A-Z
  265              0.000539     for i in split( g:SignatureIncludeMarks, '\zs' )
  260              0.003296       if maparg( g:SignatureMarkLeader . i, 'n' ) == ""
  260              0.007393         silent exec 'nnoremap <buffer> <unique> <silent> ' . g:SignatureMarkLeader . i . ' :call signature#ToggleMark("' . i . '")<CR>'
  260              0.000244       endif
  260              0.000232     endfor
                            
                                " Create maps for markers !@#$%^&*()
    5              0.000084     let s:signature_markers = split(g:SignatureIncludeMarkers, '\zs')
   55              0.000125     for i in range(0, len(s:signature_markers)-1)
   50              0.000779       if maparg( g:SignatureMarkerLeader . i, 'n' ) == ""
   50              0.000628         exec 'sign define sig_Marker_' . i . ' text=' . s:signature_markers[i] . ' texthl=WarningMsg'
   50              0.001778         silent exec 'nnoremap <buffer> <unique> <silent>' . g:SignatureMarkerLeader . i . ' :call signature#ToggleMarker("' . s:signature_markers[i] . '")<CR>'
   50              0.001780         silent exec 'nnoremap <buffer> <unique> <silent>' . g:SignatureMarkerLeader . s:signature_markers[i] . ' :call signature#RemoveMarker("' . s:signature_markers[i] . '")<CR>'
   50              0.000062       endif
   50              0.000061     endfor
                            
                                " Using hasmapto() allows a flexibility to use custom mappings along with the default mappings.
                                " Similarly, maparg() is used to ensure that mapping is created only if it is free
                                " Thus, using both, we ensure that mapping is done only if RHS (<Plug>) is unmapped and LHS is unassigned
                            
    5              0.000417     if !hasmapto( '<Plug>SIG_PlaceNextMark' ) && maparg( g:SignatureMarkerLeader . ',', 'n' ) == ""
    5              0.000133       exec 'nmap <buffer> ' . g:SignatureMarkLeader . ', <Plug>SIG_PlaceNextMark'
    5              0.000006     endif
    5              0.000387     if !hasmapto( '<Plug>SIG_PurgeMarks' ) && maparg( g:SignatureMarkerLeader . '<Space>', 'n' ) == ""
    5              0.000122       exec 'nmap <buffer> ' . g:SignatureMarkLeader . '<Space> <Plug>SIG_PurgeMarks'
    5              0.000004     endif
    5              0.000395     if !hasmapto( '<Plug>SIG_PurgeMarkers' ) && maparg( g:SignatureMarkerLeader . '<BS>', 'n' ) == ""
    5              0.000125       exec 'nmap <buffer> ' . g:SignatureMarkerLeader . '<BS> <Plug>SIG_PurgeMarkers'
    5              0.000006     endif
                            
    5              0.000392     if !hasmapto( '<Plug>SIG_NextLineByAlpha' ) && maparg( "']", 'n' ) == ""
    5              0.000113       nmap <buffer> '] <Plug>SIG_NextLineByAlpha
    5              0.000005     endif
    5              0.000392     if !hasmapto( '<Plug>SIG_PrevLineByAlpha' ) && maparg( "'[", 'n' ) == ""
    5              0.000102       nmap <buffer> '[ <Plug>SIG_PrevLineByAlpha
    5              0.000004     endif
    5              0.000382     if !hasmapto( '<Plug>SIG_NextSpotByAlpha' ) && maparg( "`]", 'n' ) == ""
    5              0.000094       nmap <buffer> `] <Plug>SIG_NextSpotByAlpha
    5              0.000005     endif
    5              0.000361     if !hasmapto( '<Plug>SIG_PrevSpotByAlpha' ) && maparg( "`[", 'n' ) == ""
    5              0.000093       nmap <buffer> `[ <Plug>SIG_PrevSpotByAlpha
    5              0.000005     endif
    5              0.000361     if !hasmapto( '<Plug>SIG_NextLineByPos' ) && maparg( "]'", 'n' ) == ""
    5              0.000090       nmap <buffer> ]' <Plug>SIG_NextLineByPos
    5              0.000004     endif
    5              0.000364     if !hasmapto( '<Plug>SIG_PrevLineByPos' ) && maparg( "['", 'n' ) == ""
    5              0.000088       nmap <buffer> [' <Plug>SIG_PrevLineByPos
    5              0.000002     endif
    5              0.000359     if !hasmapto( '<Plug>SIG_NextSpotByPos') && maparg( "]`", 'n' ) == ""
    5              0.000095       nmap <buffer> ]` <Plug>SIG_NextSpotByPos
    5              0.000006     endif
    5              0.000378     if !hasmapto( '<Plug>SIG_PrevSpotByPos' ) && maparg( "[`", 'n' ) == ""
    5              0.000091       nmap <buffer> [` <Plug>SIG_PrevSpotByPos
    5              0.000003     endif
    5              0.000368     if !hasmapto( '<Plug>SIG_NextMarkerByType' ) && maparg( "]-", 'n' ) == ""
    5              0.000106       nmap <buffer> ]- <Plug>SIG_NextMarkerByType
    5              0.000004     endif
    5              0.000375     if !hasmapto( '<Plug>SIG_PrevMarkerByType' ) && maparg( "[-", 'n' ) == ""
    5              0.000096       nmap <buffer> [- <Plug>SIG_PrevMarkerByType
    5              0.000002     endif
                            
                                "TODO Call SignRefresh after performing any action that affects marks to adjust the corresponding signs
                                "nnoremap dd dd:call signature#SignRefresh()<CR>
                                "vnoremap d   d:call signature#SignRefresh()<CR>
                                "nnoremap u   u:call signature#SignRefresh()<CR>
                                "nnoremap U   U:call signature#SignRefresh()<CR>
                                "nnoremap J   J:call signature#SignRefresh()<CR>
                            
    5              0.000014     let b:sig_map_set = 1
                            
                              " }}}
    5              0.000010   elseif ( a:mode == 0 && b:sig_map_set ) "           {{{
                                " Remove mappings
                            
  106              0.000185     for i in split(g:SignatureIncludeMarks, '\zs')
  104              0.000832       silent exec 'nunmap <buffer> <silent> ' . g:SignatureMarkLeader . i
  104              0.000092     endfor
                            
    2              0.000026     let s:signature_markers = split(g:SignatureIncludeMarkers, '\zs')
   22              0.000030     for i in range(0, len(s:signature_markers)-1)
   20              0.000145       silent exec 'nunmap <buffer> ' . g:SignatureMarkerLeader . i
   20              0.000149       silent exec 'nunmap <buffer> ' . g:SignatureMarkerLeader . s:signature_markers[i]
   20              0.000019     endfor
                            
    2              0.000114     if hasmapto( '<Plug>SIG_PlaceNextMark' )
    2   0.007630   0.000030       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PlaceNextMark', 'n' )
    2              0.000001     endif
    2              0.000094     if hasmapto( '<Plug>SIG_PurgeMarks' )
    2   0.007201   0.000033       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PurgeMarks', 'n' )
    2              0.000002     endif
    2              0.000108     if hasmapto( '<Plug>SIG_PurgeMarkers' )
    2   0.007162   0.000032       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PurgeMarkers', 'n' )
    2              0.000000     endif
    2              0.000095     if hasmapto( '<Plug>SIG_NextLineByAlpha'  )
    2   0.005685   0.000036       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_NextLineByAlpha' , 'n' )
    2              0.000002     endif
    2              0.000107     if hasmapto( '<Plug>SIG_PrevLineByAlpha'  )
    2   0.005824   0.000035       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PrevLineByAlpha' , 'n' )
    2              0.000001     endif
    2              0.000094     if hasmapto( '<Plug>SIG_NextSpotByAlpha'  )
    2   0.006659   0.000032       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_NextSpotByAlpha' , 'n' )
    2              0.000001     endif
    2              0.000109     if hasmapto( '<Plug>SIG_PrevSpotByAlpha'  )
    2   0.006459   0.000029       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PrevSpotByAlpha' , 'n' )
    2              0.000001     endif
    2              0.000094     if hasmapto( '<Plug>SIG_NextLineByPos'  )
    2   0.006244   0.000030       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_NextLineByPos'   , 'n' )
    2              0.000001     endif
    2              0.000093     if hasmapto( '<Plug>SIG_PrevLineByPos'  )
    2   0.006353   0.000028       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PrevLineByPos'   , 'n' )
    2              0.000000     endif
    2              0.000094     if hasmapto( '<Plug>SIG_NextSpotByPos'  )
    2   0.006109   0.000030       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_NextSpotByPos'   , 'n' )
    2              0.000002     endif
    2              0.000093     if hasmapto( '<Plug>SIG_PrevSpotByPos'  )
    2   0.006046   0.000029       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PrevSpotByPos'   , 'n' )
    2              0.000002     endif
    2              0.000095     if hasmapto( '<Plug>SIG_NextMarkerByType' )
    2   0.006098   0.000029       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_NextMarkerByType', 'n' )
    2              0.000001     endif
    2              0.000096     if hasmapto( '<Plug>SIG_PrevMarkerByType' )
    2   0.005986   0.000028       exec 'nunmap <buffer> ' . signature#MapKey( '<Plug>SIG_PrevMarkerByType', 'n' )
    2              0.000002     endif
                            
    2              0.000004     let b:sig_map_set = 0
                            
    2              0.000002   endif " }}}

FUNCTION  neocomplcache#get_current_neocomplcache()
Called 14 times
Total time:   0.000298
 Self time:   0.000221

count  total (s)   self (s)
   14              0.000073   if !exists('b:neocomplcache')
    1   0.000095   0.000018     call neocomplcache#init#_current_neocomplcache()
    1              0.000002   endif
                            
   14              0.000031   return b:neocomplcache

FUNCTION  <SNR>149_is_windows()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   return s:is_windows

FUNCTION  nerdtree#treeWid()
Called 12 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
   12              0.000022     return 2

FUNCTION  <SNR>148__build_module()
Called 15 times
Total time:   0.066881
 Self time:   0.053703

count  total (s)   self (s)
   15              0.000050   if has_key(s:loaded, a:sid)
   11              0.000097     return copy(s:loaded[a:sid])
                              endif
    4              0.000016   let prefix = '<SNR>' . a:sid . '_'
    4   0.004600   0.000028   let funcs = s:_redir('function')
    4              0.000012   let filter_pat = '^\s*function ' . prefix
    4              0.000010   let map_pat = prefix . '\zs\w\+'
    4              0.023127   let functions = map(filter(split(funcs, "\n"), 'v:val =~# filter_pat'),          'matchstr(v:val, map_pat)')
                            
    4              0.000013   let module = {}
   98              0.000083   for func in functions
   94              0.000352     let module[func] = function(prefix . func)
   94              0.000076   endfor
    4              0.000011   if has_key(module, '_vital_loaded')
    1              0.009532     let V = vital#{s:self_version}#new()
    1              0.000003     if has_key(module, '_vital_depends')
    1   0.009380   0.009378       call call(V.load, module._vital_depends(), V)
    1              0.000001     endif
    1              0.000001     try
    1              0.009523       call module._vital_loaded(V)
    1              0.000001     catch
                                  " FIXME: Show an error message for debug.
                                endtry
    1              0.000001   endif
    4              0.000011   if !get(g:, 'vital_debug', 0)
    4              0.000178     call filter(module, 'v:key =~# "^\\a"')
    4              0.000004   endif
    4              0.000018   let s:loaded[a:sid] = module
    4              0.000029   return copy(module)

FUNCTION  neocomplcache#sources#omni_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  <SNR>136_is_dict()
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000010   return type(a:Value) ==# s:__TYPE_DICT

FUNCTION  nerdtree#runningWindows()
Called 335 times
Total time:   0.003238
 Self time:   0.003238

count  total (s)   self (s)
  335              0.003020     return has("win16") || has("win32") || has("win64")

FUNCTION  neocomplcache#util#is_windows()
Called 1 time
Total time:   0.000015
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000014   0.000010   return call(s:V.is_windows, a:000)

FUNCTION  <SNR>140_convert2dictionary()
Called 7 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    7              0.000055   return { 'word' : a:list[0], 'source__time' : str2nr(a:list[1]), 'action__path' : a:list[0], }

FUNCTION  neobundle#autoload#function()
Called 25 times
Total time:   0.005683
 Self time:   0.001413

count  total (s)   self (s)
   25              0.000196   let function = expand('<amatch>')
   25              0.000455   let function_prefix = get(split(function, '#'), 0, '') . '#'
                            
   25   0.004424   0.000462   let bundles = filter(neobundle#config#get_autoload_bundles(), "get(v:val.autoload, 'function_prefix', '').'#' ==# function_prefix ||  (has_key(v:val.autoload, 'functions') &&    index(neobundle#util#convert2list(     v:val.autoload.functions), function) >= 0)")
   25   0.000525   0.000217   call neobundle#config#source_bundles(bundles)

FUNCTION  <SNR>164_split()
Called 3 times
Total time:   0.000281
 Self time:   0.000281

count  total (s)   self (s)
    3              0.000029   let [result, pos] = [[], 0]
    5              0.000016   while 1
    5              0.000043     let tmp = stridx(a:str, a:sep, pos)
    5              0.000018     if tmp == -1
    3              0.000032       call add(result, strpart(a:str, pos))
    3              0.000009       break
                                endif
    2              0.000026     call add(result, strpart(a:str, pos, tmp - pos))
    2              0.000010     let pos = tmp + 1
    2              0.000005   endwhile
                            
    3              0.000009   return result

FUNCTION  indent_guides#indent_highlight_pattern()
Called 780 times
Total time:   0.011288
 Self time:   0.011288

count  total (s)   self (s)
  780              0.003687   let l:pattern  = '^' . a:indent_pattern . '*\%' . a:column_start . 'v\zs'
  780              0.004122   let l:pattern .= a:indent_pattern . '*\%' . (a:column_start + a:indent_size) . 'v'
  780              0.001723   let l:pattern .= '\ze'
  780              0.000951   return l:pattern

FUNCTION  342()
Called 1 time
Total time:   0.000477
 Self time:   0.000077

count  total (s)   self (s)
                              " Initialize.
                            
                              " Initialize filename include expr. "{{{
    1              0.000010   let g:neocomplcache_filename_include_exprs = get(g:, 'neocomplcache_filename_include_exprs', {})
    1   0.000082   0.000011   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exprs', 'perl', 'fnamemodify(substitute(v:fname, "/", "::", "g"), ":r")')
    1   0.000111   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exprs', 'ruby,python,java,d', 'fnamemodify(substitute(v:fname, "/", ".", "g"), ":r")')
                              "}}}
                            
                              " Initialize filename include extensions. "{{{
    1              0.000007   let g:neocomplcache_filename_include_exts = get(g:, 'neocomplcache_filename_include_exts', {})
    1   0.000068   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'c', ['h'])
    1   0.000066   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'cpp', ['', 'h', 'hpp', 'hxx'])
    1   0.000065   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'perl', ['pm'])
    1   0.000062   0.000007   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'java', ['java'])
                              "}}}

FUNCTION  <SNR>173__unify_path()
Called 348 times
Total time:   0.013555
 Self time:   0.013555

count  total (s)   self (s)
                                " Note: On windows, vim can't expand path names from 8.3 formats.
                                " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                                " vital load duplicated scripts. Below's :~ avoid this issue.
  348              0.012862     return tolower(fnamemodify(resolve(fnamemodify(              a:path, ':p:gs?[\\/]\+?/?')), ':~'))

FUNCTION  neocomplcache#sources#include_complete#define()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:source

FUNCTION  fugitive#is_git_dir()
Called 14 times
Total time:   0.000446
 Self time:   0.000263

count  total (s)   self (s)
   14   0.000301   0.000118   let path = s:sub(a:path, '[\/]$', '') . '/'
   14              0.000135   return isdirectory(path.'objects') && isdirectory(path.'refs') && getfsize(path.'HEAD') > 10

FUNCTION  neocomplcache#get_keyword_pattern()
Called 1 time
Total time:   0.000143
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000007   let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
                            
    1   0.000135   0.000011   return neocomplcache#helper#unite_patterns( g:neocomplcache_keyword_patterns, filetype)

FUNCTION  <SNR>176_lash()
Called 3 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    3              0.000051 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  unite#util#substitute_path_separator()
Called 21 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
   21              0.000038     return a:path

FUNCTION  unite#sources#buffer#_append()
Called 12 times
Total time:   0.000664
 Self time:   0.000664

count  total (s)   self (s)
                              " Append the current buffer.
   12              0.000032   let bufnr = bufnr('%')
   12              0.000086   let s:buffer_list[bufnr] = { 'action__buffer_nr' : bufnr, 'source__time' : localtime(), }
                            
   12              0.000040   if !exists('t:unite_buffer_dictionary')
                                let t:unite_buffer_dictionary = {}
                              endif
                            
   12              0.000031   if exists('*gettabvar')
                                " Delete same buffer in other tab pages.
   24              0.000060     for tabnr in range(1, tabpagenr('$'))
   12              0.000042       let buffer_dict = gettabvar(tabnr, 'unite_buffer_dictionary')
   12              0.000059       if type(buffer_dict) == type({}) && has_key(buffer_dict, bufnr)
   10              0.000030         call remove(buffer_dict, bufnr)
   10              0.000005       endif
   12              0.000015       unlet buffer_dict
   12              0.000007     endfor
   12              0.000006   endif
                            
   12              0.000040   let t:unite_buffer_dictionary[bufnr] = 1

FUNCTION  neocomplcache#get_source_filetypes()
Called 1 time
Total time:   0.002091
 Self time:   0.000594

count  total (s)   self (s)
    1   0.002090   0.000593   return neocomplcache#helper#get_source_filetypes(a:filetype)

FUNCTION  neocomplcache#sources#dictionary_complete#define()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   return s:source

FUNCTION  neocomplcache#init#_autocmds()
Called 1 time
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    1              0.000004   augroup neocomplcache
    1              0.000116     autocmd!
    1              0.000016     autocmd InsertEnter * call neocomplcache#handler#_on_insert_enter()
    1              0.000008     autocmd InsertLeave * call neocomplcache#handler#_on_insert_leave()
    1              0.000006     autocmd CursorMovedI * call neocomplcache#handler#_on_moved_i()
    1              0.000006     autocmd BufWritePost * call neocomplcache#handler#_on_write_post()
    1              0.000002   augroup END
                            
    1              0.000007   if g:neocomplcache_enable_insert_char_pre && (v:version > 703 || v:version == 703 && has('patch418'))
                                autocmd neocomplcache InsertCharPre * call neocomplcache#handler#_do_auto_complete('InsertCharPre')
                              elseif g:neocomplcache_enable_cursor_hold_i
                                augroup neocomplcache
                                  autocmd CursorHoldI * call neocomplcache#handler#_do_auto_complete('CursorHoldI')
                                  autocmd InsertEnter * call neocomplcache#handler#_change_update_time()
                                  autocmd InsertLeave * call neocomplcache#handler#_restore_update_time()
                                augroup END
                              else
    1              0.000004     autocmd neocomplcache CursorMovedI * call neocomplcache#handler#_do_auto_complete('CursorMovedI')
    1              0.000001   endif
                            
    1              0.000011   if (v:version > 703 || v:version == 703 && has('patch598'))
                                autocmd neocomplcache CompleteDone * call neocomplcache#handler#_on_complete_done()
                              endif

FUNCTION  indent_guides#process_autocmds()
Called 13 times
Total time:   0.039986
 Self time:   0.000158

count  total (s)   self (s)
   13              0.000034   if g:indent_guides_autocmds_enabled
   13   0.039894   0.000066     call indent_guides#enable()
   13              0.000010   else
                                call indent_guides#disable()
                              end

FUNCTION  205()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000004     if g:NERDTreeStatusline != -1
    2              0.000008         let &l:statusline = g:NERDTreeStatusline
    2              0.000001     endif

FUNCTION  ctrlp#utils#opts()
Called 1 time
Total time:   0.000262
 Self time:   0.000179

count  total (s)   self (s)
    1   0.000062   0.000034 	let s:lash = ctrlp#utils#lash()
    1   0.000048   0.000023 	let usrhome = $HOME . s:lash( $HOME )
    1              0.000011 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    1   0.000057   0.000043 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    1              0.000006 	if exists('g:ctrlp_cache_dir')
    1              0.000023 		let cadir = expand(g:ctrlp_cache_dir, 1)
    1   0.000039   0.000023 		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
    1              0.000001 	en
    1              0.000004 	let s:cache_dir = cadir

FUNCTION  vimproc#util#is_mac()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000014   return s:is_mac

FUNCTION  nerdtree#treeExistsForTab()
Called 5 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    5              0.000035     return exists("t:NERDTreeBufName")

FUNCTION  nerdtree#isTreeOpen()
Called 8 times
Total time:   0.000239
 Self time:   0.000048

count  total (s)   self (s)
    8   0.000234   0.000043     return nerdtree#getTreeWinNum() != -1

FUNCTION  vimproc#util#is_cygwin()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   return s:is_cygwin

FUNCTION  <SNR>173__build_module()
Called 2 times
Total time:   0.016500
 Self time:   0.013475

count  total (s)   self (s)
    2              0.000006   if has_key(s:loaded, a:sid)
                                return copy(s:loaded[a:sid])
                              endif
    2              0.000007   let prefix = '<SNR>' . a:sid . '_'
    2   0.003036   0.000011   let funcs = s:_redir('function')
    2              0.000007   let filter_pat = '^\s*function ' . prefix
    2              0.000004   let map_pat = prefix . '\zs\w\+'
    2              0.013005   let functions = map(filter(split(funcs, "\n"), 'v:val =~# filter_pat'),          'matchstr(v:val, map_pat)')
                            
    2              0.000006   let module = {}
   46              0.000036   for func in functions
   44              0.000170     let module[func] = function(prefix . func)
   44              0.000044   endfor
    2              0.000005   if has_key(module, '_vital_loaded')
                                let V = vital#{s:self_version}#new()
                                if has_key(module, '_vital_depends')
                                  call call(V.load, module._vital_depends(), V)
                                endif
                                try
                                  call module._vital_loaded(V)
                                catch
                                  " FIXME: Show an error message for debug.
                                endtry
                              endif
    2              0.000005   if !get(g:, 'vital_debug', 0)
    2              0.000085     call filter(module, 'v:key =~# "^\\a"')
    2              0.000001   endif
    2              0.000010   let s:loaded[a:sid] = module
    2              0.000015   return copy(module)

FUNCTION  <SNR>149_substitute_path_separator()
Called 4 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    4              0.000030   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  <SNR>164_garbage_collect()
Called 2 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    2              0.000021   for pid in values(s:bg_processes)
                                " Check processes.
                                try
                                  let [cond, status] = s:libcall('vp_waitpid', [pid])
                                  " echomsg string([pid, cond, status])
                                  if cond !=# 'run'
                                    if cond !=# 'exit'
                                      " Kill process.
                                      " 15 == SIGTERM
                                      call vimproc#kill(pid, 15)
                                    endif
                            
                                    if vimproc#util#is_windows()
                                      call s:libcall('vp_close_handle', [pid])
                                    endif
                                    call remove(s:bg_processes, pid)
                                  endif
                                catch
                                  " Ignore error.
                                endtry
                              endfor

FUNCTION  neocomplcache#is_text_mode()
Called 1 time
Total time:   0.000031
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000022   0.000008   let neocomplcache = neocomplcache#get_current_neocomplcache()
    1              0.000006   return get(g:neocomplcache_text_mode_filetypes, neocomplcache.context_filetype, 0)

FUNCTION  ctrlp#utils#cachedir()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006 	retu s:cache_dir

FUNCTION  neocomplcache#sources#vim_complete#define()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   return s:source

FUNCTION  <SNR>64_AutoClose()
Called 6 times
Total time:   0.004497
 Self time:   0.004497

count  total (s)   self (s)
                            	" Add matching pair and jump to the midle:
                            	" inoremap <silent> <buffer> ( ()<Left>
    6              0.000015 	let i = 0
   24              0.000097 	while i < len(b:_l_delimitMate_matchpairs_list)
   18              0.000142 		let ld = b:_l_delimitMate_left_delims[i] == '|' ? '<bar>' : b:_l_delimitMate_left_delims[i]
   18              0.000119 		let rd = b:_l_delimitMate_right_delims[i] == '|' ? '<bar>' : b:_l_delimitMate_right_delims[i]
   18              0.000938 		exec 'inoremap <silent> <Plug>delimitMate' . ld . ' ' . ld . '<C-R>=delimitMate#ParenDelim("' . escape(rd, '|') . '")<CR>'
   18              0.000481 		exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
   18              0.000045 		let i += 1
   18              0.000020 	endwhile
                            
                            	" Exit from inside the matching pair:
   24              0.000048 	for delim in b:_l_delimitMate_right_delims
   18              0.000629 		exec 'inoremap <silent> <Plug>delimitMate' . delim . ' <C-R>=delimitMate#JumpOut("\' . delim . '")<CR>'
   18              0.000427 		exec 'silent! imap <unique> <buffer> ' . delim . ' <Plug>delimitMate'. delim
   18              0.000022 	endfor
                            
                            	" Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                            	" inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
   24              0.000046 	for delim in b:_l_delimitMate_quotes_list
   18              0.000038 		if delim == '|'
                            			let delim = '<Bar>'
                            		endif
   18              0.000628 		exec 'inoremap <silent> <Plug>delimitMate' . delim . ' <C-R>=delimitMate#QuoteDelim("\' . delim . '")<CR>'
   18              0.000405 		exec 'silent! imap <unique> <buffer> ' . delim . ' <Plug>delimitMate' . delim
   18              0.000026 	endfor
                            
                            	" Try to fix the use of apostrophes (kept for backward compatibility):
                            	" inoremap <silent> <buffer> n't n't
    6              0.000018 	for map in b:_l_delimitMate_apostrophes_list
                            		exec "inoremap <silent> " . map . " " . map
                            		exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
                            	endfor

FUNCTION  neobundle#autoload#explorer()
Called 16 times
Total time:   0.001057
 Self time:   0.000377

count  total (s)   self (s)
   16              0.000113   if bufnr('%') != expand('<abuf>') || a:path == ''
   11              0.000016     return
                              endif
                            
    5              0.000011   let path = a:path
                              " For ":edit ~".
    5              0.000022   if fnamemodify(path, ':t') ==# '~'
                                let path = '~'
                              endif
                            
    5   0.000588   0.000039   let bundles = filter(neobundle#config#get_autoload_bundles(), "get(v:val.autoload, 'explorer', 0)")
    5   0.000229   0.000098   if !filereadable(s:expand(path)) && !empty(bundles)
                                call neobundle#config#source_bundles(bundles)
                                execute 'doautocmd' a:event
                              endif

FUNCTION  vimproc#dll_version()
Called 1 time
Total time:   0.000390
 Self time:   0.000027

count  total (s)   self (s)
    1   0.000382   0.000019   let [dll_version] = s:libcall('vp_dlversion', [])
    1              0.000006   return str2nr(dll_version)

FUNCTION  <SNR>146_set_default_custom()
Called 1 time
Total time:   0.001110
 Self time:   0.000675

count  total (s)   self (s)
    1   0.001077   0.000642   let custom = neocomplcache#variables#get_custom().sources
                            
                              " Initialize completion length.
    1              0.000006   for [source_name, length] in items( g:neocomplcache_source_completion_length)
                                if !has_key(custom, source_name)
                                  let custom[source_name] = {}
                                endif
                                let custom[source_name].min_pattern_length = length
                              endfor
                            
                              " Initialize rank.
    1              0.000004   for [source_name, rank] in items( g:neocomplcache_source_rank)
                                if !has_key(custom, source_name)
                                  let custom[source_name] = {}
                                endif
                                let custom[source_name].rank = rank
                              endfor

FUNCTION  nerdtree#treeUpDirLine()
Called 5 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    5              0.000008     return '.. (up a dir)'

FUNCTION  indent_guides#init_script_vars()
Called 13 times
Total time:   0.001630
 Self time:   0.001049

count  total (s)   self (s)
   13              0.000038   let s:indent_size = &l:shiftwidth
   13   0.000227   0.000077   let s:guide_size  = indent_guides#calculate_guide_size()
   13   0.000509   0.000078   let s:hi_normal   = indent_guides#capture_highlight('Normal')
                            
                              " remove 'font=<value>' from the s:hi_normal string (only seems to happen on Vim startup in Windows)
   13              0.000167   let s:hi_normal = substitute(s:hi_normal, ' font=[A-Za-z0-9:]\+', "", "")
                            
                              " shortcuts to the global variables - this makes the code easier to read
   13              0.000034   let s:debug             = g:indent_guides_debug
   13              0.000032   let s:indent_levels     = g:indent_guides_indent_levels
   13              0.000029   let s:auto_colors       = g:indent_guides_auto_colors
   13              0.000039   let s:color_hex_pat     = g:indent_guides_color_hex_pattern
   13              0.000041   let s:color_hex_bg_pat  = g:indent_guides_color_hex_guibg_pattern
   13              0.000043   let s:color_name_bg_pat = g:indent_guides_color_name_guibg_pattern
   13              0.000028   let s:start_level       = g:indent_guides_start_level
                            
                              " str2float not available in vim versions <= 7.1
   13              0.000038   if has('float')
   13              0.000067     let s:change_percent = g:indent_guides_color_change_percent / str2float('100.0')
   13              0.000011   else
                                let s:change_percent = g:indent_guides_color_change_percent / 100.0
                              endif
                            
   13              0.000013   if s:debug
                                echo 's:indent_size = '       . s:indent_size
                                echo 's:guide_size = '        . s:guide_size
                                echo 's:hi_normal = '         . s:hi_normal
                                echo 's:indent_levels = '     . s:indent_levels
                                echo 's:auto_colors = '       . s:auto_colors
                                echo 's:change_percent = '    . string(s:change_percent)
                                echo 's:color_hex_pat = '     . s:color_hex_pat
                                echo 's:color_hex_bg_pat = '  . s:color_hex_bg_pat
                                echo 's:color_name_bg_pat = ' . s:color_name_bg_pat
                                echo 's:start_level = '       . s:start_level
                              endif

FUNCTION  <SNR>148_import()
Called 4 times
Total time:   0.091120
 Self time:   0.000181

count  total (s)   self (s)
    4              0.000008   let target = {}
    4              0.000007   let functions = []
    4              0.000006   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
    4   0.081326   0.036293   let module = s:_import(a:name, s:_scripts())
    4              0.000008   if empty(functions)
    4              0.000036     call extend(target, module, 'keep')
    4              0.000004   else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
    4              0.000004   return target

FUNCTION  <SNR>56_ApplyConfig()
Called 1 time
Total time:   0.000431
 Self time:   0.000324

count  total (s)   self (s)
                            " Set the indentation style according to the config values
                            
    1              0.000008     if has_key(a:config, "indent_style")
    1              0.000007         if a:config["indent_style"] == "tab"
                                        setl noexpandtab
                                    elseif a:config["indent_style"] == "space"
    1              0.000006             setl expandtab
    1              0.000001         endif
    1              0.000001     endif
    1              0.000004     if has_key(a:config, "tab_width")
    1              0.000011         let &l:tabstop = str2nr(a:config["tab_width"])
    1              0.000002     endif
    1              0.000004     if has_key(a:config, "indent_size")
                            
                                    " if indent_size is 'tab', set shiftwidth to tabstop;
                                    " if indent_size is a positive integer, set shiftwidth to the integer
                                    " value
    1              0.000003         if a:config["indent_size"] == "tab"
                                        let &l:shiftwidth = &l:tabstop
                                        let &l:softtabstop = &l:shiftwidth
                                    else
    1              0.000007             let l:indent_size = str2nr(a:config["indent_size"])
    1              0.000002             if l:indent_size > 0
    1              0.000005                 let &l:shiftwidth = l:indent_size
    1              0.000004                 let &l:softtabstop = &l:shiftwidth
    1              0.000002             endif
    1              0.000001         endif
                            
    1              0.000000     endif
                            
    1              0.000005     if has_key(a:config, "end_of_line") && &l:modifiable
    1              0.000004         if a:config["end_of_line"] == "lf"
    1              0.000007             setl fileformat=unix
    1              0.000003         elseif a:config["end_of_line"] == "crlf"
                                        setl fileformat=dos
                                    elseif a:config["end_of_line"] == "cr"
                                        setl fileformat=mac
                                    endif
    1              0.000001     endif
                            
    1              0.000004     if has_key(a:config, "charset") && &l:modifiable
    1              0.000003         if a:config["charset"] == "utf-8"
    1              0.000006             setl fileencoding=utf-8
    1              0.000003             setl nobomb
    1              0.000002         elseif a:config["charset"] == "utf-8-bom"
                                        setl fileencoding=utf-8
                                        setl bomb
                                    elseif a:config["charset"] == "latin1"
                                        setl fileencoding=latin1
                                        setl nobomb
                                    elseif a:config["charset"] == "utf-16be"
                                        setl fileencoding=utf-16be
                                        setl bomb
                                    elseif a:config["charset"] == "utf-16le"
                                        setl fileencoding=utf-16le
                                        setl bomb
                                    endif
    1              0.000001     endif
                            
    1              0.000004     if has_key(a:config, "trim_trailing_whitespace")
    1              0.000006         augroup editorconfig_trim_trailing_whitespace
    1              0.000111         autocmd! editorconfig_trim_trailing_whitespace
    1              0.000005         if a:config["trim_trailing_whitespace"] == "true"
    1              0.000010             autocmd editorconfig_trim_trailing_whitespace BufWritePre <buffer> :%s/\s\+$//e
    1              0.000002         endif
                            
    1              0.000002         augroup END " editorconfig_trim_trailing_whitespace group
    1              0.000001     endif
                            
    1   0.000120   0.000013     call editorconfig#ApplyHooks(a:config)

FUNCTION  ctrlp#utils#writecache()
Called 1 time
Total time:   0.001647
 Self time:   0.001608

count  total (s)   self (s)
    1   0.000069   0.000030 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.001573 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000003 	en

FUNCTION  CloseWindowOrKillBuffer()
Called 2 times
Total time:   0.039256
 Self time:   0.001088

count  total (s)   self (s)
    2              0.000076   let number_of_windows_to_this_buffer = len(filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')"))
                            
                              " never bdelete a nerd tree
    2              0.000050   if matchstr(expand("%"), 'NERD') == 'NERD'
                                wincmd c
                                return
                              endif
                            
    2              0.000012   if number_of_windows_to_this_buffer > 1
                                wincmd c
                              else
    2   0.039065   0.000897     bdelete
    2              0.000002   endif

FUNCTION  <SNR>46_FindBundlerRoot()
Called 3 times
Total time:   0.000938
 Self time:   0.000891

count  total (s)   self (s)
    3   0.000076   0.000029   let path = s:shellslash(a:path)
    3              0.000070   let fn = fnamemodify(path,':s?[\/]$??')
    3              0.000009   let ofn = ""
    3              0.000006   let nfn = fn
   27              0.000081   while fn != ofn
   24              0.000229     if filereadable(fn.'/Gemfile')
                                  return s:sub(simplify(fnamemodify(fn,':p')),'[\\/]$','')
                                endif
   24              0.000059     let ofn = fn
   24              0.000124     let fn = fnamemodify(ofn,':h')
   24              0.000049   endwhile
    3              0.000004   return ''

FUNCTION  neocomplcache#define_source()
Called 13 times
Total time:   0.326689
 Self time:   0.000586

count  total (s)   self (s)
   13   0.000280   0.000113   let sources = neocomplcache#variables#get_sources()
   26   0.000259   0.000153   for source in neocomplcache#util#convert2list(a:source)
   13   0.326018   0.000188     let sources[source.name] = neocomplcache#init#_source(source)
   13              0.000021   endfor

FUNCTION  <SNR>12_yank_with_key()
Called 2 times
Total time:   0.144195
 Self time:   0.000075

count  total (s)   self (s)
    2   0.144177   0.000057   call s:before_yank()
    2              0.000008   return a:key

FUNCTION  <SNR>70_record()
Called 16 times
Total time:   0.000827
 Self time:   0.000395

count  total (s)   self (s)
   16              0.000052 	if s:locked | retu | en
   16              0.000047 	let bufnr = a:bufnr + 0
   16              0.000052 	let bufname = bufname(bufnr)
   16              0.000046 	if bufnr > 0 && !empty(bufname)
    5              0.000025 		cal filter(s:mrbs, 'v:val != bufnr')
    5              0.000015 		cal insert(s:mrbs, bufnr)
    5   0.000466   0.000034 		cal s:addtomrufs(bufname)
    5              0.000005 	en

FUNCTION  227()
Called 4 times
Total time:   0.002257
 Self time:   0.000159

count  total (s)   self (s)
    4   0.002106   0.000023     call self.reset(a:loclist)
    4              0.000012     let buf = bufnr('')
    4   0.000040   0.000025     let issues = filter(a:loclist.filteredRaw(), 'v:val["bufnr"] == buf')
    4              0.000008     for item in issues
                                    let group = item['type'] == 'E' ? 'SyntasticError' : 'SyntasticWarning'
                            
                                    " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                    " used to override default highlighting.
                                    if has_key(item, 'hl')
                                        call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                    elseif get(item, 'col')
                                        let lastcol = col([item['lnum'], '$'])
                                        let lcol = min([lastcol, item['col']])
                            
                                        " a bug in vim can sometimes cause there to be no 'vcol' key,
                                        " so check for its existence
                                        let coltype = has_key(item, 'vcol') && item['vcol'] ? 'v' : 'c'
                            
                                        call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                    endif
                                endfor

FUNCTION  unite#util#is_windows()
Called 7 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    7              0.000011   return s:is_windows

FUNCTION  ctrlp#utils#mkdir()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000028 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    1              0.000002 	retu a:dir

FUNCTION  fugitive#statusline()
Called 90 times
Total time:   0.000920
 Self time:   0.000920

count  total (s)   self (s)
   90              0.000547   if !exists('b:git_dir')
   90              0.000199     return ''
                              endif
                              let status = ''
                              if s:buffer().commit() != ''
                                let status .= ':' . s:buffer().commit()[0:7]
                              endif
                              let status .= '('.fugitive#head(7).')'
                              if &statusline =~# '%[MRHWY]' && &statusline !~# '%[mrhwy]'
                                return ',GIT'.status
                              else
                                return '[Git'.status.']'
                              endif

FUNCTION  nerdtree#exec()
Called 14 times
Total time:   0.001496
 Self time:   0.001496

count  total (s)   self (s)
   14              0.000086     let old_ei = &ei
   14              0.000091     set ei=all
   14              0.001214     exec a:cmd
   14              0.000080     let &ei = old_ei

FUNCTION  <SNR>46_Detect()
Called 3 times
Total time:   0.001043
 Self time:   0.000105

count  total (s)   self (s)
    3              0.000018   if !exists('b:bundler_root')
    3   0.000975   0.000037     let dir = s:FindBundlerRoot(a:path)
    3              0.000007     if dir != ''
                                  let b:bundler_root = dir
                                endif
    3              0.000003   endif
    3              0.000011   if exists('b:bundler_root')
                                silent doautocmd User Bundler
                              endif

FUNCTION  neocomplcache#mappings#define_default_mappings()
Called 1 time
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
    1              0.000072   inoremap <expr><silent> <Plug>(neocomplcache_start_unite_complete) unite#sources#neocomplcache#start_complete()
    1              0.000039   inoremap <expr><silent> <Plug>(neocomplcache_start_unite_quick_match) unite#sources#neocomplcache#start_quick_match()
    1              0.000035   inoremap <silent> <Plug>(neocomplcache_start_auto_complete) <C-x><C-u><C-r>=neocomplcache#mappings#popup_post()<CR>
    1              0.000025   inoremap <silent> <Plug>(neocomplcache_start_auto_complete_no_select) <C-x><C-u><C-p>
                              " \ <C-x><C-u><C-p>
    1              0.000022   inoremap <silent> <Plug>(neocomplcache_start_omni_complete) <C-x><C-o><C-p>

FUNCTION  unite#sources#mru#append()
Called 7 times
Total time:   0.001592
 Self time:   0.000136

count  total (s)   self (s)
   21              0.000044   for m in values(s:MRUs)
   14   0.001509   0.000053     call m.append()
   14              0.000014   endfor

FUNCTION  <SNR>137_uniq()
Called 1 time
Total time:   0.000996
 Self time:   0.000996

count  total (s)   self (s)
    1              0.000078   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
    1              0.000003   let i = 0
    1              0.000002   let seen = {}
   33              0.000088   while i < len(list)
   32              0.000262     let key = string(a:0 ? list[i][1] : list[i])
   32              0.000114     if has_key(seen, key)
    8              0.000035       call remove(list, i)
    8              0.000009     else
   24              0.000093       let seen[key] = 1
   24              0.000048       let i += 1
   24              0.000024     endif
   32              0.000036   endwhile
    1              0.000043   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  indent_guides#init_matches()
Called 13 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   13              0.000084   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  ctrlp#mrufiles#cachefile()
Called 1 time
Total time:   0.031493
 Self time:   0.030192

count  total (s)   self (s)
    1              0.000013 	if !exists('s:cadir') || !exists('s:cafile')
    1   0.031448   0.030158 		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
    1   0.000024   0.000013 		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    1              0.000002 	en
    1              0.000003 	retu s:cafile

FUNCTION  <SNR>173__redir()
Called 4 times
Total time:   0.004046
 Self time:   0.004046

count  total (s)   self (s)
    4              0.000026   let oldverbosefile = &verbosefile
    4              0.000023   set verbosefile=
    4              0.000015   redir => res
    4              0.003894     silent! execute a:cmd
    4              0.000040   redir END
    4              0.000018   let &verbosefile = oldverbosefile
    4              0.000023   return res

FUNCTION  <SNR>140_convert2list()
Called 24 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   24              0.000084   return [ a:dict.action__path, a:dict.source__time ]

FUNCTION  neocomplcache#util#substitute_path_separator()
Called 4 times
Total time:   0.000094
 Self time:   0.000061

count  total (s)   self (s)
    4   0.000090   0.000057   return call(s:V.substitute_path_separator, a:000)

FUNCTION  nerdtree#renderView()
Called 3 times
Total time:   0.010840
 Self time:   0.000482

count  total (s)   self (s)
    3              0.000009     setlocal modifiable
                            
                                "remember the top line of the buffer and the current line so we can
                                "restore the view exactly how it was
    3              0.000008     let curLine = line(".")
    3              0.000006     let curCol = col(".")
    3              0.000008     let topLine = line("w0")
                            
                                "delete all lines in the buffer (being careful not to clobber a register)
    3              0.000055     silent 1,$delete _
                            
    3   0.000375   0.000019     call nerdtree#dumpHelp()
                            
                                "delete the blank line before the help and add one after it
    3              0.000006     if g:NERDTreeMinimalUI == 0
    3              0.000016         call setline(line(".")+1, "")
    3              0.000013         call cursor(line(".")+1, col("."))
    3              0.000002     endif
                            
    3              0.000003     if b:NERDTreeShowBookmarks
    3   0.000124   0.000012         call nerdtree#renderBookmarks()
    3              0.000001     endif
                            
                                "add the 'up a dir' line
    3              0.000004     if !g:NERDTreeMinimalUI
    3   0.000024   0.000019         call setline(line(".")+1, nerdtree#treeUpDirLine())
    3              0.000010         call cursor(line(".")+1, col("."))
    3              0.000002     endif
                            
                                "draw the header line
    3   0.000217   0.000028     let header = b:NERDTreeRoot.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    3              0.000015     call setline(line(".")+1, header)
    3              0.000011     call cursor(line(".")+1, col("."))
                            
                                "draw the tree
    3              0.000005     let old_o = @o
    3   0.009714   0.000018     let @o = b:NERDTreeRoot.renderToString()
    3              0.000043     silent put o
    3              0.000010     let @o = old_o
                            
                                "delete the blank line at the top of the buffer
    3              0.000029     silent 1,1delete _
                            
                                "restore the view
    3              0.000008     let old_scrolloff=&scrolloff
    3              0.000008     let &scrolloff=0
    3              0.000008     call cursor(topLine, 1)
    3              0.000035     normal! zt
    3              0.000009     call cursor(curLine, curCol)
    3              0.000008     let &scrolloff = old_scrolloff
                            
    3              0.000007     setlocal nomodifiable

FUNCTION  neocomplcache#sources#syntax_complete#define()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007   return s:source

FUNCTION  nerdtree#stripMarkupFromLine()
Called 14 times
Total time:   0.001539
 Self time:   0.001444

count  total (s)   self (s)
   14              0.000042     let line = a:line
                                "remove the tree parts and the leading space
   14   0.000334   0.000239     let line = substitute (line, nerdtree#treeMarkupReg(),"","")
                            
                                "strip off any read only flag
   14              0.000110     let line = substitute (line, ' \[RO\]', "","")
                            
                                "strip off any bookmark flags
   14              0.000112     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
   14              0.000120     let line = substitute (line, '*\ze\($\| \)', "","")
                            
   14              0.000034     let wasdir = 0
   14              0.000059     if line =~# '/$'
   14              0.000029         let wasdir = 1
   14              0.000014     endif
   14              0.000114     let line = substitute (line,' -> .*',"","") " remove link to
   14              0.000026     if wasdir ==# 1
   14              0.000180         let line = substitute (line, '/\?$', '/', "")
   14              0.000025     endif
                            
   14              0.000032     if a:removeLeadingSpaces
   12              0.000094         let line = substitute (line, '^ *', '', '')
   12              0.000014     endif
                            
   14              0.000021     return line

FUNCTION  neocomplcache#sources#tags_complete#define()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return s:source

FUNCTION  <SNR>168_caching()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000006   if &filetype == '' || &filetype ==# 'vim'
    1              0.000002     return
                              endif
                            
                              for filetype in neocomplcache#get_source_filetypes(&filetype)
                                if !has_key(s:syntax_list, filetype)
                                  " Check old cache.
                                  let cache_name = neocomplcache#cache#encode_name('syntax_cache', &filetype)
                                  let syntax_files = split( globpath(&runtimepath, 'syntax/'.&filetype.'.vim'), '\n')
                                  if getftime(cache_name) < 0 || (!empty(syntax_files) && getftime(cache_name) <= getftime(syntax_files[0]))
                                    if filetype ==# &filetype
                                      " Caching from syn list.
                                      let s:syntax_list[filetype] = s:caching_from_syn(filetype)
                                    endif
                                  else
                                    let s:syntax_list[filetype] = neocomplcache#cache#index_load_from_cache(      'syntax_cache', filetype, 1)
                                  endif
                                endif
                              endfor

FUNCTION  193()
Called 1 time
Total time:   0.206521
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000010     let creator = s:Creator.New()
    1   0.206491   0.000008     call creator.createPrimary(a:name)

FUNCTION  vimproc#util#set_default()
Called 9 times
Total time:   0.000347
 Self time:   0.000347

count  total (s)   self (s)
    9              0.000122   if !exists(a:var) || type({a:var}) != type(a:val)
    6              0.000051     let alternate_var = get(a:000, 0, '')
                            
    6              0.000080     let {a:var} = exists(alternate_var) ? {alternate_var} : a:val
    6              0.000016   endif

FUNCTION  200()
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000034     let newCreator = copy(self)
    2              0.000004     return newCreator

FUNCTION  201()
Called 1 time
Total time:   0.000020
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000019   0.000008     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    1              0.000001     return name

FUNCTION  202()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     if !exists("s:Creator._NextBufNum")
    1              0.000002         let s:Creator._NextBufNum = 1
    1              0.000000     else
                                    let s:Creator._NextBufNum += 1
                                endif
                            
    1              0.000002     return s:Creator._NextBufNum

FUNCTION  204()
Called 2 times
Total time:   0.137186
 Self time:   0.000110

count  total (s)   self (s)
                                "throwaway buffer options
    2              0.000004     setlocal noswapfile
    2              0.000007     setlocal buftype=nofile
    2              0.000004     setlocal bufhidden=hide
    2              0.000002     setlocal nowrap
    2              0.000005     setlocal foldcolumn=0
    2              0.000004     setlocal foldmethod=manual
    2              0.000002     setlocal nofoldenable
    2   0.000023   0.000002     setlocal nobuflisted
    2              0.000003     setlocal nospell
    2              0.000002     if g:NERDTreeShowLineNumbers
    2              0.000005         setlocal nu
    2              0.000001     else
                                    setlocal nonu
                                    if v:version >= 703
                                        setlocal nornu
                                    endif
                                endif
                            
    2              0.000002     iabc <buffer>
                            
    2              0.000003     if g:NERDTreeHighlightCursorline
    2              0.000003         setlocal cursorline
    2              0.000001     endif
                            
    2   0.000021   0.000008     call self._setupStatusline()
                            
    2              0.000003     let b:treeShowHelp = 0
    2              0.000003     let b:NERDTreeIgnoreEnabled = 1
    2              0.000004     let b:NERDTreeShowFiles = g:NERDTreeShowFiles
    2              0.000002     let b:NERDTreeShowHidden = g:NERDTreeShowHidden
    2              0.000004     let b:NERDTreeShowBookmarks = g:NERDTreeShowBookmarks
    2   0.131747   0.000006     setfiletype nerdtree
    2   0.005310   0.000009     call self._bindMappings()

FUNCTION  206()
Called 1 time
Total time:   0.078794
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000008     let creator = s:Creator.New()
    1   0.078762   0.000008     call creator.togglePrimary(a:dir)

FUNCTION  207()
Called 1 time
Total time:   0.078754
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000012   0.000006     if nerdtree#treeExistsForTab()
    1   0.000036   0.000005         if !nerdtree#isTreeOpen()
    1   0.078637   0.000006             call self._createTreeWin()
    1              0.000002             if !&hidden
                                            call nerdtree#renderView()
                                        endif
    1   0.000056   0.000005             call nerdtree#restoreScreenState()
    1              0.000001         else
                                        call nerdtree#closeTree()
                                    endif
    1              0.000001     else
                                    call self.createPrimary(a:dir)
                                endif

FUNCTION  <SNR>94_UpdateLastColumn()
Called 9 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
                              " Function to save the current column and buffer and window numbers,
    9              0.000034   if !exists('w:BufKillList')
                                " Just give up for now.
                                return
                              endif
    9              0.000047   let index = index(w:BufKillList, bufnr('%'))
    9              0.000015   if index != -1
                                " Extend list if required, then set the value
    9              0.000081     let w:BufKillColumnList += repeat([0], index - len(w:BufKillColumnList) + 1)
    9              0.000049     let w:BufKillColumnList[index] = col('.')
    9              0.000010   else
                                echom 'UpdateLastColumn failed to find bufnr ' . bufnr('%') . ' in w:BufKillList'
                              endif

FUNCTION  <SNR>15_SelectJavascript()
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000035   if getline(1) =~# '^#!.*/bin/env\s\+node\>'
                                set ft=javascript
                              endif

FUNCTION  <SNR>42_isAllowedType()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000003   let haz = 1
    1              0.000003   let type = a:type
    1              0.000007   let allowedTypes = get(a:000, 1, ['js', 'css', 'html'])
                            
    1              0.000005   return index(allowedTypes, type) != -1

FUNCTION  <SNR>107_BufWinEnterHook()
Called 5 times
Total time:   0.002708
 Self time:   0.000111

count  total (s)   self (s)
    5              0.000027     if empty(&bt)
    4   0.000234   0.000024         let loclist = g:SyntasticLoclist.current()
    4   0.000152   0.000022         call g:SyntasticAutoloclistNotifier.AutoToggle(loclist)
    4   0.002278   0.000021         call g:SyntasticHighlightingNotifier.refresh(loclist)
    4              0.000003     endif

FUNCTION  neocomplcache#variables#get_custom()
Called 15 times
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
   15              0.000067   if !exists('s:custom')
    1              0.000004     let s:custom = {}
    1              0.000003     let s:custom.sources = {}
    1              0.000003     let s:custom.sources._ = {}
    1              0.000001   endif
                            
   15              0.000024   return s:custom

FUNCTION  360()
Called 1 time
Total time:   0.000162
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000008   let g:neocomplcache_tags_caching_limit_file_size = get(g:, 'neocomplcache_tags_caching_limit_file_size', 500000)
                            
                              " Create cache directory.
    1   0.000142   0.000062   if !isdirectory(neocomplcache#get_temporary_directory() . '/tags_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/tags_cache', 'p')
                              endif

FUNCTION  210()
Called 4 times
Total time:   0.000130
 Self time:   0.000070

count  total (s)   self (s)
    4   0.000078   0.000018     if a:loclist.hasErrorsOrWarningsToDisplay()
                                    if g:syntastic_auto_loc_list == 1
                                        call a:loclist.show()
                                    endif
                                else
    4              0.000007         if g:syntastic_auto_loc_list > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
    4              0.000004             lclose
    4              0.000002         endif
    4              0.000004     endif

FUNCTION  neocomplcache#init#lazy()
Called 3 times
Total time:   0.710420
 Self time:   0.032611

count  total (s)   self (s)
    3              0.000047   if !exists('s:lazy_progress')
    1              0.000007     let s:lazy_progress = 0
    1              0.000003   endif
                            
    3              0.000012   if s:lazy_progress == 0
    1   0.192608   0.000014     call neocomplcache#init#_others()
    1              0.000003     let s:is_enabled = 0
    1              0.000002   elseif s:lazy_progress == 1
    1   0.517423   0.032413     call neocomplcache#init#_sources(get(g:neocomplcache_sources_list, neocomplcache#get_context_filetype(), ['_']))
    1              0.000001   else
    1   0.000218   0.000013     call neocomplcache#init#_autocmds()
    1              0.000005     let s:is_enabled = 1
    1              0.000002   endif
                            
    3              0.000009   let s:lazy_progress += 1

FUNCTION  neocomplcache#util#has_vimproc()
Called 1 time
Total time:   0.234642
 Self time:   0.119088

count  total (s)   self (s)
                              " Initialize.
    1              0.000004   if !exists('g:neocomplcache_use_vimproc')
                                " Check vimproc.
    1              0.000001     try
    1   0.234606   0.119052       call vimproc#version()
    1              0.000006       let exists_vimproc = 1
    1              0.000002     catch
                                  let exists_vimproc = 0
                                endtry
                            
    1              0.000006     let g:neocomplcache_use_vimproc = exists_vimproc
    1              0.000002   endif
                            
    1              0.000003   return g:neocomplcache_use_vimproc

FUNCTION  unite#sources#window#_append()
Called 9 times
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
    9              0.000020   if &filetype == 'unite'
                                " Ignore unite window.
                                return
                              endif
                            
                              " Save unite window information.
    9              0.000174   let w:unite_window = { 'time' : localtime(), 'cwd' : getcwd(),}

FUNCTION  <SNR>164_vp_dlopen()
Called 1 time
Total time:   0.011634
 Self time:   0.000029

count  total (s)   self (s)
    1   0.011627   0.000022   let [handle] = s:libcall('vp_dlopen', [a:path])
    1              0.000004   return handle

FUNCTION  40()
Called 3 times
Total time:   0.001226
 Self time:   0.000094

count  total (s)   self (s)
    3   0.000036   0.000011     if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
                                else
    3              0.000034         let path = '/'. join(self.pathSegments[0:-2], '/')
    3              0.000011     endif
                            
    3   0.001125   0.000018     return s:Path.New(path)

FUNCTION  41()
Called 613 times
Total time:   0.006265
 Self time:   0.006265

count  total (s)   self (s)
  613              0.001116     if empty(self.pathSegments)
                                    return ''
                                endif
  613              0.001330     let toReturn = self.pathSegments[-1]
  613              0.000824     if a:dirSlash && self.isDirectory
   90              0.000192         let toReturn = toReturn . '/'
   90              0.000051     endif
  613              0.000554     return toReturn

FUNCTION  42()
Called 108 times
Total time:   0.008609
 Self time:   0.004994

count  total (s)   self (s)
  108              0.000151     let i = 0
  438              0.000764     while i < len(g:NERDTreeSortOrder)
  372   0.005734   0.002119         if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
   42              0.000051             return i
                                    endif
  330              0.000514         let i = i + 1
  330              0.000265     endwhile
   66              0.000079     return s:NERDTreeSortStarIndex

FUNCTION  203()
Called 1 time
Total time:   0.000700
 Self time:   0.000088

count  total (s)   self (s)
    1              0.000003     let path = {}
    1   0.000091   0.000009     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
                                else
    1              0.000006         let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
    1              0.000005         if dir =~# '^\.'
                                        let dir = getcwd() . g:NERDTreePath.Slash() . dir
                                    endif
    1   0.000080   0.000014         let dir = g:NERDTreePath.Resolve(dir)
                            
    1              0.000001         try
    1   0.000476   0.000012             let path = g:NERDTreePath.New(dir)
    1              0.000002         catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("No bookmark or directory found for: " . a:str)
                                        return
                                    endtry
    1              0.000001     endif
    1              0.000002     if !path.isDirectory
                                    let path = path.getParent()
                                endif
                            
    1              0.000002     return path

FUNCTION  228()
Called 4 times
Total time:   0.002083
 Self time:   0.002083

count  total (s)   self (s)
  244              0.000614     for match in getmatches()
  240              0.000661         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
  240              0.000156     endfor

FUNCTION  229()
Called 4 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
    4              0.000033     let newObj = copy(self)
    4              0.000016     let newObj._quietWarnings = g:syntastic_quiet_warnings
                            
    4              0.000014     let llist = copy(a:rawLoclist)
    4              0.000015     let llist = filter(llist, 'v:val["valid"] == 1')
                            
    4              0.000008     for e in llist
                                    if empty(e['type'])
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    4              0.000009     let newObj._rawLoclist = llist
    4              0.000009     let newObj._hasErrorsOrWarningsToDisplay = -1
                            
    4              0.000005     return newObj

FUNCTION  neocomplcache#init#_others()
Called 1 time
Total time:   0.192594
 Self time:   0.001772

count  total (s)   self (s)
    1   0.187426   0.000012   call neocomplcache#init#_variables()
                            
    1   0.002132   0.000622   call neocomplcache#context_filetype#initialize()
                            
    1   0.001363   0.000551   call neocomplcache#commands#_initialize()
                            
                              " Save options.
    1              0.000004   let s:completefunc_save = &completefunc
    1              0.000003   let s:completeopt_save = &completeopt
                            
                              " Set completefunc.
    1              0.000005   let &completefunc = 'neocomplcache#complete#manual_complete'
                            
                              " For auto complete keymappings.
    1   0.001620   0.000534   call neocomplcache#mappings#define_default_mappings()
                            
                              " Detect set paste.
    1              0.000002   if &paste
                                redir => output
                                99verbose set paste
                                redir END
                                call neocomplcache#print_error(output)
                                call neocomplcache#print_error( 'Detected set paste! Disabled neocomplcache.')
                              endif
                            
    1              0.000016   command! -nargs=0 -bar NeoComplCacheDisable call neocomplcache#init#disable()

FUNCTION  49()
Called 18 times
Total time:   0.003865
 Self time:   0.000154

count  total (s)   self (s)
   18   0.003856   0.000145     return self.str() ==# a:path.str()

FUNCTION  <SNR>164_finalize()
Called 1 time
Total time:   0.000590
 Self time:   0.000045

count  total (s)   self (s)
    1   0.000099   0.000014   call s:garbage_collect()
                            
    1              0.000009   if exists('s:dll_handle')
    1   0.000476   0.000016     call s:vp_dlclose(s:dll_handle)
    1              0.000002   endif

FUNCTION  237()
Called 34 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
   34              0.000093     if self._hasErrorsOrWarningsToDisplay >= 0
   30              0.000072         return self._hasErrorsOrWarningsToDisplay
                                endif
    4              0.000028     let self._hasErrorsOrWarningsToDisplay = empty(self._rawLoclist) ? 0 : (!self._quietWarnings || len(self.errors()))
    4              0.000005     return self._hasErrorsOrWarningsToDisplay

FUNCTION  neocomplcache#sources#vimshell_complete#define()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  <SNR>67_SetCurrentExtension()
Called 7 times
Total time:   0.000293
 Self time:   0.000171

count  total (s)   self (s)
    7   0.000077   0.000039     call s:CreateDict()
    7              0.000018     if !empty(&buftype)
    1              0.000001         return
                                endif
    6              0.000017     let fname = bufname("%")
    6              0.000010     if empty(fname)
    5              0.000004         return
                                endif
    1              0.000004     let ext = fnamemodify(fname, ":e")
    1              0.000002     if !empty(ext)
                                    let ext = "*.".ext
                                else
    1              0.000017         let ext = fnamemodify(fname, ":p:t")
    1              0.000003         if(empty(ext))
                                        return
                                    endif
    1              0.000000     endif
    1   0.000090   0.000006     if !s:IsModeTracked()
                                    " Always save the extension when not in tracked mode
    1              0.000002         let s:TrackedExt = ext
                            
                                    " Note: this has a very, very, very, small issue (is it even an
                                    " issue?) where if you're working with C++ files, and you switch to
                                    " buffers mode, and then edit a file of another type, like .c (which
                                    " should be in the C++ list), and then switch back to tracked mode,
                                    " you will lose the C++ association and have to go back to a C++
                                    " file before being able to search them.
                                    " This is so small of an issue that it's almost a non-issue, so I'm
                                    " not going to bother fixing it
    1              0.000001     else
                                    let tempList = split(s:FilesToGrep)
                            
                                    " When in tracked mode, change the tracked extension if it isn't
                                    " already in the list of files to be grepped
                                    if index(tempList, ext) == -1
                                        let s:TrackedExt = ext
                                        let s:Dict[s:EasyGrepModeTracked][1] = ext
                                    endif
                                endif

FUNCTION  <SNR>56_UseConfigFiles_Python_Builtin()
Called 1 time
Total time:   0.013842
 Self time:   0.013411

count  total (s)   self (s)
                            " Use built-in python to run the python EditorConfig core
                            
    1              0.000005     let l:config = {}
    1              0.000003     let l:ret = 0
                            
                                " ignore buffers that do not have a file path associated
    1              0.000025     if empty(expand('%:p'))
                                    return 0
                                endif
                            
    1              0.000001     python << EEOOFF
                            
                            ec_data['filename'] = vim.eval("expand('%:p')")
                            ec_data['conf_file'] = ".editorconfig"
                            
                            try:
                                ec_data['options'] = editorconfig.get_properties(ec_data['filename'])
                            except editorconfig_except.EditorConfigError, e:
                                if int(vim.eval('g:EditorConfig_verbose')) != 0:
                                    print >> sys.stderr, str(e)
                                vim.command('let l:ret = 1')
                            
                            EEOOFF
    1              0.000019     if l:ret != 0
                                    return l:ret
                                endif
                            
    1              0.000002     python << EEOOFF
                            for key, value in ec_data['options'].items():
                                vim.command("let l:config['" + key.replace("'", "''") + "'] = " +
                                    "'" + value.replace("'", "''") + "'")
                            
                            EEOOFF
                            
    1   0.000456   0.000025     call s:ApplyConfig(l:config)
                            
    1              0.000001     return 0

FUNCTION  nerdtree#getTreeWinNum()
Called 16 times
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
   16              0.000067     if exists("t:NERDTreeBufName")
   16              0.000265         return bufwinnr(t:NERDTreeBufName)
                                else
                                    return -1
                                endif

FUNCTION  <SNR>147_escape()
Called 78 times
Total time:   0.002311
 Self time:   0.002311

count  total (s)   self (s)
   78              0.002241   return substitute(a:path, ',\|\\,\@=', '\\\0', 'g')

FUNCTION  vimproc#util#is_windows()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000005   return s:is_windows

FUNCTION  <SNR>150_uniq()
Called 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000012   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
    1              0.000002   let i = 0
    1              0.000002   let seen = {}
    2              0.000007   while i < len(list)
    1              0.000007     let key = string(a:0 ? list[i][1] : list[i])
    1              0.000003     if has_key(seen, key)
                                  call remove(list, i)
                                else
    1              0.000003       let seen[key] = 1
    1              0.000002       let i += 1
    1              0.000001     endif
    1              0.000001   endwhile
    1              0.000003   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  230()
Called 34 times
Total time:   0.000706
 Self time:   0.000556

count  total (s)   self (s)
   34              0.000202     if !exists("b:syntastic_loclist")
    4   0.000179   0.000029         let b:syntastic_loclist = g:SyntasticLoclist.New([])
    4              0.000003     endif
   34              0.000092     return b:syntastic_loclist

FUNCTION  233()
Called 34 times
Total time:   0.000250
 Self time:   0.000250

count  total (s)   self (s)
   34              0.000222     return copy(self._quietWarnings ? self.errors() : self._rawLoclist)

FUNCTION  236()
Called 30 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
   30              0.000113     return len(self._rawLoclist)

FUNCTION  nerdtree#has_opt()
Called 91 times
Total time:   0.000423
 Self time:   0.000423

count  total (s)   self (s)
   91              0.000377     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  neocomplcache#init#_current_neocomplcache()
Called 1 time
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000074   let b:neocomplcache = { 'context' : {      'input' : '',      'complete_pos' : -1,      'complete_str' : '',      'candidates' : [], }, 'lock' : 0, 'skip_next_complete' : 0, 'filetype' : '', 'context_filetype' : '', 'context_filetype_range' :    [[1, 1], [line('$'), len(getline('$'))+1]], 'completion_length' : -1, 'update_time_save' : &updatetime, 'foldinfo' : [], 'lock_sources' : {}, 'skipped' : 0, 'event' : '', 'cur_text' : '', 'old_cur_text' : '', 'complete_str' : '', 'complete_pos' : -1, 'candidates' : [], 'complete_results' : [], 'complete_sources' : [], 'manual_sources' : [], 'start_time' : reltime(),}

FUNCTION  <SNR>148__unify_path()
Called 2313 times
Total time:   0.076975
 Self time:   0.076975

count  total (s)   self (s)
                                " Note: On windows, vim can't expand path names from 8.3 formats.
                                " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                                " vital load duplicated scripts. Below's :~ avoid this issue.
 2313              0.072910     return tolower(fnamemodify(resolve(fnamemodify(              a:path, ':p:gs?[\\/]\+?/?')), ':~'))

FUNCTION  nerdtree#checkForBrowse()
Called 7 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    7              0.000029     if a:dir != '' && isdirectory(a:dir)
                                    call g:NERDTreeCreator.CreateSecondary(a:dir)
                                endif

FUNCTION  <SNR>64_Map()
Called 6 times
Total time:   0.026313
 Self time:   0.000533

count  total (s)   self (s)
                            	" Set mappings:
    6              0.000010 	try
    6              0.000018 		let save_keymap = &keymap
    6              0.000016 		let save_iminsert = &iminsert
    6              0.000015 		let save_imsearch = &imsearch
    6              0.000045 		let save_cpo = &cpo
    6              0.000050 		set keymap=
    6              0.000045 		set cpo&vim
    6              0.000016 		if b:_l_delimitMate_autoclose
    6   0.004539   0.000042 			call s:AutoClose()
    6              0.000006 		else
                            			call s:NoAutoClose()
                            		endif
    6   0.021340   0.000057 		call s:ExtraMappings()
    6              0.000008 	finally
    6              0.000047 		let &cpo = save_cpo
    6              0.000030 		let &keymap = save_keymap
    6              0.000026 		let &iminsert = save_iminsert
    6              0.000015 		let &imsearch = save_imsearch
    6              0.000008 	endtry
                            
    6              0.000014 	let b:delimitMate_enabled = 1
                            

FUNCTION  132()
Called 1 time
Total time:   0.000059
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000017   0.000008     if nerdtree#treeExistsForTab()
    1              0.000040         return getbufvar(t:NERDTreeBufName, 'NERDTreeRoot')
                                end
                                return {}

FUNCTION  neocomplcache#is_enabled()
Called 2 times
Total time:   0.000043
 Self time:   0.000022

count  total (s)   self (s)
    2   0.000042   0.000021   return neocomplcache#init#is_enabled()

FUNCTION  neobundle#config#get_autoload_bundles()
Called 32 times
Total time:   0.004655
 Self time:   0.004655

count  total (s)   self (s)
   32              0.004621   return filter(values(s:neobundles), "!v:val.sourced && v:val.rtp != '' && v:val.lazy")

FUNCTION  indent_guides#clear_matches()
Called 13 times
Total time:   0.008210
 Self time:   0.008118

count  total (s)   self (s)
   13   0.000144   0.000052   call indent_guides#init_matches()
   13              0.000037   if !empty(w:indent_guides_matches)
   11              0.000018     let l:index = 0
  671              0.000689     for l:match_id in w:indent_guides_matches
  660              0.000532       try
  660              0.001612         call matchdelete(l:match_id)
  660              0.000525       catch /E803:/
                                    " Do nothing
                                  endtry
  660              0.001857       call remove(w:indent_guides_matches, l:index)
  660              0.001194       let l:index += l:index
  660              0.000489     endfor
   11              0.000007   endif

FUNCTION  neosnippet#util#set_default()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000007   if !exists(a:var) || type({a:var}) != type(a:val)
    1              0.000004     let alternate_var = get(a:000, 0, '')
                            
    1              0.000005     let {a:var} = exists(alternate_var) ? {alternate_var} : a:val
    1              0.000001   endif

FUNCTION  <SNR>31_SynSet()
Called 2 times
Total time:   0.021467
 Self time:   0.020079

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000014   syn clear
    2              0.000004   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    2              0.000006   let s = expand("<amatch>")
    2              0.000004   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              endif
                            
    2              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000014     for name in split(s, '\.')
    2   0.021382   0.019994       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000005     endfor
    2              0.000003   endif

FUNCTION  <SNR>64_ExtraMappings()
Called 6 times
Total time:   0.021283
 Self time:   0.021283

count  total (s)   self (s)
                            	" If pair is empty, delete both delimiters:
    6              0.000249 	inoremap <silent><expr> <Plug>delimitMateBS delimitMate#WithinEmptyPair() ? "\<C-R>=delimitMate#BS()\<CR>" : "\<BS>"
    6              0.000275 	if !hasmapto('<Plug>delimitMateBS','i') && maparg('<BS>'. 'i') == ''
    6              0.000108 		silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
    6              0.000007 	endif
                            	" If pair is empty, delete closing delimiter:
    6              0.000245 	inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<C-R>=delimitMate#Del()\<CR>" : "\<S-BS>"
    6              0.000246 	if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
    6              0.000112 		silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
    6              0.000007 	endif
                            	" Expand return if inside an empty pair:
    6              0.000160 	inoremap <silent> <Plug>delimitMateCR <C-R>=delimitMate#ExpandReturn()<CR>
    6              0.000243 	if b:_l_delimitMate_expand_cr != 0 && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
    6              0.000103 		silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
    6              0.000006 	endif
                            	" Expand space if inside an empty pair:
    6              0.000164 	inoremap <silent> <Plug>delimitMateSpace <C-R>=delimitMate#ExpandSpace()<CR>
    6              0.000027 	if b:_l_delimitMate_expand_space != 0 && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                            		silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
                            	endif
                            	" Jump over any delimiter:
    6              0.000168 	inoremap <silent> <Plug>delimitMateS-Tab <C-R>=delimitMate#JumpAny("\<S-Tab>")<CR>
    6              0.000232 	if b:_l_delimitMate_tab2exit && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
                            		silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
                            	endif
                            	" Change char buffer on Del:
    6              0.000152 	inoremap <silent> <Plug>delimitMateDel <C-R>=delimitMate#Del()<CR>
    6              0.000232 	if !hasmapto('<Plug>delimitMateDel', 'i') && maparg('<Del>', 'i') == ''
    6              0.000102 		silent! imap <unique> <buffer> <Del> <Plug>delimitMateDel
    6              0.000005 	endif
    6              0.000079 	let keys = ['Left', 'Right', 'Home', 'End', 'C-Left', 'C-Right', 'ScrollWheelUp', 'S-ScrollWheelUp', 'C-ScrollWheelUp', 'ScrollWheelDown', 'S-ScrollWheelDown', 'C-ScrollWheelDown', 'ScrollWheelLeft', 'S-ScrollWheelLeft', 'C-ScrollWheelLeft', 'ScrollWheelRight', 'S-ScrollWheelRight', 'C-ScrollWheelRight']
                            	" Flush the char buffer on movement keystrokes:
  114              0.000150 	for map in keys
  108              0.005160 		exec 'inoremap <silent><expr> <Plug>delimitMate'.map.' !<SID>empty_buffer() ? "<C-R>=delimitMate#Finish(1)<CR><'.map.'>" : "<'.map.'>"'
  108              0.004174 		if !hasmapto('<Plug>delimitMate'.map, 'i') && maparg('<'.map.'>', 'i') == ''
   84              0.002164 			exec 'silent! imap <unique> <buffer> <'.map.'> <Plug>delimitMate'.map
   84              0.000071 		endif
  108              0.000101 	endfor
                            	" Also for default MacVim movements:
    6              0.000023 	if has('gui_macvim')
                            		for [key, map] in [['D-Left','Home'], ['D-Right','End'], ['M-Left','C-Left'], ['M-Right','C-Right']]
                            			exec 'inoremap <silent> <Plug>delimitMate'.key.' <C-R>=<SID>Finish()<CR><'.map.'>'
                            			if mapcheck('<'.key.'>', 'i') == '<'.map.'>'
                            				exec 'silent! imap <buffer> <'.key.'> <Plug>delimitMate'.key
                            			endif
                            		endfor
                            	endif
                            	" Except when pop-up menu is active:
   42              0.000075 	for map in ['Up', 'Down', 'PageUp', 'PageDown', 'S-Down', 'S-Up']
   36              0.001686 		exec 'inoremap <silent> <expr> <Plug>delimitMate'.map.' pumvisible()  \|\| <SID>empty_buffer() ? "\<'.map.'>" : "\<C-R>=\<SID>Finish()\<CR>\<'.map.'>"'
   36              0.001428 		if !hasmapto('<Plug>delimitMate'.map, 'i') && maparg('<'.map.'>', 'i') == ''
   36              0.000816 			exec 'silent! imap <unique> <buffer> <'.map.'> <Plug>delimitMate'.map
   36              0.000032 		endif
   36              0.000027 	endfor
                            	" Avoid ambiguous mappings:
   18              0.000034 	for map in ['LeftMouse', 'RightMouse']
   12              0.000407 		exec 'inoremap <silent> <Plug>delimitMateM'.map.' <C-R>=delimitMate#Finish(1)<CR><'.map.'>'
   12              0.000506 		if !hasmapto('<Plug>delimitMate'.map, 'i') && maparg('<'.map.'>', 'i') == ''
   12              0.000325 			exec 'silent! imap <unique> <buffer> <'.map.'> <Plug>delimitMateM'.map
   12              0.000011 		endif
   12              0.000008 	endfor
                            
                            	" Jump over next delimiters
    6              0.000257 	inoremap <buffer> <Plug>delimitMateJumpMany <C-R>=len(b:_l_delimitMate_buffer) ? delimitMate#Finish(0) : delimitMate#JumpMany()<CR>
    6              0.000235 	if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
    6              0.000103 		imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
    6              0.000006 	endif

FUNCTION  neocomplcache#sources#member_complete#define()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   return s:source

FUNCTION  <SNR>45_Detect()
Called 1 time
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
    1              0.000008   if exists('b:rails_root')
                                return s:BufInit(b:rails_root)
                              endif
    1              0.000029   let fn = substitute(fnamemodify(a:filename,":p"),'\c^file://','','')
    1              0.000020   let sep = matchstr(fn,'^[^\\/]\{3,\}\zs[\\/]')
    1              0.000004   if sep != ""
                                let fn = getcwd().sep.fn
                              endif
    1              0.000009   if isdirectory(fn)
                                let fn = fnamemodify(fn,':s?[\/]$??')
                              else
    1              0.000036     let fn = fnamemodify(fn,':s?\(.*\)[\/][^\/]*$?\1?')
    1              0.000002   endif
    1              0.000003   let ofn = ""
    8              0.000033   while fn != ofn
    7              0.000102     if filereadable(fn . "/config/environment.rb")
                                  return s:BufInit(resolve(fn))
                                endif
    7              0.000026     let ofn = fn
    7              0.000051     let fn = fnamemodify(ofn,':h')
    7              0.000022   endwhile
    1              0.000003   return 0

FUNCTION  <SNR>164_vp_dlclose()
Called 1 time
Total time:   0.000460
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000459   0.000019   call s:libcall('vp_dlclose', [a:handle])

FUNCTION  <SNR>70_addtomrufs()
Called 5 times
Total time:   0.000432
 Self time:   0.000432

count  total (s)   self (s)
    5              0.000137 	let fn = fnamemodify(a:fname, ':p')
    5              0.000035 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    5              0.000253 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
                            	let idx = index(s:mrufs, fn, 0, !{s:cseno})
                            	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en

FUNCTION  346()
Called 1 time
Total time:   0.235397
 Self time:   0.000125

count  total (s)   self (s)
    1   0.000444   0.000005   call s:initialize_variables()
                            
    1   0.234659   0.000007   if neocomplcache#has_vimproc()
    1              0.000006     augroup neocomplcache
                                  " Caching events
    1              0.000021       autocmd BufWritePost * call s:check_buffer('', 0)
    1              0.000010       autocmd CursorHold * call s:check_cache()
    1              0.000002     augroup END
    1              0.000001   endif
                            
    1   0.000058   0.000016   call neocomplcache#util#set_default( 'g:neocomplcache_include_max_processes', 20)
                            
                              " Create cache directory.
    1   0.000149   0.000017   if !isdirectory(neocomplcache#get_temporary_directory() . '/include_cache')
                                call mkdir(neocomplcache#get_temporary_directory() . '/include_cache', 'p')
                              endif
                            
    1   0.000025   0.000018   if neocomplcache#exists_echodoc()
                                call echodoc#register('include_complete', s:doc_dict)
                              endif

FUNCTION  syntastic#util#unique()
Called 7 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    7              0.000012     let seen = {}
    7              0.000014     for e in a:list
                                    let seen[e] = 1
                                endfor
    7              0.000022     return copy(keys(seen))

FUNCTION  nerdtree#renderBookmarks()
Called 3 times
Total time:   0.000112
 Self time:   0.000093

count  total (s)   self (s)
                            
    3              0.000004     if g:NERDTreeMinimalUI == 0
    3              0.000013         call setline(line(".")+1, ">----------Bookmarks----------")
    3              0.000010         call cursor(line(".")+1, col("."))
    3              0.000003     endif
                            
    3   0.000031   0.000012     for i in g:NERDTreeBookmark.Bookmarks()
                                    call setline(line(".")+1, i.str())
                                    call cursor(line(".")+1, col("."))
                                endfor
                            
    3              0.000012     call setline(line(".")+1, '')
    3              0.000011     call cursor(line(".")+1, col("."))

FUNCTION  <SNR>148__redir()
Called 19 times
Total time:   0.009754
 Self time:   0.009754

count  total (s)   self (s)
   19              0.000107   let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
   19              0.000105   set verbose=0 verbosefile=
   19              0.000057   redir => res
   19              0.009108     silent! execute a:cmd
   19              0.000126   redir END
   19              0.000142   let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
   19              0.000069   return res

FUNCTION  neocomplcache#sources#snippets_complete#define()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007   return s:source

FUNCTION  ModePrefix()
Called 30 times
Total time:   0.002221
 Self time:   0.002221

count  total (s)   self (s)
   30              0.000386   let l:mode = mode()
   30              0.000188   if l:mode !=# g:last_mode
                                let g:last_mode = l:mode
                            
                                " mode
                                hi User2 guifg=#005f00 guibg=#dfff00 gui=bold ctermfg=22 ctermbg=190 term=bold
                                " mode seperator
                                hi User3 guifg=#dfff00 guibg=#444444 ctermfg=190 ctermbg=238
                                " info
                                hi User4 guifg=#ffffff guibg=#444444 ctermfg=255 ctermbg=238
                                " file info
                                hi User9 guifg=#ff0000 guibg=#1c1c1c ctermfg=160 ctermbg=233
                            
                                if l:mode ==# "i"
                                  hi User2 guibg=#00dfff guifg=#00005f ctermbg=45 ctermfg=17
                                  hi User3 guibg=#005fff guifg=#00dfff ctermbg=27 ctermfg=45
                                  hi User4 guibg=#005fff ctermbg=27
                                elseif l:mode ==? "v" || l:mode ==# ""
                                  hi User2 guibg=#ffaf00 guifg=#000000 ctermbg=214 ctermfg=0
                                  hi User3 guifg=#ffaf00 guibg=#ff5f00 ctermfg=214 ctermbg=202
                                  hi User4 guibg=#ff5f00 guifg=#000000 ctermbg=202 ctermfg=0
                                endif
                              endif
                            
   30              0.000121   if l:mode ==# "n"
   30              0.000100     return "  NORMAL "
                              elseif l:mode ==# "i"
                                return "  INSERT "
                              elseif l:mode ==# "R"
                                return "  RPLACE "
                              elseif l:mode ==# "v"
                                return "  VISUAL "
                              elseif l:mode ==# "V"
                                return "  VLINE "
                              elseif l:mode ==# ""
                                return "  VBLCK "
                              else
                                return l:mode
                              endif

FUNCTION  signature#MapKey()
Called 26 times
Total time:   0.083055
 Self time:   0.083055

count  total (s)   self (s)
                              " Description: Inverse of maparg()
                              "              Pass in a key sequence and the first letter of a vim mode.
                              "              Returns key mapping mapped to it in that mode, else '' if none.
                              " Example:     :nnoremap <Tab> :bn<CR>
                              "              :call Mapkey(':bn<CR>', 'n')
                              "              returns <Tab>
   26              0.064094   execute 'redir => l:mappings | silent! ' . a:mode . 'map | redir END'
                            
                              " Convert all text between angle-brackets to lowercase
                              " Required to recognize all case-variants of <c-A> and <C-a> as the same thing
   26              0.000254   let l:rhs = substitute(a:rhs, '<[^>]\+>', "\\L\\0", 'g')
                            
  380              0.006554   for l:map in split(l:mappings, '\n')
                                " Get rhs for each mapping
  380              0.003270     let l:lhs = split(l:map, '\s\+')[1]
  380              0.002731     let l:lhs_map = maparg(l:lhs, a:mode)
                            
  380              0.002349     if substitute(l:lhs_map, '<[^>]\+>', "\\L\\0", 'g') ==# l:rhs
   26              0.000047       return l:lhs
                                endif
  354              0.000921   endfor
                              return ''

FUNCTION  neocomplcache#util#set_dictionary_helper()
Called 153 times
Total time:   0.006908
 Self time:   0.001312

count  total (s)   self (s)
  153   0.006788   0.001192   return call(s:V.set_dictionary_helper, a:000)

FUNCTION  <SNR>148__get_module_path()
Called 15 times
Total time:   0.007536
 Self time:   0.006908

count  total (s)   self (s)
   15              0.000090   if filereadable(a:name)
                                return s:_unify_path(a:name)
                              endif
   15              0.000021   if a:name ==# ''
    5              0.000022     let tailpath = printf('autoload/vital/%s.vim', s:self_version)
    5              0.000008   elseif a:name =~# '\v^\u\a*%(\.\u\a*)*$'
   10              0.000069     let target = '/' . substitute(a:name, '\W\+', '/', 'g')
   10              0.000070     let target = substitute(target, '\l\zs\ze\u', '_', 'g') " OrderedSet -> Ordered_Set
   10              0.000071     let target = substitute(target, '[/_]\zs\u', '\l\0', 'g') " Ordered_Set -> ordered_set
   10              0.000051     let tailpath = printf('autoload/vital/%s%s.vim', s:self_version, target)
   10              0.000010   else
                                let tailpath = a:name
                              endif
                            
                              " Note: The extra argument to globpath() was added in Patch 7.2.051.
   15              0.000039   if v:version > 702 || v:version == 702 && has('patch51')
   15              0.005754     let paths = split(globpath(&runtimepath, tailpath, 1), "\n")
   15              0.000017   else
                                let paths = split(globpath(&runtimepath, tailpath), "\n")
                              endif
   15              0.000241   call filter(paths, 'filereadable(v:val)')
   15   0.000762   0.000134   return s:_unify_path(get(paths, 0, ''))

FUNCTION  nerdtree#dumpHelp()
Called 3 times
Total time:   0.000356
 Self time:   0.000356

count  total (s)   self (s)
    3              0.000008     let old_h = @h
    3              0.000004     if b:treeShowHelp ==# 1
                                    let @h=   "\" NERD tree (" . nerdtree#version() . ") quickhelp~\n"
                                    let @h=@h."\" ============================\n"
                                    let @h=@h."\" File node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let @h=@h."\" <CR>,\n"
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let @h=@h."\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if b:NERDTreeType ==# "primary"
                                        let @h=@h."\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let @h=@h."\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Directory node mappings~\n"
                                    let @h=@h."\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let @h=@h."\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let @h=@h."\"    current node recursively\n"
                                    let @h=@h."\" middle-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark table mappings~\n"
                                    let @h=@h."\" double-click,\n"
                                    let @h=@h."\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let @h=@h."\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let @h=@h."\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree navigation mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let @h=@h."\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Filesystem mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let @h=@h."\"    but leave old root open\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let @h=@h."\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let @h=@h."\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let @h=@h."\"    selected dir\n"
                                    let @h=@h."\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Tree filtering mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (b:NERDTreeShowHidden ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFilters .": file filters (" . (b:NERDTreeIgnoreEnabled ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleFiles .": files (" . (b:NERDTreeShowFiles ? "on" : "off") . ")\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (b:NERDTreeShowBookmarks ? "on" : "off") . ")\n"
                            
                                    "add quickhelp entries for each custom key map
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let @h=@h."\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Other mappings~\n"
                                    let @h=@h."\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let @h=@h."\"    the NERDTree window\n"
                                    let @h=@h."\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let @h=@h."\"\n\" ----------------------------\n"
                                    let @h=@h."\" Bookmark commands~\n"
                                    let @h=@h."\" :Bookmark <name>\n"
                                    let @h=@h."\" :BookmarkToRoot <name>\n"
                                    let @h=@h."\" :RevealBookmark <name>\n"
                                    let @h=@h."\" :OpenBookmark <name>\n"
                                    let @h=@h."\" :ClearBookmarks [<names>]\n"
                                    let @h=@h."\" :ClearAllBookmarks\n"
                                    silent! put h
                                elseif g:NERDTreeMinimalUI == 0
    3              0.000011         let @h="\" Press ". g:NERDTreeMapHelp ." for help\n"
    3              0.000036         silent! put h
    3              0.000001     endif
                            
    3              0.000006     let @h = old_h

FUNCTION  neobundle#autoload#filetype()
Called 2 times
Total time:   0.000230
 Self time:   0.000054

count  total (s)   self (s)
    2   0.000156   0.000012   let bundles = filter(neobundle#config#get_autoload_bundles(), "has_key(v:val.autoload, 'filetypes')")
    4   0.000032   0.000012   for filetype in neobundle#util#get_filetypes()
    2   0.000029   0.000017     call neobundle#config#source_bundles(filter(copy(bundles)," index(neobundle#util#convert2list(     v:val.autoload.filetypes), filetype) >= 0"))
    2              0.000002   endfor

FUNCTION  <SNR>148_load()
Called 6 times
Total time:   0.066927
 Self time:   0.000633

count  total (s)   self (s)
    6   0.055034   0.000047   let scripts = s:_scripts()
   12              0.000022   for arg in a:000
    6              0.000046     let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
    6              0.000043     let target = split(join(as, ''), '\W\+')
    6              0.000011     let dict = self
    8              0.000016     while 1 <= len(target)
    2              0.000005       let ns = remove(target, 0)
    2              0.000005       if !has_key(dict, ns)
    2              0.000005         let dict[ns] = {}
    2              0.000000       endif
    2              0.000006       if type(dict[ns]) == type({})
    2              0.000004         let dict = dict[ns]
    2              0.000001       else
                                    unlet dict
                                    break
                                  endif
    2              0.000001     endwhile
                            
    6              0.000013     if exists('dict')
    6   0.011443   0.000136       call extend(dict, s:_import(name, scripts))
    6              0.000005     endif
    6              0.000010     unlet arg
    6              0.000008   endfor
    6              0.000006   return self

FUNCTION  neocomplcache#helper#get_source_filetypes()
Called 1 time
Total time:   0.000172
 Self time:   0.000088

count  total (s)   self (s)
    1              0.000008   let filetype = (a:filetype == '') ? 'nothing' : a:filetype
                            
    1              0.000003   let filetype_dict = {}
                            
    1              0.000003   let filetypes = [filetype]
    1              0.000007   if filetype =~ '\.'
                                if exists('g:neocomplcache_ignore_composite_filetype_lists') && has_key(g:neocomplcache_ignore_composite_filetype_lists, filetype)
                                  let filetypes = [g:neocomplcache_ignore_composite_filetype_lists[filetype]]
                                else
                                  " Set composite filetype.
                                  let filetypes += split(filetype, '\.')
                                endif
                              endif
                            
    1              0.000006   if exists('g:neocomplcache_same_filetype_lists')
    2              0.000006     for ft in filetypes
    1              0.000013       let filetypes += split(get(g:neocomplcache_same_filetype_lists, ft, get(g:neocomplcache_same_filetype_lists, '_', '')), ',')
    1              0.000001     endfor
    1              0.000001   endif
                            
    1   0.000092   0.000008   return neocomplcache#util#uniq(filetypes)

FUNCTION  indent_guides#capture_highlight()
Called 13 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
   13              0.000051   redir => l:output
   13              0.000182   exe "silent hi " . a:group_name
   13              0.000042   redir END
                            
   13              0.000103   let l:output = substitute(l:output, "\n", "", "")
   13              0.000027   return l:output

FUNCTION  neocomplcache#sources#buffer_complete#define()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000004   return s:source

FUNCTION  <SNR>87_MarksList()
Called 10 times
Total time:   0.009971
 Self time:   0.009971

count  total (s)   self (s)
                              " Description: Returns a list of [mark, line no.] pairs that are in use in
                              "              the buffer or are free to be placed in which case, line no. is 0
                            
   10              0.000066   let l:SignatureIncludeMarks = ( exists('b:SignatureIncludeMarks') ? b:SignatureIncludeMarks : g:SignatureIncludeMarks )
   10              0.000020   let l:marks = []
                            
  270              0.000567   for i in split("abcdefghijklmnopqrstuvwxyz", '\zs')
  260              0.001250     if stridx(l:SignatureIncludeMarks, toupper(i)) >= 0
  260              0.001842       let [ l:buf, l:line, l:col, l:off ] = getpos("'" . toupper(i))
  260              0.000824       if l:buf == bufnr('%') || l:buf == 0
                                    " Add uppercase mark to list if it is in use in this buffer or hasn't been used at all.
  250              0.001284         let l:marks = add(l:marks, [toupper(i), l:line])
  250              0.000218       endif
  260              0.000166     endif
  260              0.000942     if stridx(l:SignatureIncludeMarks, i) >= 0
  260              0.001442       let l:marks = add(l:marks, [i, line("'" . i)])
  260              0.000227     endif
  260              0.000238   endfor
                            
   10              0.000016   return l:marks

FUNCTION  indent_guides#enable()
Called 13 times
Total time:   0.039828
 Self time:   0.018232

count  total (s)   self (s)
   13              0.000034   let g:indent_guides_autocmds_enabled = 1
                            
   13   0.000399   0.000077   if &diff || indent_guides#exclude_filetype()
                                call indent_guides#clear_matches()
                                return
                              end
                            
   13   0.001684   0.000054   call indent_guides#init_script_vars()
   13   0.000261   0.000115   call indent_guides#highlight_colors()
   13   0.008268   0.000058   call indent_guides#clear_matches()
                            
                              " loop through each indent level and define a highlight pattern
                              " will automagically figure out whether to use tabs or spaces
  403              0.000540   for l:level in range(s:start_level, s:indent_levels)
  390              0.001363     let l:group = 'IndentGuides' . ((l:level % 2 == 0) ? 'Even' : 'Odd')
  390              0.001389     let l:column_start = (l:level - 1) * s:indent_size + 1
  390   0.008404   0.002658     let l:soft_pattern = indent_guides#indent_highlight_pattern('\s', l:column_start, s:guide_size)
  390   0.008068   0.002526     let l:hard_pattern = indent_guides#indent_highlight_pattern('\t', l:column_start, s:indent_size)
                            
                                " define the higlight patterns and add to matches list
  390              0.000565     if g:indent_guides_space_guides
  390              0.003698       call add(w:indent_guides_matches, matchadd(l:group, l:soft_pattern))
  390              0.000325     end
  390              0.003447     call add(w:indent_guides_matches, matchadd(l:group, l:hard_pattern))
  390              0.000395   endfor

FUNCTION  53()
Called 26 times
Total time:   0.009165
 Self time:   0.003991

count  total (s)   self (s)
   26   0.001142   0.000168     call self.extractDriveLetter(a:fullpath)
                            
   26   0.000715   0.000202     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
   26              0.000291     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
   26              0.000302     let self.pathSegments = split(fullpath, '/')
                            
   26              0.000110     let self.isReadOnly = 0
   26              0.000177     if isdirectory(a:fullpath)
   15              0.000077         let self.isDirectory = 1
   15              0.000042     elseif filereadable(a:fullpath)
   10              0.000045         let self.isDirectory = 0
   10              0.000109         let self.isReadOnly = filewritable(a:fullpath) ==# 0
   10              0.000014     else
    1              0.002142         throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
   25              0.000088     let self.isExecutable = 0
   25              0.000043     if !self.isDirectory
   10              0.000091         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
   10              0.000012     endif
                            
                                "grab the last part of the path (minus the trailing slash)
   25   0.000680   0.000242     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
   25   0.002025   0.000328     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
   25   0.001948   0.000396     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
   25              0.000053     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  vital#_a477c91#new()
Called 5 times
Total time:   0.122783
 Self time:   0.000292

count  total (s)   self (s)
    5   0.122778   0.000287   return s:_import('', s:_scripts()).load(['Prelude', ''])

FUNCTION  indent_guides#exclude_filetype()
Called 13 times
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
   22              0.000155   for ft in split(&ft, '\.')
    9              0.000042     if index(g:indent_guides_exclude_filetypes, ft) > -1
                                  return 1
                                end
    9              0.000006   endfor
   13              0.000015   return 0

FUNCTION  <SNR>67_IsModeTracked()
Called 1 time
Total time:   0.000084
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000082   0.000006     call s:SanitizeMode()
    1              0.000002     return g:EasyGrepMode == s:EasyGrepModeTracked

FUNCTION  neobundle#util#substitute_path_separator()
Called 5 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    5              0.000021   return (s:is_windows && a:path =~ '\\') ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  vimproc#util#termencoding()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000005   return 'char'

FUNCTION  vital#_08a462e#new()
Called 1 time
Total time:   0.044458
 Self time:   0.000079

count  total (s)   self (s)
    1   0.044456   0.000077   return s:_import('', s:_scripts()).load(['Prelude', ''])

FUNCTION  SyntasticStatuslineFlag()
Called 30 times
Total time:   0.004250
 Self time:   0.003171

count  total (s)   self (s)
   30   0.000825   0.000329     let loclist = g:SyntasticLoclist.current()
   30   0.000475   0.000240     let issues = loclist.filteredRaw()
   30   0.000365   0.000222     let num_issues = loclist.length()
   30   0.000396   0.000191     if loclist.hasErrorsOrWarningsToDisplay()
                                    let errors = loclist.errors()
                                    let warnings = loclist.warnings()
                            
                                    let num_errors = len(errors)
                                    let num_warnings = len(warnings)
                            
                                    let output = g:syntastic_stl_format
                            
                                    "hide stuff wrapped in %E(...) unless there are errors
                                    let output = substitute(output, '\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                    "hide stuff wrapped in %W(...) unless there are warnings
                                    let output = substitute(output, '\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                    "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                    let output = substitute(output, '\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                            
                                    "sub in the total errors/warnings/both
                                    let output = substitute(output, '\C%w', num_warnings, 'g')
                                    let output = substitute(output, '\C%e', num_errors, 'g')
                                    let output = substitute(output, '\C%t', num_issues, 'g')
                            
                                    "first error/warning line num
                                    let output = substitute(output, '\C%F', num_issues ? issues[0]['lnum'] : '', 'g')
                            
                                    "first error line num
                                    let output = substitute(output, '\C%fe', num_errors ? errors[0]['lnum'] : '', 'g')
                            
                                    "first warning line num
                                    let output = substitute(output, '\C%fw', num_warnings ? warnings[0]['lnum'] : '', 'g')
                            
                                    return output
                                else
   30              0.000038         return ''
                                endif

FUNCTION  neocomplcache#util#set_default()
Called 19 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
   19              0.000153   if !exists(a:var) || type({a:var}) != type(a:val)
   12              0.000076     let alternate_var = get(a:000, 0, '')
                            
   12              0.000112     let {a:var} = exists(alternate_var) ? {alternate_var} : a:val
   12              0.000016   endif

FUNCTION  signature#Toggle()
Called 7 times
Total time:   0.040659
 Self time:   0.000410

count  total (s)   self (s)
                              " Description: Toggles and refreshes sign display in the buffer.
                              " Arguments:   When mode = 1, toggle sign display.
                              "                        = 0, don't toggle, preserve existing state. Useful for recreating maps when returning from
                              "                             buffers in which Signature and its maps have been disabled
                            
    7              0.000038   if !exists('b:sig_marks')   | let b:sig_marks   = {} | endif
                              " b:sig_marks   = { lnum:marks_str }
    7              0.000031   if !exists('b:sig_markers') | let b:sig_markers = {} | endif
                              " b:sig_markers = { lnum:marker }
                            
    7              0.000018   if !exists( 'b:sig_status' )
    4              0.000006     let b:sig_status  = 1
    4              0.000005   elseif ( a:mode )
                                let b:sig_status = !b:sig_status
                              endif
                            
                              " Enable/disable mappings
    7   0.024975   0.000052   call signature#BufferMaps( g:SignatureEnableDefaultMappings && b:sig_status )
                            
    7              0.000027   if b:sig_status
                                " Signature enabled ==> Refresh signs
    7   0.015385   0.000059     call signature#SignRefresh()
    7              0.000007   else
                                " Signature has been disabled
                                for i in range(1, line('$'))
                                  let l:id = ( winbufnr(0) + 1 ) * i
                                  execute 'sign unplace ' . l:id
                                endfor
                                unlet b:sig_marks
                              endif
                            

FUNCTION  vital#of()
Called 5 times
Total time:   0.187899
 Self time:   0.036855

count  total (s)   self (s)
    5              0.003691   let files = globpath(&runtimepath, 'autoload/vital/' . a:name . '.vital')
    5              0.000053   let file = split(files, "\n")
    5              0.000018   if empty(file)
                                throw 'vital: version file not found: ' . a:name
                              endif
    5              0.031226   let ver = readfile(file[0], 'b')
    5              0.000042   if empty(ver)
                                throw 'vital: invalid version file: ' . a:name
                              endif
    5   0.152796   0.001752   return vital#_{substitute(ver[0], '\W', '', 'g')}#new()

FUNCTION  neocomplcache#init#_source()
Called 13 times
Total time:   0.325830
 Self time:   0.002188

count  total (s)   self (s)
   13   0.000783   0.000372   let default = { 'max_candidates' : 0, 'filetypes' : {}, 'hooks' : {}, 'matchers' : ['matcher_old'], 'sorters' : ['sorter_rank'], 'converters' : [      'converter_remove_next_keyword',      'converter_delimiter',      'converter_case',      'converter_abbr', ], 'neocomplcache__context' : copy(neocomplcache#get_context()), }
                            
   13              0.000174   let source = extend(copy(default), a:source)
                            
                              " Overwritten by user custom.
   13   0.000304   0.000118   let custom = neocomplcache#variables#get_custom().sources
   13              0.000128   let source = extend(source, get(custom, source.name, get(custom, '_', {})))
                            
   13              0.000046   let source.loaded = 0
                              " Source kind convertion.
   13              0.000130   if source.kind ==# 'plugin' || (!has_key(source, 'gather_candidates') &&  !has_key(source, 'get_complete_words'))
    4              0.000013     let source.kind = 'keyword'
    4              0.000015   elseif source.kind ==# 'ftplugin' || source.kind ==# 'complfunc'
                                " For compatibility.
    3              0.000009     let source.kind = 'manual'
    3              0.000003   else
    6              0.000015     let source.kind = 'manual'
    6              0.000006   endif
                            
   13              0.000040   if !has_key(source, 'rank')
                                " Set default rank.
    4              0.000030     let source.rank = (source.kind ==# 'keyword') ? 5 : empty(source.filetypes) ? 10 : 100
    4              0.000006   endif
                            
   13              0.000046   if !has_key(source, 'min_pattern_length')
                                " Set min_pattern_length.
    7              0.000052     let source.min_pattern_length = (source.kind ==# 'keyword') ? g:neocomplcache_auto_completion_start_length : 0
    7              0.000008   endif
                            
   13              0.000054   let source.neocomplcache__context.source_name = source.name
                            
                              " Note: This routine is for compatibility of old sources implementation.
                              " Initialize sources.
   13              0.000060   if empty(source.filetypes) && has_key(source, 'initialize')
    9              0.000017     try
    9   0.323115   0.000070       call source.initialize()
    9              0.000012     catch
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  call neocomplcache#print_error( 'Error occured in source''s initialize()!')
                                  call neocomplcache#print_error( 'Source name is ' . source.name)
                                endtry
                            
    9              0.000027     let source.loaded = 1
    9              0.000011   endif
                            
   13              0.000023   return source

FUNCTION  <SNR>47_stop()
Called 4 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    4              0.000016   if !has_key(s:sy, a:path)
    4              0.000006     return
                              endif
                            
                              call s:sign_remove_all(a:path)
                            
                              silent! nunmap <buffer> ]c
                              silent! nunmap <buffer> [c
                            
                              augroup signify
                                autocmd! * <buffer>
                              augroup END
                            
                              let s:sy[s:path].active = 0

FUNCTION  neobundle#util#get_filetypes()
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000010   let filetype = exists('b:neocomplcache.context_filetype') ? b:neocomplcache.context_filetype : &filetype
    2              0.000010   return split(filetype, '\.')

FUNCTION  nerdtree#treeMarkupReg()
Called 14 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
   14              0.000034     if g:NERDTreeDirArrows
   14              0.000044         return '^\([] \| \+[] \| \+\)'
                                endif
                            
                                return '^[ `|]*[\-+~]'

FUNCTION  <SNR>163_initialize_variables()
Called 2 times
Total time:   0.000924
 Self time:   0.000187

count  total (s)   self (s)
    2              0.000009   let s:include_info = {}
    2              0.000004   let s:include_cache = {}
    2              0.000004   let s:cache_accessed_time = {}
    2              0.000004   let s:async_include_cache = {}
    2              0.000004   let s:cached_pattern = {}
                            
                              " Initialize include pattern. "{{{
    2              0.000009   let g:neocomplcache_include_patterns = get(g:, 'neocomplcache_include_patterns', {})
    2   0.000145   0.000014   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_patterns', 'java,haskell', '^\s*\<import')
    2   0.000111   0.000013   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_patterns', 'cs', '^\s*\<using')
    2   0.000108   0.000014   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_patterns', 'ruby', '^\s*\<\%(load\|require\|require_relative\)\>')
                              "}}}
                              " Initialize expr pattern. "{{{
    2   0.000041   0.000011   call neocomplcache#util#set_default( 'g:neocomplcache_include_exprs', {})
    2   0.000136   0.000018   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_exprs', 'haskell,cs', "substitute(v:fname, '\\.', '/', 'g')")
                              "}}}
                              " Initialize path pattern. "{{{
    2   0.000038   0.000010   call neocomplcache#util#set_default( 'g:neocomplcache_include_paths', {})
                              "}}}
                              " Initialize include suffixes. "{{{
    2   0.000036   0.000010   call neocomplcache#util#set_default( 'g:neocomplcache_include_suffixes', {})
    2   0.000103   0.000012   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_suffixes', 'haskell', '.hs')
                              "}}}
                              " Initialize include functions. "{{{
    2   0.000040   0.000010   call neocomplcache#util#set_default( 'g:neocomplcache_include_functions', {})
                              " call neocomplcache#util#set_default_dictionary(
                              "       \ 'g:neocomplcache_include_functions', 'vim',
                              "       \ 'neocomplcache#sources#include_complete#analyze_vim_include_files')
    2   0.000105   0.000014   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_functions', 'ruby', 'neocomplcache#sources#include_complete#analyze_ruby_include_files')
                              "}}}

FUNCTION  146()
Called 3 times
Total time:   0.009696
 Self time:   0.000026

count  total (s)   self (s)
    3   0.009694   0.000024     return self._renderToString(0, 0, [], self.getChildCount() ==# 1)

FUNCTION  147()
Called 45 times
Total time:   0.013730
 Self time:   0.012315

count  total (s)   self (s)
   45              0.000069     let output = ""
   45              0.000049     if a:drawText ==# 1
                            
   42              0.000054         let treeParts = ''
                            
                                    "get all the leading spaces and vertical tree parts for this line
   42              0.000041         if a:depth > 1
                                        for j in a:vertMap[0:-2]
                                            if g:NERDTreeDirArrows
                                                let treeParts = treeParts . '  '
                                            else
                                                if j ==# 1
                                                    let treeParts = treeParts . '| '
                                                else
                                                    let treeParts = treeParts . '  '
                                                endif
                                            endif
                                        endfor
                                    endif
                            
                                    "get the last vertical tree part for this line which will be different
                                    "if this node is the last child of its parent
   42              0.000049         if !g:NERDTreeDirArrows
                                        if a:isLastChild
                                            let treeParts = treeParts . '`'
                                        else
                                            let treeParts = treeParts . '|'
                                        endif
                                    endif
                            
                                    "smack the appropriate dir/file symbol on the line before the file/dir
                                    "name itself
   42              0.000043         if self.path.isDirectory
   18              0.000016             if self.isOpen
                                            if g:NERDTreeDirArrows
                                                let treeParts = treeParts . ' '
                                            else
                                                let treeParts = treeParts . '~'
                                            endif
                                        else
   18              0.000019                 if g:NERDTreeDirArrows
   18              0.000035                     let treeParts = treeParts . ' '
   18              0.000011                 else
                                                let treeParts = treeParts . '+'
                                            endif
   18              0.000009             endif
   18              0.000007         else
   24              0.000024             if g:NERDTreeDirArrows
   24              0.000054                 let treeParts = treeParts . '  '
   24              0.000017             else
                                            let treeParts = treeParts . '-'
                                        endif
   24              0.000017         endif
   42   0.001220   0.000158         let line = treeParts . self.displayString()
                            
   42              0.000102         let output = output . line . "\n"
   42              0.000026     endif
                            
                                "if the node is an open dir, draw its children
   45              0.000064     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    3   0.004955   0.000018         let childNodesToDraw = self.getVisibleChildren()
    3              0.000006         if len(childNodesToDraw) > 0
                            
                                        "draw all the nodes children except the last
    3              0.000009             let lastIndx = len(childNodesToDraw)-1
    3              0.000003             if lastIndx > 0
   42              0.000052                 for i in childNodesToDraw[0:lastIndx-1]
   39              0.000216                     let output = output . i._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 1), 0)
   39              0.000044                 endfor
    3              0.000002             endif
                            
                                        "draw the last child, indicating that it IS the last
    3              0.000018             let output = output . childNodesToDraw[lastIndx]._renderToString(a:depth + 1, 1, add(copy(a:vertMap), 0), 1)
    3              0.000002         endif
    3              0.000000     endif
                            
   45              0.000038     return output

FUNCTION  BeautifierEditorconfigHook()
Called 1 time
Total time:   0.000060
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000008   let type = expand('%:e')
    1              0.000003   let config = a:config
                            
    1              0.000005   if !(type(config) == 4)
                                return 1
                              endif
                            
    1   0.000036   0.000013   if !s:isAllowedType(type)
    1              0.000002     return 1
                              endif
                            
                            
                              " If buffer config variable does not exist
                              " then let it
                              if !exists('b:config_Beautifier')
                                let b:config_Beautifier = deepcopy(g:config_Beautifier)
                              endif
                            
                              if !len(config)
                                call s:updateConfig(g:config_Beautifier)
                                return 1
                              endif
                            
                              if empty(get(b:config_Beautifier, type))
                                call WarningMsg('Type '.type.' is not presented in config')
                                return 1
                              endif
                            
                              let config = extend(b:config_Beautifier[type], config)
                            
                              call s:treatConfig(config)
                            
                              let b:config_Beautifier[type] = config
                            
                              " All Ok! retun 0
                              return 0

FUNCTION  <SNR>70_chop()
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000015 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000002 	retu a:mrufs

FUNCTION  <SNR>64_Unmap()
Called 2 times
Total time:   0.001867
 Self time:   0.001867

count  total (s)   self (s)
    2              0.000135 	let imaps = b:_l_delimitMate_right_delims + b:_l_delimitMate_left_delims + b:_l_delimitMate_quotes_list + b:_l_delimitMate_apostrophes_list + ['<BS>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
   64              0.000083 	for map in imaps
   62              0.000723 		if maparg(map, "i") =~? 'delimitMate'
   56              0.000106 			if map == '|'
                            				let map = '<Bar>'
                            			endif
   56              0.000451 			exec 'silent! iunmap <buffer> ' . map
   56              0.000040 		endif
   62              0.000060 	endfor
                            
    2              0.000009 	if !has('gui_running')
    2              0.000059 		silent! iunmap <C-[>OC
    2              0.000002 	endif
                            
    2              0.000006 	let b:delimitMate_enabled = 0

FUNCTION  nerdtree#closeTree()
Called 2 times
Total time:   0.025272
 Self time:   0.000355

count  total (s)   self (s)
    2   0.000081   0.000010     if !nerdtree#isTreeOpen()
                                    throw "NERDTree.NoTreeFoundError: no NERDTree is open"
                                endif
                            
    2              0.000006     if winnr("$") != 1
    2   0.000059   0.000016         if winnr() == nerdtree#getTreeWinNum()
    2   0.000583   0.000014             call nerdtree#exec("wincmd p")
    2              0.000008             let bufnr = bufnr("")
    2   0.000478   0.000019             call nerdtree#exec("wincmd p")
    2              0.000002         else
                                        let bufnr = bufnr("")
                                    endif
                            
    2   0.000376   0.000030         call nerdtree#exec(nerdtree#getTreeWinNum() . " wincmd w")
    2   0.023590   0.000202         close
    2   0.000056   0.000015         call nerdtree#exec(bufwinnr(bufnr) . " wincmd w")
    2              0.000002     else
                                    close
                                endif

FUNCTION  neocomplcache#exists_echodoc()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return exists('g:loaded_echodoc') && g:loaded_echodoc

FUNCTION  <SNR>149_set_dictionary_helper()
Called 153 times
Total time:   0.005596
 Self time:   0.005596

count  total (s)   self (s)
  405              0.001904   for key in split(a:keys, '\s*,\s*')
  252              0.000923     if !has_key(a:variable, key)
  240              0.000981       let a:variable[key] = a:pattern
  240              0.000239     endif
  252              0.000341   endfor

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    3   0.710420   0.032611  neocomplcache#init#lazy()
    1   0.482394   0.101474  neocomplcache#init#_sources()
   13   0.326689   0.000586  neocomplcache#define_source()
   13   0.325830   0.002188  neocomplcache#init#_source()
    3   0.303400   0.000887  nerdtree#findAndRevealPath()
    2   0.258788   0.000994  199()
    1   0.235397   0.000125  346()
    1   0.234652   0.000010  neocomplcache#has_vimproc()
    1   0.234642   0.119088  neocomplcache#util#has_vimproc()
    1   0.206521   0.000018  193()
    1   0.206483   0.000096  194()
    1   0.192594   0.001772  neocomplcache#init#_others()
    5   0.187899   0.036855  vital#of()
    1   0.187414   0.002717  neocomplcache#init#_variables()
    2   0.144195   0.000075  <SNR>12_yank_with_key()
    2   0.144120   0.000131  <SNR>12_before_yank()
    2   0.143989   0.143861  <SNR>12_get_yankstack_head()
   15   0.143676   0.062147  <SNR>148__scripts()
    2   0.137186   0.000110  204()
    5   0.122783   0.000292  vital#_a477c91#new()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2   0.143989   0.143861  <SNR>12_get_yankstack_head()
    1   0.234642   0.119088  neocomplcache#util#has_vimproc()
    1   0.482394   0.101474  neocomplcache#init#_sources()
   26              0.083055  signature#MapKey()
 2313              0.076975  <SNR>148__unify_path()
   15   0.143676   0.062147  <SNR>148__scripts()
   15   0.066881   0.053703  <SNR>148__build_module()
    1              0.041768  vimproc#util#iconv()
    5   0.187899   0.036855  vital#of()
    3   0.710420   0.032611  neocomplcache#init#lazy()
    1   0.031493   0.030192  ctrlp#mrufiles#cachefile()
    9   0.111469   0.028414  signature#BufferMaps()
    6              0.021283  <SNR>64_ExtraMappings()
    1   0.082970   0.020244  367()
    2   0.021467   0.020079  <SNR>31_SynSet()
   13   0.039828   0.018232  indent_guides#enable()
    1              0.017890  ctrlp#utils#readfile()
  348              0.013555  <SNR>173__unify_path()
    2   0.016500   0.013475  <SNR>173__build_module()
    1   0.013842   0.013411  <SNR>56_UseConfigFiles_Python_Builtin()

